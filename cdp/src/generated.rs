#![allow(deprecated)]
#[macro_export]
macro_rules ! cdp_stable_protocol_version { ( ) => ( "1.3" ) }
pub const STABLE_PROTOCOL_VERSION: &str = cdp_stable_protocol_version!();
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Accessibility\n\n## Commands\n\n- [`Accessibility.getPartialAXTree`](struct.GetPartialAxTreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n- [`Accessibility.getFullAXTree`](struct.GetFullAxTreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fetches the entire accessibility tree\n\n##Types\n\n- [`AXNodeId`](type.AxNodeId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique accessibility node identifier.\n- [`AXValueType`](enum.AxValueType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible property types.\n- [`AXValueSourceType`](enum.AxValueSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible property sources.\n- [`AXValueNativeSourceType`](enum.AxValueNativeSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible native property sources \\(as a subtype of a particular AXValueSourceType\\).\n- [`AXValueSource`](struct.AxValueSource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A single source for a computed AX property.\n- [`AXRelatedNode`](struct.AxRelatedNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`AXProperty`](struct.AxProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`AXValue`](struct.AxValue.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A single computed AX property.\n- [`AXPropertyName`](enum.AxPropertyName.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Values of AXProperty name: from 'busy' to 'roledescription' - states which apply to every AX\n  node, from 'live' to 'root' - attributes which apply to nodes in live regions, from\n  'autocomplete' to 'valuetext' - attributes which apply to widgets, from 'checked' to 'selected'\n  - states which apply to widgets, from 'activedescendant' to 'owns' - relationships between\n  elements other than parent/child/sibling.\n- [`AXNode`](struct.AxNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A node in the accessibility tree.\n"]
pub mod accessibility {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n\n# Command `Accessibility.getPartialAXTree`\n\n*Domain Module:* [`cdp::accessibility`](index.html)  \n*Command Struct:* [`cdp::accessibility::GetPartialAxTreeCommand`](struct.GetPartialAxTreeCommand.html)  \n*Response Struct:* [`cdp::accessibility::GetPartialAxTreeResponse`](struct.GetPartialAxTreeResponse.html)"]
    pub struct GetPartialAxTreeCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node to get the partial accessibility tree for."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node to get the partial accessibility tree for."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper to get the partial accessibility tree for."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
        #[serde(rename = "fetchRelatives", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to fetch this nodes ancestors, siblings and children. Defaults to true."]
        pub fetch_relatives: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetPartialAxTreeCommand<'a> {
        const COMMAND_NAME: &'static str = "Accessibility.getPartialAXTree";
    }
    impl<'a> ::SerializeCdpCommand for GetPartialAxTreeCommand<'a> {
        fn command_name(&self) -> &str {
            "Accessibility.getPartialAXTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetPartialAxTreeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Accessibility.getPartialAXTree" {
                Ok ( < GetPartialAxTreeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.\n\n# Command `Accessibility.getPartialAXTree`\n\n*Domain Module:* [`cdp::accessibility`](index.html)  \n*Command Struct:* [`cdp::accessibility::GetPartialAxTreeCommand`](struct.GetPartialAxTreeCommand.html)  \n*Response Struct:* [`cdp::accessibility::GetPartialAxTreeResponse`](struct.GetPartialAxTreeResponse.html)"]
    pub struct GetPartialAxTreeResponse<'a> {
        #[serde(rename = "nodes")]
        #[doc = "The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and\nchildren, if requested."]
        pub nodes: Vec<::accessibility::AxNode<'a>>,
    }
    impl<'a> ::CdpCommand for GetPartialAxTreeResponse<'a> {
        const COMMAND_NAME: &'static str = "Accessibility.getPartialAXTree";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetPartialAxTreeCommand<'a> {
        type Response = GetPartialAxTreeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetPartialAxTreeResponse<'b> {
        type Command = GetPartialAxTreeCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the entire accessibility tree\n\n# Command `Accessibility.getFullAXTree`\n\n*Domain Module:* [`cdp::accessibility`](index.html)  \n*Command Struct:* [`cdp::accessibility::GetFullAxTreeCommand`](struct.GetFullAxTreeCommand.html)  \n*Response Struct:* [`cdp::accessibility::GetFullAxTreeResponse`](struct.GetFullAxTreeResponse.html)"]
    pub struct GetFullAxTreeCommand;
    impl ::serde::Serialize for GetFullAxTreeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetFullAxTreeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetFullAxTreeCommand)
        }
    }
    impl ::CdpCommand for GetFullAxTreeCommand {
        const COMMAND_NAME: &'static str = "Accessibility.getFullAXTree";
    }
    impl ::SerializeCdpCommand for GetFullAxTreeCommand {
        fn command_name(&self) -> &str {
            "Accessibility.getFullAXTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetFullAxTreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Accessibility.getFullAXTree" {
                Ok(
                    <GetFullAxTreeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches the entire accessibility tree\n\n# Command `Accessibility.getFullAXTree`\n\n*Domain Module:* [`cdp::accessibility`](index.html)  \n*Command Struct:* [`cdp::accessibility::GetFullAxTreeCommand`](struct.GetFullAxTreeCommand.html)  \n*Response Struct:* [`cdp::accessibility::GetFullAxTreeResponse`](struct.GetFullAxTreeResponse.html)"]
    pub struct GetFullAxTreeResponse<'a> {
        #[serde(rename = "nodes")]
        pub nodes: Vec<::accessibility::AxNode<'a>>,
    }
    impl<'a> ::CdpCommand for GetFullAxTreeResponse<'a> {
        const COMMAND_NAME: &'static str = "Accessibility.getFullAXTree";
    }
    impl<'b> ::HasCdpResponse<'b> for GetFullAxTreeCommand {
        type Response = GetFullAxTreeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetFullAxTreeResponse<'b> {
        type Command = GetFullAxTreeCommand;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique accessibility node identifier."]
    pub type AxNodeId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible property types."]
    pub enum AxValueType {
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "tristate")]
        #[doc = "Represented as `\"tristate\"`."]
        Tristate,
        #[serde(rename = "booleanOrUndefined")]
        #[doc = "Represented as `\"booleanOrUndefined\"`."]
        BooleanOrUndefined,
        #[serde(rename = "idref")]
        #[doc = "Represented as `\"idref\"`."]
        Idref,
        #[serde(rename = "idrefList")]
        #[doc = "Represented as `\"idrefList\"`."]
        IdrefList,
        #[serde(rename = "integer")]
        #[doc = "Represented as `\"integer\"`."]
        Integer,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "nodeList")]
        #[doc = "Represented as `\"nodeList\"`."]
        NodeList,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "computedString")]
        #[doc = "Represented as `\"computedString\"`."]
        ComputedString,
        #[serde(rename = "token")]
        #[doc = "Represented as `\"token\"`."]
        Token,
        #[serde(rename = "tokenList")]
        #[doc = "Represented as `\"tokenList\"`."]
        TokenList,
        #[serde(rename = "domRelation")]
        #[doc = "Represented as `\"domRelation\"`."]
        DomRelation,
        #[serde(rename = "role")]
        #[doc = "Represented as `\"role\"`."]
        Role,
        #[serde(rename = "internalRole")]
        #[doc = "Represented as `\"internalRole\"`."]
        InternalRole,
        #[serde(rename = "valueUndefined")]
        #[doc = "Represented as `\"valueUndefined\"`."]
        ValueUndefined,
    }
    impl AxValueType {
        pub const ENUM_VALUES: &'static [AxValueType] = &[
            AxValueType::Boolean,
            AxValueType::Tristate,
            AxValueType::BooleanOrUndefined,
            AxValueType::Idref,
            AxValueType::IdrefList,
            AxValueType::Integer,
            AxValueType::Node,
            AxValueType::NodeList,
            AxValueType::Number,
            AxValueType::String,
            AxValueType::ComputedString,
            AxValueType::Token,
            AxValueType::TokenList,
            AxValueType::DomRelation,
            AxValueType::Role,
            AxValueType::InternalRole,
            AxValueType::ValueUndefined,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "boolean",
            "tristate",
            "booleanOrUndefined",
            "idref",
            "idrefList",
            "integer",
            "node",
            "nodeList",
            "number",
            "string",
            "computedString",
            "token",
            "tokenList",
            "domRelation",
            "role",
            "internalRole",
            "valueUndefined",
        ];
    }
    impl ::std::str::FromStr for AxValueType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "boolean" => Ok(AxValueType::Boolean),
                "tristate" => Ok(AxValueType::Tristate),
                "booleanOrUndefined" => Ok(AxValueType::BooleanOrUndefined),
                "idref" => Ok(AxValueType::Idref),
                "idrefList" => Ok(AxValueType::IdrefList),
                "integer" => Ok(AxValueType::Integer),
                "node" => Ok(AxValueType::Node),
                "nodeList" => Ok(AxValueType::NodeList),
                "number" => Ok(AxValueType::Number),
                "string" => Ok(AxValueType::String),
                "computedString" => Ok(AxValueType::ComputedString),
                "token" => Ok(AxValueType::Token),
                "tokenList" => Ok(AxValueType::TokenList),
                "domRelation" => Ok(AxValueType::DomRelation),
                "role" => Ok(AxValueType::Role),
                "internalRole" => Ok(AxValueType::InternalRole),
                "valueUndefined" => Ok(AxValueType::ValueUndefined),
                _ => Err(::ParseEnumError {
                    expected: AxValueType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueType::Boolean => "boolean",
                    AxValueType::Tristate => "tristate",
                    AxValueType::BooleanOrUndefined => "booleanOrUndefined",
                    AxValueType::Idref => "idref",
                    AxValueType::IdrefList => "idrefList",
                    AxValueType::Integer => "integer",
                    AxValueType::Node => "node",
                    AxValueType::NodeList => "nodeList",
                    AxValueType::Number => "number",
                    AxValueType::String => "string",
                    AxValueType::ComputedString => "computedString",
                    AxValueType::Token => "token",
                    AxValueType::TokenList => "tokenList",
                    AxValueType::DomRelation => "domRelation",
                    AxValueType::Role => "role",
                    AxValueType::InternalRole => "internalRole",
                    AxValueType::ValueUndefined => "valueUndefined",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible property sources."]
    pub enum AxValueSourceType {
        #[serde(rename = "attribute")]
        #[doc = "Represented as `\"attribute\"`."]
        Attribute,
        #[serde(rename = "implicit")]
        #[doc = "Represented as `\"implicit\"`."]
        Implicit,
        #[serde(rename = "style")]
        #[doc = "Represented as `\"style\"`."]
        Style,
        #[serde(rename = "contents")]
        #[doc = "Represented as `\"contents\"`."]
        Contents,
        #[serde(rename = "placeholder")]
        #[doc = "Represented as `\"placeholder\"`."]
        Placeholder,
        #[serde(rename = "relatedElement")]
        #[doc = "Represented as `\"relatedElement\"`."]
        RelatedElement,
    }
    impl AxValueSourceType {
        pub const ENUM_VALUES: &'static [AxValueSourceType] = &[
            AxValueSourceType::Attribute,
            AxValueSourceType::Implicit,
            AxValueSourceType::Style,
            AxValueSourceType::Contents,
            AxValueSourceType::Placeholder,
            AxValueSourceType::RelatedElement,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "attribute",
            "implicit",
            "style",
            "contents",
            "placeholder",
            "relatedElement",
        ];
    }
    impl ::std::str::FromStr for AxValueSourceType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "attribute" => Ok(AxValueSourceType::Attribute),
                "implicit" => Ok(AxValueSourceType::Implicit),
                "style" => Ok(AxValueSourceType::Style),
                "contents" => Ok(AxValueSourceType::Contents),
                "placeholder" => Ok(AxValueSourceType::Placeholder),
                "relatedElement" => Ok(AxValueSourceType::RelatedElement),
                _ => Err(::ParseEnumError {
                    expected: AxValueSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueSourceType::Attribute => "attribute",
                    AxValueSourceType::Implicit => "implicit",
                    AxValueSourceType::Style => "style",
                    AxValueSourceType::Contents => "contents",
                    AxValueSourceType::Placeholder => "placeholder",
                    AxValueSourceType::RelatedElement => "relatedElement",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible native property sources \\(as a subtype of a particular AXValueSourceType\\)."]
    pub enum AxValueNativeSourceType {
        #[serde(rename = "figcaption")]
        #[doc = "Represented as `\"figcaption\"`."]
        Figcaption,
        #[serde(rename = "label")]
        #[doc = "Represented as `\"label\"`."]
        Label,
        #[serde(rename = "labelfor")]
        #[doc = "Represented as `\"labelfor\"`."]
        Labelfor,
        #[serde(rename = "labelwrapped")]
        #[doc = "Represented as `\"labelwrapped\"`."]
        Labelwrapped,
        #[serde(rename = "legend")]
        #[doc = "Represented as `\"legend\"`."]
        Legend,
        #[serde(rename = "tablecaption")]
        #[doc = "Represented as `\"tablecaption\"`."]
        Tablecaption,
        #[serde(rename = "title")]
        #[doc = "Represented as `\"title\"`."]
        Title,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl AxValueNativeSourceType {
        pub const ENUM_VALUES: &'static [AxValueNativeSourceType] =
            &[
                AxValueNativeSourceType::Figcaption,
                AxValueNativeSourceType::Label,
                AxValueNativeSourceType::Labelfor,
                AxValueNativeSourceType::Labelwrapped,
                AxValueNativeSourceType::Legend,
                AxValueNativeSourceType::Tablecaption,
                AxValueNativeSourceType::Title,
                AxValueNativeSourceType::Other,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "figcaption",
            "label",
            "labelfor",
            "labelwrapped",
            "legend",
            "tablecaption",
            "title",
            "other",
        ];
    }
    impl ::std::str::FromStr for AxValueNativeSourceType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "figcaption" => Ok(AxValueNativeSourceType::Figcaption),
                "label" => Ok(AxValueNativeSourceType::Label),
                "labelfor" => Ok(AxValueNativeSourceType::Labelfor),
                "labelwrapped" => Ok(AxValueNativeSourceType::Labelwrapped),
                "legend" => Ok(AxValueNativeSourceType::Legend),
                "tablecaption" => Ok(AxValueNativeSourceType::Tablecaption),
                "title" => Ok(AxValueNativeSourceType::Title),
                "other" => Ok(AxValueNativeSourceType::Other),
                _ => Err(::ParseEnumError {
                    expected: AxValueNativeSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxValueNativeSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxValueNativeSourceType::Figcaption => "figcaption",
                    AxValueNativeSourceType::Label => "label",
                    AxValueNativeSourceType::Labelfor => "labelfor",
                    AxValueNativeSourceType::Labelwrapped => "labelwrapped",
                    AxValueNativeSourceType::Legend => "legend",
                    AxValueNativeSourceType::Tablecaption => "tablecaption",
                    AxValueNativeSourceType::Title => "title",
                    AxValueNativeSourceType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A single source for a computed AX property."]
    pub struct AxValueSource<'a> {
        #[serde(rename = "type")]
        #[doc = "What type of source this is."]
        pub ty: ::accessibility::AxValueSourceType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value of this property source."]
        pub value: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "attribute", skip_serializing_if = "Option::is_none")]
        #[doc = "The name of the relevant attribute, if any."]
        pub attribute: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "attributeValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value of the relevant attribute, if any."]
        pub attribute_value: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "superseded", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether this source is superseded by a higher priority source."]
        pub superseded: Option<bool>,
        #[serde(rename = "nativeSource", skip_serializing_if = "Option::is_none")]
        #[doc = "The native markup source for this value, e.g. a <label> element."]
        pub native_source: Option<::accessibility::AxValueNativeSourceType>,
        #[serde(rename = "nativeSourceValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value, such as a node or node list, of the native source."]
        pub native_source_value: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "invalid", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the value for this property is invalid."]
        pub invalid: Option<bool>,
        #[serde(rename = "invalidReason", skip_serializing_if = "Option::is_none")]
        #[doc = "Reason for the value being invalid, if it is."]
        pub invalid_reason: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct AxRelatedNode<'a> {
        #[serde(rename = "backendDOMNodeId")]
        #[doc = "The BackendNodeId of the related DOM node."]
        pub backend_dom_node_id: ::dom::BackendNodeId,
        #[serde(rename = "idref", skip_serializing_if = "Option::is_none")]
        #[doc = "The IDRef value provided, if any."]
        pub idref: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "The text alternative of this node in the current context."]
        pub text: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct AxProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "The name of this property."]
        pub name: ::accessibility::AxPropertyName,
        #[serde(rename = "value")]
        #[doc = "The value of this property."]
        pub value: ::accessibility::AxValue<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A single computed AX property."]
    pub struct AxValue<'a> {
        #[serde(rename = "type")]
        #[doc = "The type of this value."]
        pub ty: ::accessibility::AxValueType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The computed value of this property."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "relatedNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "One or more related nodes, if applicable."]
        pub related_nodes: Option<Vec<::accessibility::AxRelatedNode<'a>>>,
        #[serde(rename = "sources", skip_serializing_if = "Option::is_none")]
        #[doc = "The sources which contributed to the computation of this property."]
        pub sources: Option<Vec<::accessibility::AxValueSource<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Values of AXProperty name: from 'busy' to 'roledescription' - states which apply to every AX\nnode, from 'live' to 'root' - attributes which apply to nodes in live regions, from\n'autocomplete' to 'valuetext' - attributes which apply to widgets, from 'checked' to 'selected'\n- states which apply to widgets, from 'activedescendant' to 'owns' - relationships between\nelements other than parent/child/sibling."]
    pub enum AxPropertyName {
        #[serde(rename = "busy")]
        #[doc = "Represented as `\"busy\"`."]
        Busy,
        #[serde(rename = "disabled")]
        #[doc = "Represented as `\"disabled\"`."]
        Disabled,
        #[serde(rename = "hidden")]
        #[doc = "Represented as `\"hidden\"`."]
        Hidden,
        #[serde(rename = "hiddenRoot")]
        #[doc = "Represented as `\"hiddenRoot\"`."]
        HiddenRoot,
        #[serde(rename = "invalid")]
        #[doc = "Represented as `\"invalid\"`."]
        Invalid,
        #[serde(rename = "keyshortcuts")]
        #[doc = "Represented as `\"keyshortcuts\"`."]
        Keyshortcuts,
        #[serde(rename = "roledescription")]
        #[doc = "Represented as `\"roledescription\"`."]
        Roledescription,
        #[serde(rename = "live")]
        #[doc = "Represented as `\"live\"`."]
        Live,
        #[serde(rename = "atomic")]
        #[doc = "Represented as `\"atomic\"`."]
        Atomic,
        #[serde(rename = "relevant")]
        #[doc = "Represented as `\"relevant\"`."]
        Relevant,
        #[serde(rename = "root")]
        #[doc = "Represented as `\"root\"`."]
        Root,
        #[serde(rename = "autocomplete")]
        #[doc = "Represented as `\"autocomplete\"`."]
        Autocomplete,
        #[serde(rename = "hasPopup")]
        #[doc = "Represented as `\"hasPopup\"`."]
        HasPopup,
        #[serde(rename = "level")]
        #[doc = "Represented as `\"level\"`."]
        Level,
        #[serde(rename = "multiselectable")]
        #[doc = "Represented as `\"multiselectable\"`."]
        Multiselectable,
        #[serde(rename = "orientation")]
        #[doc = "Represented as `\"orientation\"`."]
        Orientation,
        #[serde(rename = "multiline")]
        #[doc = "Represented as `\"multiline\"`."]
        Multiline,
        #[serde(rename = "readonly")]
        #[doc = "Represented as `\"readonly\"`."]
        Readonly,
        #[serde(rename = "required")]
        #[doc = "Represented as `\"required\"`."]
        Required,
        #[serde(rename = "valuemin")]
        #[doc = "Represented as `\"valuemin\"`."]
        Valuemin,
        #[serde(rename = "valuemax")]
        #[doc = "Represented as `\"valuemax\"`."]
        Valuemax,
        #[serde(rename = "valuetext")]
        #[doc = "Represented as `\"valuetext\"`."]
        Valuetext,
        #[serde(rename = "checked")]
        #[doc = "Represented as `\"checked\"`."]
        Checked,
        #[serde(rename = "expanded")]
        #[doc = "Represented as `\"expanded\"`."]
        Expanded,
        #[serde(rename = "modal")]
        #[doc = "Represented as `\"modal\"`."]
        Modal,
        #[serde(rename = "pressed")]
        #[doc = "Represented as `\"pressed\"`."]
        Pressed,
        #[serde(rename = "selected")]
        #[doc = "Represented as `\"selected\"`."]
        Selected,
        #[serde(rename = "activedescendant")]
        #[doc = "Represented as `\"activedescendant\"`."]
        Activedescendant,
        #[serde(rename = "controls")]
        #[doc = "Represented as `\"controls\"`."]
        Controls,
        #[serde(rename = "describedby")]
        #[doc = "Represented as `\"describedby\"`."]
        Describedby,
        #[serde(rename = "details")]
        #[doc = "Represented as `\"details\"`."]
        Details,
        #[serde(rename = "errormessage")]
        #[doc = "Represented as `\"errormessage\"`."]
        Errormessage,
        #[serde(rename = "flowto")]
        #[doc = "Represented as `\"flowto\"`."]
        Flowto,
        #[serde(rename = "labelledby")]
        #[doc = "Represented as `\"labelledby\"`."]
        Labelledby,
        #[serde(rename = "owns")]
        #[doc = "Represented as `\"owns\"`."]
        Owns,
    }
    impl AxPropertyName {
        pub const ENUM_VALUES: &'static [AxPropertyName] = &[
            AxPropertyName::Busy,
            AxPropertyName::Disabled,
            AxPropertyName::Hidden,
            AxPropertyName::HiddenRoot,
            AxPropertyName::Invalid,
            AxPropertyName::Keyshortcuts,
            AxPropertyName::Roledescription,
            AxPropertyName::Live,
            AxPropertyName::Atomic,
            AxPropertyName::Relevant,
            AxPropertyName::Root,
            AxPropertyName::Autocomplete,
            AxPropertyName::HasPopup,
            AxPropertyName::Level,
            AxPropertyName::Multiselectable,
            AxPropertyName::Orientation,
            AxPropertyName::Multiline,
            AxPropertyName::Readonly,
            AxPropertyName::Required,
            AxPropertyName::Valuemin,
            AxPropertyName::Valuemax,
            AxPropertyName::Valuetext,
            AxPropertyName::Checked,
            AxPropertyName::Expanded,
            AxPropertyName::Modal,
            AxPropertyName::Pressed,
            AxPropertyName::Selected,
            AxPropertyName::Activedescendant,
            AxPropertyName::Controls,
            AxPropertyName::Describedby,
            AxPropertyName::Details,
            AxPropertyName::Errormessage,
            AxPropertyName::Flowto,
            AxPropertyName::Labelledby,
            AxPropertyName::Owns,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "busy",
            "disabled",
            "hidden",
            "hiddenRoot",
            "invalid",
            "keyshortcuts",
            "roledescription",
            "live",
            "atomic",
            "relevant",
            "root",
            "autocomplete",
            "hasPopup",
            "level",
            "multiselectable",
            "orientation",
            "multiline",
            "readonly",
            "required",
            "valuemin",
            "valuemax",
            "valuetext",
            "checked",
            "expanded",
            "modal",
            "pressed",
            "selected",
            "activedescendant",
            "controls",
            "describedby",
            "details",
            "errormessage",
            "flowto",
            "labelledby",
            "owns",
        ];
    }
    impl ::std::str::FromStr for AxPropertyName {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "busy" => Ok(AxPropertyName::Busy),
                "disabled" => Ok(AxPropertyName::Disabled),
                "hidden" => Ok(AxPropertyName::Hidden),
                "hiddenRoot" => Ok(AxPropertyName::HiddenRoot),
                "invalid" => Ok(AxPropertyName::Invalid),
                "keyshortcuts" => Ok(AxPropertyName::Keyshortcuts),
                "roledescription" => Ok(AxPropertyName::Roledescription),
                "live" => Ok(AxPropertyName::Live),
                "atomic" => Ok(AxPropertyName::Atomic),
                "relevant" => Ok(AxPropertyName::Relevant),
                "root" => Ok(AxPropertyName::Root),
                "autocomplete" => Ok(AxPropertyName::Autocomplete),
                "hasPopup" => Ok(AxPropertyName::HasPopup),
                "level" => Ok(AxPropertyName::Level),
                "multiselectable" => Ok(AxPropertyName::Multiselectable),
                "orientation" => Ok(AxPropertyName::Orientation),
                "multiline" => Ok(AxPropertyName::Multiline),
                "readonly" => Ok(AxPropertyName::Readonly),
                "required" => Ok(AxPropertyName::Required),
                "valuemin" => Ok(AxPropertyName::Valuemin),
                "valuemax" => Ok(AxPropertyName::Valuemax),
                "valuetext" => Ok(AxPropertyName::Valuetext),
                "checked" => Ok(AxPropertyName::Checked),
                "expanded" => Ok(AxPropertyName::Expanded),
                "modal" => Ok(AxPropertyName::Modal),
                "pressed" => Ok(AxPropertyName::Pressed),
                "selected" => Ok(AxPropertyName::Selected),
                "activedescendant" => Ok(AxPropertyName::Activedescendant),
                "controls" => Ok(AxPropertyName::Controls),
                "describedby" => Ok(AxPropertyName::Describedby),
                "details" => Ok(AxPropertyName::Details),
                "errormessage" => Ok(AxPropertyName::Errormessage),
                "flowto" => Ok(AxPropertyName::Flowto),
                "labelledby" => Ok(AxPropertyName::Labelledby),
                "owns" => Ok(AxPropertyName::Owns),
                _ => Err(::ParseEnumError {
                    expected: AxPropertyName::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AxPropertyName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AxPropertyName::Busy => "busy",
                    AxPropertyName::Disabled => "disabled",
                    AxPropertyName::Hidden => "hidden",
                    AxPropertyName::HiddenRoot => "hiddenRoot",
                    AxPropertyName::Invalid => "invalid",
                    AxPropertyName::Keyshortcuts => "keyshortcuts",
                    AxPropertyName::Roledescription => "roledescription",
                    AxPropertyName::Live => "live",
                    AxPropertyName::Atomic => "atomic",
                    AxPropertyName::Relevant => "relevant",
                    AxPropertyName::Root => "root",
                    AxPropertyName::Autocomplete => "autocomplete",
                    AxPropertyName::HasPopup => "hasPopup",
                    AxPropertyName::Level => "level",
                    AxPropertyName::Multiselectable => "multiselectable",
                    AxPropertyName::Orientation => "orientation",
                    AxPropertyName::Multiline => "multiline",
                    AxPropertyName::Readonly => "readonly",
                    AxPropertyName::Required => "required",
                    AxPropertyName::Valuemin => "valuemin",
                    AxPropertyName::Valuemax => "valuemax",
                    AxPropertyName::Valuetext => "valuetext",
                    AxPropertyName::Checked => "checked",
                    AxPropertyName::Expanded => "expanded",
                    AxPropertyName::Modal => "modal",
                    AxPropertyName::Pressed => "pressed",
                    AxPropertyName::Selected => "selected",
                    AxPropertyName::Activedescendant => "activedescendant",
                    AxPropertyName::Controls => "controls",
                    AxPropertyName::Describedby => "describedby",
                    AxPropertyName::Details => "details",
                    AxPropertyName::Errormessage => "errormessage",
                    AxPropertyName::Flowto => "flowto",
                    AxPropertyName::Labelledby => "labelledby",
                    AxPropertyName::Owns => "owns",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A node in the accessibility tree."]
    pub struct AxNode<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Unique identifier for this node."]
        pub node_id: ::accessibility::AxNodeId<'a>,
        #[serde(rename = "ignored")]
        #[doc = "Whether this node is ignored for accessibility"]
        pub ignored: bool,
        #[serde(rename = "ignoredReasons", skip_serializing_if = "Option::is_none")]
        #[doc = "Collection of reasons why this node is hidden."]
        pub ignored_reasons: Option<Vec<::accessibility::AxProperty<'a>>>,
        #[serde(rename = "role", skip_serializing_if = "Option::is_none")]
        #[doc = "This `Node`'s role, whether explicit or implicit."]
        pub role: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "The accessible name for this `Node`."]
        pub name: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "The accessible description for this `Node`."]
        pub description: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value for this `Node`."]
        pub value: Option<::accessibility::AxValue<'a>>,
        #[serde(rename = "properties", skip_serializing_if = "Option::is_none")]
        #[doc = "All other properties"]
        pub properties: Option<Vec<::accessibility::AxProperty<'a>>>,
        #[serde(rename = "childIds", skip_serializing_if = "Option::is_none")]
        #[doc = "IDs for each of this node's child nodes."]
        pub child_ids: Option<Vec<::accessibility::AxNodeId<'a>>>,
        #[serde(rename = "backendDOMNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend ID for the associated DOM node, if any."]
        pub backend_dom_node_id: Option<::dom::BackendNodeId>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Animation\n\n## Commands\n\n- [`Animation.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables animation domain notifications.\n- [`Animation.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables animation domain notifications.\n- [`Animation.getCurrentTime`](struct.GetCurrentTimeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the current time of the an animation.\n- [`Animation.getPlaybackRate`](struct.GetPlaybackRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets the playback rate of the document timeline.\n- [`Animation.releaseAnimations`](struct.ReleaseAnimationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Releases a set of animations to no longer be manipulated.\n- [`Animation.resolveAnimation`](struct.ResolveAnimationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets the remote object of the Animation.\n- [`Animation.seekAnimations`](struct.SeekAnimationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Seek a set of animations to a particular time within each animation.\n- [`Animation.setPaused`](struct.SetPausedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the paused state of a set of animations.\n- [`Animation.setPlaybackRate`](struct.SetPlaybackRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the playback rate of the document timeline.\n- [`Animation.setTiming`](struct.SetTimingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the timing of an animation node.\n\n## Events\n\n- [`Animation.animationCanceled`](struct.AnimationCanceledEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for when an animation has been cancelled.\n- [`Animation.animationCreated`](struct.AnimationCreatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for each animation that has been created.\n- [`Animation.animationStarted`](struct.AnimationStartedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Event for animation that has been started.\n\n##Types\n\n- [`Animation`](struct.Animation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Animation instance.\n- [`AnimationEffect`](struct.AnimationEffect.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  AnimationEffect instance\n- [`KeyframesRule`](struct.KeyframesRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Keyframes Rule\n- [`KeyframeStyle`](struct.KeyframeStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Keyframe Style\n"]
pub mod animation {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables animation domain notifications.\n\n# Command `Animation.disable`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::animation::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Animation.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Animation.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables animation domain notifications.\n\n# Command `Animation.disable`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::animation::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Animation.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables animation domain notifications.\n\n# Command `Animation.enable`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::animation::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Animation.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Animation.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables animation domain notifications.\n\n# Command `Animation.enable`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::animation::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Animation.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current time of the an animation.\n\n# Command `Animation.getCurrentTime`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::GetCurrentTimeCommand`](struct.GetCurrentTimeCommand.html)  \n*Response Struct:* [`cdp::animation::GetCurrentTimeResponse`](struct.GetCurrentTimeResponse.html)"]
    pub struct GetCurrentTimeCommand<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of animation."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetCurrentTimeCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.getCurrentTime";
    }
    impl<'a> ::SerializeCdpCommand for GetCurrentTimeCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.getCurrentTime"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetCurrentTimeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.getCurrentTime" {
                Ok(
                    <GetCurrentTimeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current time of the an animation.\n\n# Command `Animation.getCurrentTime`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::GetCurrentTimeCommand`](struct.GetCurrentTimeCommand.html)  \n*Response Struct:* [`cdp::animation::GetCurrentTimeResponse`](struct.GetCurrentTimeResponse.html)"]
    pub struct GetCurrentTimeResponse {
        #[serde(rename = "currentTime")]
        #[doc = "Current time of the page."]
        pub current_time: f64,
    }
    impl ::CdpCommand for GetCurrentTimeResponse {
        const COMMAND_NAME: &'static str = "Animation.getCurrentTime";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetCurrentTimeCommand<'a> {
        type Response = GetCurrentTimeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetCurrentTimeResponse {
        type Command = GetCurrentTimeCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the playback rate of the document timeline.\n\n# Command `Animation.getPlaybackRate`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::GetPlaybackRateCommand`](struct.GetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::animation::GetPlaybackRateResponse`](struct.GetPlaybackRateResponse.html)"]
    pub struct GetPlaybackRateCommand;
    impl ::serde::Serialize for GetPlaybackRateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetPlaybackRateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetPlaybackRateCommand)
        }
    }
    impl ::CdpCommand for GetPlaybackRateCommand {
        const COMMAND_NAME: &'static str = "Animation.getPlaybackRate";
    }
    impl ::SerializeCdpCommand for GetPlaybackRateCommand {
        fn command_name(&self) -> &str {
            "Animation.getPlaybackRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetPlaybackRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.getPlaybackRate" {
                Ok(
                    <GetPlaybackRateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the playback rate of the document timeline.\n\n# Command `Animation.getPlaybackRate`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::GetPlaybackRateCommand`](struct.GetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::animation::GetPlaybackRateResponse`](struct.GetPlaybackRateResponse.html)"]
    pub struct GetPlaybackRateResponse {
        #[serde(rename = "playbackRate")]
        #[doc = "Playback rate for animations on page."]
        pub playback_rate: f64,
    }
    impl ::CdpCommand for GetPlaybackRateResponse {
        const COMMAND_NAME: &'static str = "Animation.getPlaybackRate";
    }
    impl<'b> ::HasCdpResponse<'b> for GetPlaybackRateCommand {
        type Response = GetPlaybackRateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetPlaybackRateResponse {
        type Command = GetPlaybackRateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases a set of animations to no longer be manipulated.\n\n# Command `Animation.releaseAnimations`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::ReleaseAnimationsCommand`](struct.ReleaseAnimationsCommand.html)  \n*Response Struct:* [`cdp::animation::ReleaseAnimationsResponse`](struct.ReleaseAnimationsResponse.html)"]
    pub struct ReleaseAnimationsCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "List of animation ids to seek."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for ReleaseAnimationsCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.releaseAnimations";
    }
    impl<'a> ::SerializeCdpCommand for ReleaseAnimationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.releaseAnimations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReleaseAnimationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.releaseAnimations" {
                Ok ( < ReleaseAnimationsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases a set of animations to no longer be manipulated.\n\n# Command `Animation.releaseAnimations`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::ReleaseAnimationsCommand`](struct.ReleaseAnimationsCommand.html)  \n*Response Struct:* [`cdp::animation::ReleaseAnimationsResponse`](struct.ReleaseAnimationsResponse.html)"]
    pub struct ReleaseAnimationsResponse;
    impl ::serde::Serialize for ReleaseAnimationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseAnimationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseAnimationsResponse)
        }
    }
    impl ::CdpCommand for ReleaseAnimationsResponse {
        const COMMAND_NAME: &'static str = "Animation.releaseAnimations";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReleaseAnimationsCommand<'a> {
        type Response = ReleaseAnimationsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReleaseAnimationsResponse {
        type Command = ReleaseAnimationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the remote object of the Animation.\n\n# Command `Animation.resolveAnimation`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::ResolveAnimationCommand`](struct.ResolveAnimationCommand.html)  \n*Response Struct:* [`cdp::animation::ResolveAnimationResponse`](struct.ResolveAnimationResponse.html)"]
    pub struct ResolveAnimationCommand<'a> {
        #[serde(rename = "animationId")]
        #[doc = "Animation id."]
        pub animation_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ResolveAnimationCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.resolveAnimation";
    }
    impl<'a> ::SerializeCdpCommand for ResolveAnimationCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.resolveAnimation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ResolveAnimationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.resolveAnimation" {
                Ok ( < ResolveAnimationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets the remote object of the Animation.\n\n# Command `Animation.resolveAnimation`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::ResolveAnimationCommand`](struct.ResolveAnimationCommand.html)  \n*Response Struct:* [`cdp::animation::ResolveAnimationResponse`](struct.ResolveAnimationResponse.html)"]
    pub struct ResolveAnimationResponse<'a> {
        #[serde(rename = "remoteObject")]
        #[doc = "Corresponding remote object."]
        pub remote_object: ::runtime::RemoteObject<'a>,
    }
    impl<'a> ::CdpCommand for ResolveAnimationResponse<'a> {
        const COMMAND_NAME: &'static str = "Animation.resolveAnimation";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ResolveAnimationCommand<'a> {
        type Response = ResolveAnimationResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ResolveAnimationResponse<'b> {
        type Command = ResolveAnimationCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seek a set of animations to a particular time within each animation.\n\n# Command `Animation.seekAnimations`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SeekAnimationsCommand`](struct.SeekAnimationsCommand.html)  \n*Response Struct:* [`cdp::animation::SeekAnimationsResponse`](struct.SeekAnimationsResponse.html)"]
    pub struct SeekAnimationsCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "List of animation ids to seek."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "currentTime")]
        #[doc = "Set the current time of each animation."]
        pub current_time: f64,
    }
    impl<'a> ::CdpCommand for SeekAnimationsCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.seekAnimations";
    }
    impl<'a> ::SerializeCdpCommand for SeekAnimationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.seekAnimations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SeekAnimationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.seekAnimations" {
                Ok(
                    <SeekAnimationsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seek a set of animations to a particular time within each animation.\n\n# Command `Animation.seekAnimations`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SeekAnimationsCommand`](struct.SeekAnimationsCommand.html)  \n*Response Struct:* [`cdp::animation::SeekAnimationsResponse`](struct.SeekAnimationsResponse.html)"]
    pub struct SeekAnimationsResponse;
    impl ::serde::Serialize for SeekAnimationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SeekAnimationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SeekAnimationsResponse)
        }
    }
    impl ::CdpCommand for SeekAnimationsResponse {
        const COMMAND_NAME: &'static str = "Animation.seekAnimations";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SeekAnimationsCommand<'a> {
        type Response = SeekAnimationsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SeekAnimationsResponse {
        type Command = SeekAnimationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the paused state of a set of animations.\n\n# Command `Animation.setPaused`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetPausedCommand`](struct.SetPausedCommand.html)  \n*Response Struct:* [`cdp::animation::SetPausedResponse`](struct.SetPausedResponse.html)"]
    pub struct SetPausedCommand<'a> {
        #[serde(rename = "animations")]
        #[doc = "Animations to set the pause state of."]
        pub animations: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "paused")]
        #[doc = "Paused state to set to."]
        pub paused: bool,
    }
    impl<'a> ::CdpCommand for SetPausedCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.setPaused";
    }
    impl<'a> ::SerializeCdpCommand for SetPausedCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.setPaused"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetPausedCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setPaused" {
                Ok(
                    <SetPausedCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the paused state of a set of animations.\n\n# Command `Animation.setPaused`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetPausedCommand`](struct.SetPausedCommand.html)  \n*Response Struct:* [`cdp::animation::SetPausedResponse`](struct.SetPausedResponse.html)"]
    pub struct SetPausedResponse;
    impl ::serde::Serialize for SetPausedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPausedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPausedResponse)
        }
    }
    impl ::CdpCommand for SetPausedResponse {
        const COMMAND_NAME: &'static str = "Animation.setPaused";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetPausedCommand<'a> {
        type Response = SetPausedResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPausedResponse {
        type Command = SetPausedCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the playback rate of the document timeline.\n\n# Command `Animation.setPlaybackRate`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetPlaybackRateCommand`](struct.SetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::animation::SetPlaybackRateResponse`](struct.SetPlaybackRateResponse.html)"]
    pub struct SetPlaybackRateCommand {
        #[serde(rename = "playbackRate")]
        #[doc = "Playback rate for animations on page"]
        pub playback_rate: f64,
    }
    impl ::CdpCommand for SetPlaybackRateCommand {
        const COMMAND_NAME: &'static str = "Animation.setPlaybackRate";
    }
    impl ::SerializeCdpCommand for SetPlaybackRateCommand {
        fn command_name(&self) -> &str {
            "Animation.setPlaybackRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetPlaybackRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setPlaybackRate" {
                Ok(
                    <SetPlaybackRateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the playback rate of the document timeline.\n\n# Command `Animation.setPlaybackRate`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetPlaybackRateCommand`](struct.SetPlaybackRateCommand.html)  \n*Response Struct:* [`cdp::animation::SetPlaybackRateResponse`](struct.SetPlaybackRateResponse.html)"]
    pub struct SetPlaybackRateResponse;
    impl ::serde::Serialize for SetPlaybackRateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPlaybackRateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPlaybackRateResponse)
        }
    }
    impl ::CdpCommand for SetPlaybackRateResponse {
        const COMMAND_NAME: &'static str = "Animation.setPlaybackRate";
    }
    impl<'b> ::HasCdpResponse<'b> for SetPlaybackRateCommand {
        type Response = SetPlaybackRateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPlaybackRateResponse {
        type Command = SetPlaybackRateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the timing of an animation node.\n\n# Command `Animation.setTiming`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetTimingCommand`](struct.SetTimingCommand.html)  \n*Response Struct:* [`cdp::animation::SetTimingResponse`](struct.SetTimingResponse.html)"]
    pub struct SetTimingCommand<'a> {
        #[serde(rename = "animationId")]
        #[doc = "Animation id."]
        pub animation_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "duration")]
        #[doc = "Duration of the animation."]
        pub duration: f64,
        #[serde(rename = "delay")]
        #[doc = "Delay of the animation."]
        pub delay: f64,
    }
    impl<'a> ::CdpCommand for SetTimingCommand<'a> {
        const COMMAND_NAME: &'static str = "Animation.setTiming";
    }
    impl<'a> ::SerializeCdpCommand for SetTimingCommand<'a> {
        fn command_name(&self) -> &str {
            "Animation.setTiming"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetTimingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.setTiming" {
                Ok(
                    <SetTimingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the timing of an animation node.\n\n# Command `Animation.setTiming`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Command Struct:* [`cdp::animation::SetTimingCommand`](struct.SetTimingCommand.html)  \n*Response Struct:* [`cdp::animation::SetTimingResponse`](struct.SetTimingResponse.html)"]
    pub struct SetTimingResponse;
    impl ::serde::Serialize for SetTimingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTimingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTimingResponse)
        }
    }
    impl ::CdpCommand for SetTimingResponse {
        const COMMAND_NAME: &'static str = "Animation.setTiming";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetTimingCommand<'a> {
        type Response = SetTimingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetTimingResponse {
        type Command = SetTimingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for when an animation has been cancelled.\n\n# Event `Animation.animationCanceled`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Event Struct:* [`cdp::animation::AnimationCanceledEvent`](struct.AnimationCanceledEvent.html)"]
    pub struct AnimationCanceledEvent<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of the animation that was cancelled."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AnimationCanceledEvent<'a> {
        const EVENT_NAME: &'static str = "Animation.animationCanceled";
    }
    impl<'a> ::SerializeCdpEvent for AnimationCanceledEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationCanceled"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AnimationCanceledEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationCanceled" {
                Ok(
                    <AnimationCanceledEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for each animation that has been created.\n\n# Event `Animation.animationCreated`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Event Struct:* [`cdp::animation::AnimationCreatedEvent`](struct.AnimationCreatedEvent.html)"]
    pub struct AnimationCreatedEvent<'a> {
        #[serde(rename = "id")]
        #[doc = "Id of the animation that was created."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AnimationCreatedEvent<'a> {
        const EVENT_NAME: &'static str = "Animation.animationCreated";
    }
    impl<'a> ::SerializeCdpEvent for AnimationCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AnimationCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationCreated" {
                Ok(
                    <AnimationCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Event for animation that has been started.\n\n# Event `Animation.animationStarted`\n\n*Domain Module:* [`cdp::animation`](index.html)  \n*Event Struct:* [`cdp::animation::AnimationStartedEvent`](struct.AnimationStartedEvent.html)"]
    pub struct AnimationStartedEvent<'a> {
        #[serde(rename = "animation")]
        #[doc = "Animation that was started."]
        pub animation: ::animation::Animation<'a>,
    }
    impl<'a> ::CdpEvent for AnimationStartedEvent<'a> {
        const EVENT_NAME: &'static str = "Animation.animationStarted";
    }
    impl<'a> ::SerializeCdpEvent for AnimationStartedEvent<'a> {
        fn event_name(&self) -> &str {
            "Animation.animationStarted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AnimationStartedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Animation.animationStarted" {
                Ok(
                    <AnimationStartedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::animation::Animation::ty`](struct.Animation.html#structfield.ty)."]
    pub enum AnimationType {
        #[serde(rename = "CSSTransition")]
        #[doc = "Represented as `\"CSSTransition\"`."]
        CssTransition,
        #[serde(rename = "CSSAnimation")]
        #[doc = "Represented as `\"CSSAnimation\"`."]
        CssAnimation,
        #[serde(rename = "WebAnimation")]
        #[doc = "Represented as `\"WebAnimation\"`."]
        WebAnimation,
    }
    impl AnimationType {
        pub const ENUM_VALUES: &'static [AnimationType] = &[
            AnimationType::CssTransition,
            AnimationType::CssAnimation,
            AnimationType::WebAnimation,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["CSSTransition", "CSSAnimation", "WebAnimation"];
    }
    impl ::std::str::FromStr for AnimationType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "CSSTransition" => Ok(AnimationType::CssTransition),
                "CSSAnimation" => Ok(AnimationType::CssAnimation),
                "WebAnimation" => Ok(AnimationType::WebAnimation),
                _ => Err(::ParseEnumError {
                    expected: AnimationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AnimationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AnimationType::CssTransition => "CSSTransition",
                    AnimationType::CssAnimation => "CSSAnimation",
                    AnimationType::WebAnimation => "WebAnimation",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Animation instance."]
    pub struct Animation<'a> {
        #[serde(rename = "id")]
        #[doc = "`Animation`'s id."]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "`Animation`'s name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "pausedState")]
        #[doc = "`Animation`'s internal paused state."]
        pub paused_state: bool,
        #[serde(rename = "playState")]
        #[doc = "`Animation`'s play state."]
        pub play_state: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "playbackRate")]
        #[doc = "`Animation`'s playback rate."]
        pub playback_rate: f64,
        #[serde(rename = "startTime")]
        #[doc = "`Animation`'s start time."]
        pub start_time: f64,
        #[serde(rename = "currentTime")]
        #[doc = "`Animation`'s current time."]
        pub current_time: f64,
        #[serde(rename = "type")]
        #[doc = "Animation type of `Animation`."]
        pub ty: ::animation::AnimationType,
        #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
        #[doc = "`Animation`'s source animation node."]
        pub source: Option<::animation::AnimationEffect<'a>>,
        #[serde(rename = "cssId", skip_serializing_if = "Option::is_none")]
        #[doc = "A unique ID for `Animation` representing the sources that triggered this CSS\nanimation/transition."]
        pub css_id: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> AnimationEffect instance"]
    pub struct AnimationEffect<'a> {
        #[serde(rename = "delay")]
        #[doc = "`AnimationEffect`'s delay."]
        pub delay: f64,
        #[serde(rename = "endDelay")]
        #[doc = "`AnimationEffect`'s end delay."]
        pub end_delay: f64,
        #[serde(rename = "iterationStart")]
        #[doc = "`AnimationEffect`'s iteration start."]
        pub iteration_start: f64,
        #[serde(rename = "iterations")]
        #[doc = "`AnimationEffect`'s iterations."]
        pub iterations: f64,
        #[serde(rename = "duration")]
        #[doc = "`AnimationEffect`'s iteration duration."]
        pub duration: f64,
        #[serde(rename = "direction")]
        #[doc = "`AnimationEffect`'s playback direction."]
        pub direction: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fill")]
        #[doc = "`AnimationEffect`'s fill mode."]
        pub fill: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "`AnimationEffect`'s target node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "keyframesRule", skip_serializing_if = "Option::is_none")]
        #[doc = "`AnimationEffect`'s keyframes."]
        pub keyframes_rule: Option<::animation::KeyframesRule<'a>>,
        #[serde(rename = "easing")]
        #[doc = "`AnimationEffect`'s timing function."]
        pub easing: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Keyframes Rule"]
    pub struct KeyframesRule<'a> {
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "CSS keyframed animation's name."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "keyframes")]
        #[doc = "List of animation keyframes."]
        pub keyframes: Vec<::animation::KeyframeStyle<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Keyframe Style"]
    pub struct KeyframeStyle<'a> {
        #[serde(rename = "offset")]
        #[doc = "Keyframe's time offset."]
        pub offset: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "easing")]
        #[doc = "`AnimationEffect`'s timing function."]
        pub easing: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# ApplicationCache\n\n## Commands\n\n- [`ApplicationCache.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables application cache domain notifications.\n- [`ApplicationCache.getApplicationCacheForFrame`](struct.GetApplicationCacheForFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns relevant application cache data for the document in given frame.\n- [`ApplicationCache.getFramesWithManifests`](struct.GetFramesWithManifestsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns array of frame identifiers with manifest urls for each frame containing a document\n  associated with some application cache.\n- [`ApplicationCache.getManifestForFrame`](struct.GetManifestForFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns manifest URL for document in the given frame.\n\n## Events\n\n- [`ApplicationCache.applicationCacheStatusUpdated`](struct.ApplicationCacheStatusUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ApplicationCache.networkStateUpdated`](struct.NetworkStateUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`ApplicationCacheResource`](struct.ApplicationCacheResource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Detailed application cache resource information.\n- [`ApplicationCache`](struct.ApplicationCache.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Detailed application cache information.\n- [`FrameWithManifest`](struct.FrameWithManifest.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Frame identifier - manifest URL pair.\n"]
pub mod application_cache {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables application cache domain notifications.\n\n# Command `ApplicationCache.enable`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::application_cache::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "ApplicationCache.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "ApplicationCache.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables application cache domain notifications.\n\n# Command `ApplicationCache.enable`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::application_cache::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "ApplicationCache.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns relevant application cache data for the document in given frame.\n\n# Command `ApplicationCache.getApplicationCacheForFrame`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetApplicationCacheForFrameCommand`](struct.GetApplicationCacheForFrameCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetApplicationCacheForFrameResponse`](struct.GetApplicationCacheForFrameResponse.html)"]
    pub struct GetApplicationCacheForFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose application cache is retrieved."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpCommand for GetApplicationCacheForFrameCommand<'a> {
        const COMMAND_NAME: &'static str = "ApplicationCache.getApplicationCacheForFrame";
    }
    impl<'a> ::SerializeCdpCommand for GetApplicationCacheForFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "ApplicationCache.getApplicationCacheForFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetApplicationCacheForFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getApplicationCacheForFrame" {
                Ok ( < GetApplicationCacheForFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns relevant application cache data for the document in given frame.\n\n# Command `ApplicationCache.getApplicationCacheForFrame`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetApplicationCacheForFrameCommand`](struct.GetApplicationCacheForFrameCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetApplicationCacheForFrameResponse`](struct.GetApplicationCacheForFrameResponse.html)"]
    pub struct GetApplicationCacheForFrameResponse<'a> {
        #[serde(rename = "applicationCache")]
        #[doc = "Relevant application cache data for the document in given frame."]
        pub application_cache: ::application_cache::ApplicationCache<'a>,
    }
    impl<'a> ::CdpCommand for GetApplicationCacheForFrameResponse<'a> {
        const COMMAND_NAME: &'static str = "ApplicationCache.getApplicationCacheForFrame";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetApplicationCacheForFrameCommand<'a> {
        type Response = GetApplicationCacheForFrameResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetApplicationCacheForFrameResponse<'b> {
        type Command = GetApplicationCacheForFrameCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns array of frame identifiers with manifest urls for each frame containing a document\nassociated with some application cache.\n\n# Command `ApplicationCache.getFramesWithManifests`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetFramesWithManifestsCommand`](struct.GetFramesWithManifestsCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetFramesWithManifestsResponse`](struct.GetFramesWithManifestsResponse.html)"]
    pub struct GetFramesWithManifestsCommand;
    impl ::serde::Serialize for GetFramesWithManifestsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetFramesWithManifestsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetFramesWithManifestsCommand)
        }
    }
    impl ::CdpCommand for GetFramesWithManifestsCommand {
        const COMMAND_NAME: &'static str = "ApplicationCache.getFramesWithManifests";
    }
    impl ::SerializeCdpCommand for GetFramesWithManifestsCommand {
        fn command_name(&self) -> &str {
            "ApplicationCache.getFramesWithManifests"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetFramesWithManifestsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getFramesWithManifests" {
                Ok ( < GetFramesWithManifestsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns array of frame identifiers with manifest urls for each frame containing a document\nassociated with some application cache.\n\n# Command `ApplicationCache.getFramesWithManifests`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetFramesWithManifestsCommand`](struct.GetFramesWithManifestsCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetFramesWithManifestsResponse`](struct.GetFramesWithManifestsResponse.html)"]
    pub struct GetFramesWithManifestsResponse<'a> {
        #[serde(rename = "frameIds")]
        #[doc = "Array of frame identifiers with manifest urls for each frame containing a document\nassociated with some application cache."]
        pub frame_ids: Vec<::application_cache::FrameWithManifest<'a>>,
    }
    impl<'a> ::CdpCommand for GetFramesWithManifestsResponse<'a> {
        const COMMAND_NAME: &'static str = "ApplicationCache.getFramesWithManifests";
    }
    impl<'b> ::HasCdpResponse<'b> for GetFramesWithManifestsCommand {
        type Response = GetFramesWithManifestsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetFramesWithManifestsResponse<'b> {
        type Command = GetFramesWithManifestsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns manifest URL for document in the given frame.\n\n# Command `ApplicationCache.getManifestForFrame`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetManifestForFrameCommand`](struct.GetManifestForFrameCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetManifestForFrameResponse`](struct.GetManifestForFrameResponse.html)"]
    pub struct GetManifestForFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose manifest is retrieved."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpCommand for GetManifestForFrameCommand<'a> {
        const COMMAND_NAME: &'static str = "ApplicationCache.getManifestForFrame";
    }
    impl<'a> ::SerializeCdpCommand for GetManifestForFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "ApplicationCache.getManifestForFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetManifestForFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.getManifestForFrame" {
                Ok ( < GetManifestForFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns manifest URL for document in the given frame.\n\n# Command `ApplicationCache.getManifestForFrame`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Command Struct:* [`cdp::application_cache::GetManifestForFrameCommand`](struct.GetManifestForFrameCommand.html)  \n*Response Struct:* [`cdp::application_cache::GetManifestForFrameResponse`](struct.GetManifestForFrameResponse.html)"]
    pub struct GetManifestForFrameResponse<'a> {
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL for document in the given frame."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetManifestForFrameResponse<'a> {
        const COMMAND_NAME: &'static str = "ApplicationCache.getManifestForFrame";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetManifestForFrameCommand<'a> {
        type Response = GetManifestForFrameResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetManifestForFrameResponse<'b> {
        type Command = GetManifestForFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ApplicationCache.applicationCacheStatusUpdated`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Event Struct:* [`cdp::application_cache::ApplicationCacheStatusUpdatedEvent`](struct.ApplicationCacheStatusUpdatedEvent.html)"]
    pub struct ApplicationCacheStatusUpdatedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame containing document whose application cache updated status."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "Updated application cache status."]
        pub status: i32,
    }
    impl<'a> ::CdpEvent for ApplicationCacheStatusUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "ApplicationCache.applicationCacheStatusUpdated";
    }
    impl<'a> ::SerializeCdpEvent for ApplicationCacheStatusUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ApplicationCache.applicationCacheStatusUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ApplicationCacheStatusUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.applicationCacheStatusUpdated" {
                Ok ( < ApplicationCacheStatusUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ApplicationCache.networkStateUpdated`\n\n*Domain Module:* [`cdp::application_cache`](index.html)  \n*Event Struct:* [`cdp::application_cache::NetworkStateUpdatedEvent`](struct.NetworkStateUpdatedEvent.html)"]
    pub struct NetworkStateUpdatedEvent {
        #[serde(rename = "isNowOnline")]
        pub is_now_online: bool,
    }
    impl ::CdpEvent for NetworkStateUpdatedEvent {
        const EVENT_NAME: &'static str = "ApplicationCache.networkStateUpdated";
    }
    impl ::SerializeCdpEvent for NetworkStateUpdatedEvent {
        fn event_name(&self) -> &str {
            "ApplicationCache.networkStateUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for NetworkStateUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ApplicationCache.networkStateUpdated" {
                Ok ( < NetworkStateUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detailed application cache resource information."]
    pub struct ApplicationCacheResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "size")]
        #[doc = "Resource size."]
        pub size: i32,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Detailed application cache information."]
    pub struct ApplicationCache<'a> {
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "size")]
        #[doc = "Application cache size."]
        pub size: f64,
        #[serde(rename = "creationTime")]
        #[doc = "Application cache creation time."]
        pub creation_time: f64,
        #[serde(rename = "updateTime")]
        #[doc = "Application cache update time."]
        pub update_time: f64,
        #[serde(rename = "resources")]
        #[doc = "Application cache resources."]
        pub resources: Vec<::application_cache::ApplicationCacheResource<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Frame identifier - manifest URL pair."]
    pub struct FrameWithManifest<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame identifier."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "manifestURL")]
        #[doc = "Manifest URL."]
        pub manifest_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "Application cache status."]
        pub status: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Audits domain allows investigation of page violations and possible improvements.\n\n# Audits\n\n## Commands\n\n- [`Audits.getEncodedResponse`](struct.GetEncodedResponseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the response body and size if it were re-encoded with the specified settings. Only\n  applies to images.\n"]
pub mod audits {
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::audits::GetEncodedResponseCommand::encoding`](struct.GetEncodedResponseCommand.html#structfield.encoding)."]
    pub enum GetEncodedResponseCommandEncoding {
        #[serde(rename = "webp")]
        #[doc = "Represented as `\"webp\"`."]
        Webp,
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl GetEncodedResponseCommandEncoding {
        pub const ENUM_VALUES: &'static [GetEncodedResponseCommandEncoding] =
            &[
                GetEncodedResponseCommandEncoding::Webp,
                GetEncodedResponseCommandEncoding::Jpeg,
                GetEncodedResponseCommandEncoding::Png,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["webp", "jpeg", "png"];
    }
    impl ::std::str::FromStr for GetEncodedResponseCommandEncoding {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "webp" => Ok(GetEncodedResponseCommandEncoding::Webp),
                "jpeg" => Ok(GetEncodedResponseCommandEncoding::Jpeg),
                "png" => Ok(GetEncodedResponseCommandEncoding::Png),
                _ => Err(::ParseEnumError {
                    expected: GetEncodedResponseCommandEncoding::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for GetEncodedResponseCommandEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    GetEncodedResponseCommandEncoding::Webp => "webp",
                    GetEncodedResponseCommandEncoding::Jpeg => "jpeg",
                    GetEncodedResponseCommandEncoding::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the response body and size if it were re-encoded with the specified settings. Only\napplies to images.\n\n# Command `Audits.getEncodedResponse`\n\n*Domain Module:* [`cdp::audits`](index.html)  \n*Command Struct:* [`cdp::audits::GetEncodedResponseCommand`](struct.GetEncodedResponseCommand.html)  \n*Response Struct:* [`cdp::audits::GetEncodedResponseResponse`](struct.GetEncodedResponseResponse.html)"]
    pub struct GetEncodedResponseCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of the network request to get content for."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "encoding")]
        #[doc = "The encoding to use."]
        pub encoding: ::audits::GetEncodedResponseCommandEncoding,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "The quality of the encoding \\(0-1\\). \\(defaults to 1\\)"]
        pub quality: Option<f64>,
        #[serde(rename = "sizeOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to only return the size information \\(defaults to false\\)."]
        pub size_only: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetEncodedResponseCommand<'a> {
        const COMMAND_NAME: &'static str = "Audits.getEncodedResponse";
    }
    impl<'a> ::SerializeCdpCommand for GetEncodedResponseCommand<'a> {
        fn command_name(&self) -> &str {
            "Audits.getEncodedResponse"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetEncodedResponseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Audits.getEncodedResponse" {
                Ok ( < GetEncodedResponseCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the response body and size if it were re-encoded with the specified settings. Only\napplies to images.\n\n# Command `Audits.getEncodedResponse`\n\n*Domain Module:* [`cdp::audits`](index.html)  \n*Command Struct:* [`cdp::audits::GetEncodedResponseCommand`](struct.GetEncodedResponseCommand.html)  \n*Response Struct:* [`cdp::audits::GetEncodedResponseResponse`](struct.GetEncodedResponseResponse.html)"]
    pub struct GetEncodedResponseResponse<'a> {
        #[serde(rename = "body", skip_serializing_if = "Option::is_none")]
        #[doc = "The encoded body as a base64 string. Omitted if sizeOnly is true."]
        pub body: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "originalSize")]
        #[doc = "Size before re-encoding."]
        pub original_size: i32,
        #[serde(rename = "encodedSize")]
        #[doc = "Size after re-encoding."]
        pub encoded_size: i32,
    }
    impl<'a> ::CdpCommand for GetEncodedResponseResponse<'a> {
        const COMMAND_NAME: &'static str = "Audits.getEncodedResponse";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetEncodedResponseCommand<'a> {
        type Response = GetEncodedResponseResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetEncodedResponseResponse<'b> {
        type Command = GetEncodedResponseCommand<'a>;
    }
}
#[doc = "The Browser domain defines methods and events for browser managing.\n\n# Browser\n\n## Commands\n\n- [`Browser.grantPermissions`](struct.GrantPermissionsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Grant specific permissions to the given origin and reject all others.\n- [`Browser.resetPermissions`](struct.ResetPermissionsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Reset all permission management for all origins.\n- [`Browser.close`](struct.CloseCommand.html)\n\n  Close browser gracefully.\n- [`Browser.crash`](struct.CrashCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Crashes browser on the main thread.\n- [`Browser.getVersion`](struct.GetVersionCommand.html)\n\n  Returns version information.\n- [`Browser.getBrowserCommandLine`](struct.GetBrowserCommandLineCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the command line switches for the browser process if, and only if\n  --enable-automation is on the commandline.\n- [`Browser.getHistograms`](struct.GetHistogramsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get Chrome histograms.\n- [`Browser.getHistogram`](struct.GetHistogramCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get a Chrome histogram by name.\n- [`Browser.getWindowBounds`](struct.GetWindowBoundsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get position and size of the browser window.\n- [`Browser.getWindowForTarget`](struct.GetWindowForTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Get the browser window that contains the devtools target.\n- [`Browser.setWindowBounds`](struct.SetWindowBoundsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Set position and/or size of the browser window.\n\n##Types\n\n- [`WindowID`](type.WindowId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`WindowState`](enum.WindowState.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The state of the browser window.\n- [`Bounds`](struct.Bounds.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Browser window bounds information\n- [`PermissionType`](enum.PermissionType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Bucket`](struct.Bucket.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Chrome histogram bucket.\n- [`Histogram`](struct.Histogram.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Chrome histogram.\n"]
pub mod browser {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Grant specific permissions to the given origin and reject all others.\n\n# Command `Browser.grantPermissions`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GrantPermissionsCommand`](struct.GrantPermissionsCommand.html)  \n*Response Struct:* [`cdp::browser::GrantPermissionsResponse`](struct.GrantPermissionsResponse.html)"]
    pub struct GrantPermissionsCommand<'a> {
        #[serde(rename = "origin")]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "permissions")]
        pub permissions: Vec<::browser::PermissionType>,
        #[serde(rename = "browserContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "BrowserContext to override permissions. When omitted, default browser context is used."]
        pub browser_context_id: Option<::target::BrowserContextId<'a>>,
    }
    impl<'a> ::CdpCommand for GrantPermissionsCommand<'a> {
        const COMMAND_NAME: &'static str = "Browser.grantPermissions";
    }
    impl<'a> ::SerializeCdpCommand for GrantPermissionsCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.grantPermissions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GrantPermissionsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.grantPermissions" {
                Ok ( < GrantPermissionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Grant specific permissions to the given origin and reject all others.\n\n# Command `Browser.grantPermissions`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GrantPermissionsCommand`](struct.GrantPermissionsCommand.html)  \n*Response Struct:* [`cdp::browser::GrantPermissionsResponse`](struct.GrantPermissionsResponse.html)"]
    pub struct GrantPermissionsResponse;
    impl ::serde::Serialize for GrantPermissionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GrantPermissionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GrantPermissionsResponse)
        }
    }
    impl ::CdpCommand for GrantPermissionsResponse {
        const COMMAND_NAME: &'static str = "Browser.grantPermissions";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GrantPermissionsCommand<'a> {
        type Response = GrantPermissionsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GrantPermissionsResponse {
        type Command = GrantPermissionsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Reset all permission management for all origins.\n\n# Command `Browser.resetPermissions`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::ResetPermissionsCommand`](struct.ResetPermissionsCommand.html)  \n*Response Struct:* [`cdp::browser::ResetPermissionsResponse`](struct.ResetPermissionsResponse.html)"]
    pub struct ResetPermissionsCommand<'a> {
        #[serde(rename = "browserContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "BrowserContext to reset permissions. When omitted, default browser context is used."]
        pub browser_context_id: Option<::target::BrowserContextId<'a>>,
    }
    impl<'a> ::CdpCommand for ResetPermissionsCommand<'a> {
        const COMMAND_NAME: &'static str = "Browser.resetPermissions";
    }
    impl<'a> ::SerializeCdpCommand for ResetPermissionsCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.resetPermissions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ResetPermissionsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.resetPermissions" {
                Ok ( < ResetPermissionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Reset all permission management for all origins.\n\n# Command `Browser.resetPermissions`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::ResetPermissionsCommand`](struct.ResetPermissionsCommand.html)  \n*Response Struct:* [`cdp::browser::ResetPermissionsResponse`](struct.ResetPermissionsResponse.html)"]
    pub struct ResetPermissionsResponse;
    impl ::serde::Serialize for ResetPermissionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetPermissionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetPermissionsResponse)
        }
    }
    impl ::CdpCommand for ResetPermissionsResponse {
        const COMMAND_NAME: &'static str = "Browser.resetPermissions";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ResetPermissionsCommand<'a> {
        type Response = ResetPermissionsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ResetPermissionsResponse {
        type Command = ResetPermissionsCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Close browser gracefully.\n\n# Command `Browser.close`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::browser::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseCommand;
    impl ::serde::Serialize for CloseCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CloseCommand)
        }
    }
    impl ::CdpCommand for CloseCommand {
        const COMMAND_NAME: &'static str = "Browser.close";
    }
    impl ::SerializeCdpCommand for CloseCommand {
        fn command_name(&self) -> &str {
            "Browser.close"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CloseCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.close" {
                Ok(
                    <CloseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Close browser gracefully.\n\n# Command `Browser.close`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::browser::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseResponse;
    impl ::serde::Serialize for CloseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CloseResponse)
        }
    }
    impl ::CdpCommand for CloseResponse {
        const COMMAND_NAME: &'static str = "Browser.close";
    }
    impl<'b> ::HasCdpResponse<'b> for CloseCommand {
        type Response = CloseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CloseResponse {
        type Command = CloseCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Crashes browser on the main thread.\n\n# Command `Browser.crash`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::CrashCommand`](struct.CrashCommand.html)  \n*Response Struct:* [`cdp::browser::CrashResponse`](struct.CrashResponse.html)"]
    pub struct CrashCommand;
    impl ::serde::Serialize for CrashCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CrashCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CrashCommand)
        }
    }
    impl ::CdpCommand for CrashCommand {
        const COMMAND_NAME: &'static str = "Browser.crash";
    }
    impl ::SerializeCdpCommand for CrashCommand {
        fn command_name(&self) -> &str {
            "Browser.crash"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CrashCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.crash" {
                Ok(
                    <CrashCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Crashes browser on the main thread.\n\n# Command `Browser.crash`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::CrashCommand`](struct.CrashCommand.html)  \n*Response Struct:* [`cdp::browser::CrashResponse`](struct.CrashResponse.html)"]
    pub struct CrashResponse;
    impl ::serde::Serialize for CrashResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CrashResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CrashResponse)
        }
    }
    impl ::CdpCommand for CrashResponse {
        const COMMAND_NAME: &'static str = "Browser.crash";
    }
    impl<'b> ::HasCdpResponse<'b> for CrashCommand {
        type Response = CrashResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CrashResponse {
        type Command = CrashCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns version information.\n\n# Command `Browser.getVersion`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetVersionCommand`](struct.GetVersionCommand.html)  \n*Response Struct:* [`cdp::browser::GetVersionResponse`](struct.GetVersionResponse.html)"]
    pub struct GetVersionCommand;
    impl ::serde::Serialize for GetVersionCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetVersionCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetVersionCommand)
        }
    }
    impl ::CdpCommand for GetVersionCommand {
        const COMMAND_NAME: &'static str = "Browser.getVersion";
    }
    impl ::SerializeCdpCommand for GetVersionCommand {
        fn command_name(&self) -> &str {
            "Browser.getVersion"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetVersionCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getVersion" {
                Ok(
                    <GetVersionCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns version information.\n\n# Command `Browser.getVersion`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetVersionCommand`](struct.GetVersionCommand.html)  \n*Response Struct:* [`cdp::browser::GetVersionResponse`](struct.GetVersionResponse.html)"]
    pub struct GetVersionResponse<'a> {
        #[serde(rename = "protocolVersion")]
        #[doc = "Protocol version."]
        pub protocol_version: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "product")]
        #[doc = "Product name."]
        pub product: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "revision")]
        #[doc = "Product revision."]
        pub revision: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "userAgent")]
        #[doc = "User-Agent."]
        pub user_agent: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "jsVersion")]
        #[doc = "V8 version."]
        pub js_version: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetVersionResponse<'a> {
        const COMMAND_NAME: &'static str = "Browser.getVersion";
    }
    impl<'b> ::HasCdpResponse<'b> for GetVersionCommand {
        type Response = GetVersionResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetVersionResponse<'b> {
        type Command = GetVersionCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the command line switches for the browser process if, and only if\n--enable-automation is on the commandline.\n\n# Command `Browser.getBrowserCommandLine`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetBrowserCommandLineCommand`](struct.GetBrowserCommandLineCommand.html)  \n*Response Struct:* [`cdp::browser::GetBrowserCommandLineResponse`](struct.GetBrowserCommandLineResponse.html)"]
    pub struct GetBrowserCommandLineCommand;
    impl ::serde::Serialize for GetBrowserCommandLineCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetBrowserCommandLineCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetBrowserCommandLineCommand)
        }
    }
    impl ::CdpCommand for GetBrowserCommandLineCommand {
        const COMMAND_NAME: &'static str = "Browser.getBrowserCommandLine";
    }
    impl ::SerializeCdpCommand for GetBrowserCommandLineCommand {
        fn command_name(&self) -> &str {
            "Browser.getBrowserCommandLine"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetBrowserCommandLineCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getBrowserCommandLine" {
                Ok ( < GetBrowserCommandLineCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the command line switches for the browser process if, and only if\n--enable-automation is on the commandline.\n\n# Command `Browser.getBrowserCommandLine`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetBrowserCommandLineCommand`](struct.GetBrowserCommandLineCommand.html)  \n*Response Struct:* [`cdp::browser::GetBrowserCommandLineResponse`](struct.GetBrowserCommandLineResponse.html)"]
    pub struct GetBrowserCommandLineResponse<'a> {
        #[serde(rename = "arguments")]
        #[doc = "Commandline parameters"]
        pub arguments: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetBrowserCommandLineResponse<'a> {
        const COMMAND_NAME: &'static str = "Browser.getBrowserCommandLine";
    }
    impl<'b> ::HasCdpResponse<'b> for GetBrowserCommandLineCommand {
        type Response = GetBrowserCommandLineResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetBrowserCommandLineResponse<'b> {
        type Command = GetBrowserCommandLineCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get Chrome histograms.\n\n# Command `Browser.getHistograms`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetHistogramsCommand`](struct.GetHistogramsCommand.html)  \n*Response Struct:* [`cdp::browser::GetHistogramsResponse`](struct.GetHistogramsResponse.html)"]
    pub struct GetHistogramsCommand<'a> {
        #[serde(rename = "query", skip_serializing_if = "Option::is_none")]
        #[doc = "Requested substring in name. Only histograms which have query as a\nsubstring in their name are extracted. An empty or absent query returns\nall histograms."]
        pub query: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "delta", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, retrieve delta since last call."]
        pub delta: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetHistogramsCommand<'a> {
        const COMMAND_NAME: &'static str = "Browser.getHistograms";
    }
    impl<'a> ::SerializeCdpCommand for GetHistogramsCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.getHistograms"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetHistogramsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getHistograms" {
                Ok(
                    <GetHistogramsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get Chrome histograms.\n\n# Command `Browser.getHistograms`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetHistogramsCommand`](struct.GetHistogramsCommand.html)  \n*Response Struct:* [`cdp::browser::GetHistogramsResponse`](struct.GetHistogramsResponse.html)"]
    pub struct GetHistogramsResponse<'a> {
        #[serde(rename = "histograms")]
        #[doc = "Histograms."]
        pub histograms: Vec<::browser::Histogram<'a>>,
    }
    impl<'a> ::CdpCommand for GetHistogramsResponse<'a> {
        const COMMAND_NAME: &'static str = "Browser.getHistograms";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetHistogramsCommand<'a> {
        type Response = GetHistogramsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetHistogramsResponse<'b> {
        type Command = GetHistogramsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get a Chrome histogram by name.\n\n# Command `Browser.getHistogram`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetHistogramCommand`](struct.GetHistogramCommand.html)  \n*Response Struct:* [`cdp::browser::GetHistogramResponse`](struct.GetHistogramResponse.html)"]
    pub struct GetHistogramCommand<'a> {
        #[serde(rename = "name")]
        #[doc = "Requested histogram name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "delta", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, retrieve delta since last call."]
        pub delta: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetHistogramCommand<'a> {
        const COMMAND_NAME: &'static str = "Browser.getHistogram";
    }
    impl<'a> ::SerializeCdpCommand for GetHistogramCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.getHistogram"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetHistogramCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getHistogram" {
                Ok(
                    <GetHistogramCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get a Chrome histogram by name.\n\n# Command `Browser.getHistogram`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetHistogramCommand`](struct.GetHistogramCommand.html)  \n*Response Struct:* [`cdp::browser::GetHistogramResponse`](struct.GetHistogramResponse.html)"]
    pub struct GetHistogramResponse<'a> {
        #[serde(rename = "histogram")]
        #[doc = "Histogram."]
        pub histogram: ::browser::Histogram<'a>,
    }
    impl<'a> ::CdpCommand for GetHistogramResponse<'a> {
        const COMMAND_NAME: &'static str = "Browser.getHistogram";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetHistogramCommand<'a> {
        type Response = GetHistogramResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetHistogramResponse<'b> {
        type Command = GetHistogramCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get position and size of the browser window.\n\n# Command `Browser.getWindowBounds`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetWindowBoundsCommand`](struct.GetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::browser::GetWindowBoundsResponse`](struct.GetWindowBoundsResponse.html)"]
    pub struct GetWindowBoundsCommand {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::browser::WindowId,
    }
    impl ::CdpCommand for GetWindowBoundsCommand {
        const COMMAND_NAME: &'static str = "Browser.getWindowBounds";
    }
    impl ::SerializeCdpCommand for GetWindowBoundsCommand {
        fn command_name(&self) -> &str {
            "Browser.getWindowBounds"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetWindowBoundsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getWindowBounds" {
                Ok(
                    <GetWindowBoundsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get position and size of the browser window.\n\n# Command `Browser.getWindowBounds`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetWindowBoundsCommand`](struct.GetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::browser::GetWindowBoundsResponse`](struct.GetWindowBoundsResponse.html)"]
    pub struct GetWindowBoundsResponse {
        #[serde(rename = "bounds")]
        #[doc = "Bounds information of the window. When window state is 'minimized', the restored window\nposition and size are returned."]
        pub bounds: ::browser::Bounds,
    }
    impl ::CdpCommand for GetWindowBoundsResponse {
        const COMMAND_NAME: &'static str = "Browser.getWindowBounds";
    }
    impl<'b> ::HasCdpResponse<'b> for GetWindowBoundsCommand {
        type Response = GetWindowBoundsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetWindowBoundsResponse {
        type Command = GetWindowBoundsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get the browser window that contains the devtools target.\n\n# Command `Browser.getWindowForTarget`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetWindowForTargetCommand`](struct.GetWindowForTargetCommand.html)  \n*Response Struct:* [`cdp::browser::GetWindowForTargetResponse`](struct.GetWindowForTargetResponse.html)"]
    pub struct GetWindowForTargetCommand<'a> {
        #[serde(rename = "targetId")]
        #[doc = "Devtools agent host id."]
        pub target_id: ::target::TargetId<'a>,
    }
    impl<'a> ::CdpCommand for GetWindowForTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Browser.getWindowForTarget";
    }
    impl<'a> ::SerializeCdpCommand for GetWindowForTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Browser.getWindowForTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetWindowForTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.getWindowForTarget" {
                Ok ( < GetWindowForTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Get the browser window that contains the devtools target.\n\n# Command `Browser.getWindowForTarget`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::GetWindowForTargetCommand`](struct.GetWindowForTargetCommand.html)  \n*Response Struct:* [`cdp::browser::GetWindowForTargetResponse`](struct.GetWindowForTargetResponse.html)"]
    pub struct GetWindowForTargetResponse {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::browser::WindowId,
        #[serde(rename = "bounds")]
        #[doc = "Bounds information of the window. When window state is 'minimized', the restored window\nposition and size are returned."]
        pub bounds: ::browser::Bounds,
    }
    impl ::CdpCommand for GetWindowForTargetResponse {
        const COMMAND_NAME: &'static str = "Browser.getWindowForTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetWindowForTargetCommand<'a> {
        type Response = GetWindowForTargetResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetWindowForTargetResponse {
        type Command = GetWindowForTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set position and/or size of the browser window.\n\n# Command `Browser.setWindowBounds`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::SetWindowBoundsCommand`](struct.SetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::browser::SetWindowBoundsResponse`](struct.SetWindowBoundsResponse.html)"]
    pub struct SetWindowBoundsCommand {
        #[serde(rename = "windowId")]
        #[doc = "Browser window id."]
        pub window_id: ::browser::WindowId,
        #[serde(rename = "bounds")]
        #[doc = "New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined\nwith 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged."]
        pub bounds: ::browser::Bounds,
    }
    impl ::CdpCommand for SetWindowBoundsCommand {
        const COMMAND_NAME: &'static str = "Browser.setWindowBounds";
    }
    impl ::SerializeCdpCommand for SetWindowBoundsCommand {
        fn command_name(&self) -> &str {
            "Browser.setWindowBounds"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetWindowBoundsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Browser.setWindowBounds" {
                Ok(
                    <SetWindowBoundsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set position and/or size of the browser window.\n\n# Command `Browser.setWindowBounds`\n\n*Domain Module:* [`cdp::browser`](index.html)  \n*Command Struct:* [`cdp::browser::SetWindowBoundsCommand`](struct.SetWindowBoundsCommand.html)  \n*Response Struct:* [`cdp::browser::SetWindowBoundsResponse`](struct.SetWindowBoundsResponse.html)"]
    pub struct SetWindowBoundsResponse;
    impl ::serde::Serialize for SetWindowBoundsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetWindowBoundsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetWindowBoundsResponse)
        }
    }
    impl ::CdpCommand for SetWindowBoundsResponse {
        const COMMAND_NAME: &'static str = "Browser.setWindowBounds";
    }
    impl<'b> ::HasCdpResponse<'b> for SetWindowBoundsCommand {
        type Response = SetWindowBoundsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetWindowBoundsResponse {
        type Command = SetWindowBoundsCommand;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type WindowId = i32;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The state of the browser window."]
    pub enum WindowState {
        #[serde(rename = "normal")]
        #[doc = "Represented as `\"normal\"`."]
        Normal,
        #[serde(rename = "minimized")]
        #[doc = "Represented as `\"minimized\"`."]
        Minimized,
        #[serde(rename = "maximized")]
        #[doc = "Represented as `\"maximized\"`."]
        Maximized,
        #[serde(rename = "fullscreen")]
        #[doc = "Represented as `\"fullscreen\"`."]
        Fullscreen,
    }
    impl WindowState {
        pub const ENUM_VALUES: &'static [WindowState] = &[
            WindowState::Normal,
            WindowState::Minimized,
            WindowState::Maximized,
            WindowState::Fullscreen,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["normal", "minimized", "maximized", "fullscreen"];
    }
    impl ::std::str::FromStr for WindowState {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "normal" => Ok(WindowState::Normal),
                "minimized" => Ok(WindowState::Minimized),
                "maximized" => Ok(WindowState::Maximized),
                "fullscreen" => Ok(WindowState::Fullscreen),
                _ => Err(::ParseEnumError {
                    expected: WindowState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for WindowState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    WindowState::Normal => "normal",
                    WindowState::Minimized => "minimized",
                    WindowState::Maximized => "maximized",
                    WindowState::Fullscreen => "fullscreen",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Browser window bounds information"]
    pub struct Bounds {
        #[serde(rename = "left", skip_serializing_if = "Option::is_none")]
        #[doc = "The offset from the left edge of the screen to the window in pixels."]
        pub left: Option<i32>,
        #[serde(rename = "top", skip_serializing_if = "Option::is_none")]
        #[doc = "The offset from the top edge of the screen to the window in pixels."]
        pub top: Option<i32>,
        #[serde(rename = "width", skip_serializing_if = "Option::is_none")]
        #[doc = "The window width in pixels."]
        pub width: Option<i32>,
        #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
        #[doc = "The window height in pixels."]
        pub height: Option<i32>,
        #[serde(rename = "windowState", skip_serializing_if = "Option::is_none")]
        #[doc = "The window state. Default to normal."]
        pub window_state: Option<::browser::WindowState>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum PermissionType {
        #[serde(rename = "accessibilityEvents")]
        #[doc = "Represented as `\"accessibilityEvents\"`."]
        AccessibilityEvents,
        #[serde(rename = "audioCapture")]
        #[doc = "Represented as `\"audioCapture\"`."]
        AudioCapture,
        #[serde(rename = "backgroundSync")]
        #[doc = "Represented as `\"backgroundSync\"`."]
        BackgroundSync,
        #[serde(rename = "clipboardRead")]
        #[doc = "Represented as `\"clipboardRead\"`."]
        ClipboardRead,
        #[serde(rename = "clipboardWrite")]
        #[doc = "Represented as `\"clipboardWrite\"`."]
        ClipboardWrite,
        #[serde(rename = "durableStorage")]
        #[doc = "Represented as `\"durableStorage\"`."]
        DurableStorage,
        #[serde(rename = "flash")]
        #[doc = "Represented as `\"flash\"`."]
        Flash,
        #[serde(rename = "geolocation")]
        #[doc = "Represented as `\"geolocation\"`."]
        Geolocation,
        #[serde(rename = "midi")]
        #[doc = "Represented as `\"midi\"`."]
        Midi,
        #[serde(rename = "midiSysex")]
        #[doc = "Represented as `\"midiSysex\"`."]
        MidiSysex,
        #[serde(rename = "notifications")]
        #[doc = "Represented as `\"notifications\"`."]
        Notifications,
        #[serde(rename = "paymentHandler")]
        #[doc = "Represented as `\"paymentHandler\"`."]
        PaymentHandler,
        #[serde(rename = "protectedMediaIdentifier")]
        #[doc = "Represented as `\"protectedMediaIdentifier\"`."]
        ProtectedMediaIdentifier,
        #[serde(rename = "sensors")]
        #[doc = "Represented as `\"sensors\"`."]
        Sensors,
        #[serde(rename = "videoCapture")]
        #[doc = "Represented as `\"videoCapture\"`."]
        VideoCapture,
    }
    impl PermissionType {
        pub const ENUM_VALUES: &'static [PermissionType] =
            &[
                PermissionType::AccessibilityEvents,
                PermissionType::AudioCapture,
                PermissionType::BackgroundSync,
                PermissionType::ClipboardRead,
                PermissionType::ClipboardWrite,
                PermissionType::DurableStorage,
                PermissionType::Flash,
                PermissionType::Geolocation,
                PermissionType::Midi,
                PermissionType::MidiSysex,
                PermissionType::Notifications,
                PermissionType::PaymentHandler,
                PermissionType::ProtectedMediaIdentifier,
                PermissionType::Sensors,
                PermissionType::VideoCapture,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "accessibilityEvents",
            "audioCapture",
            "backgroundSync",
            "clipboardRead",
            "clipboardWrite",
            "durableStorage",
            "flash",
            "geolocation",
            "midi",
            "midiSysex",
            "notifications",
            "paymentHandler",
            "protectedMediaIdentifier",
            "sensors",
            "videoCapture",
        ];
    }
    impl ::std::str::FromStr for PermissionType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "accessibilityEvents" => Ok(PermissionType::AccessibilityEvents),
                "audioCapture" => Ok(PermissionType::AudioCapture),
                "backgroundSync" => Ok(PermissionType::BackgroundSync),
                "clipboardRead" => Ok(PermissionType::ClipboardRead),
                "clipboardWrite" => Ok(PermissionType::ClipboardWrite),
                "durableStorage" => Ok(PermissionType::DurableStorage),
                "flash" => Ok(PermissionType::Flash),
                "geolocation" => Ok(PermissionType::Geolocation),
                "midi" => Ok(PermissionType::Midi),
                "midiSysex" => Ok(PermissionType::MidiSysex),
                "notifications" => Ok(PermissionType::Notifications),
                "paymentHandler" => Ok(PermissionType::PaymentHandler),
                "protectedMediaIdentifier" => Ok(PermissionType::ProtectedMediaIdentifier),
                "sensors" => Ok(PermissionType::Sensors),
                "videoCapture" => Ok(PermissionType::VideoCapture),
                _ => Err(::ParseEnumError {
                    expected: PermissionType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PermissionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PermissionType::AccessibilityEvents => "accessibilityEvents",
                    PermissionType::AudioCapture => "audioCapture",
                    PermissionType::BackgroundSync => "backgroundSync",
                    PermissionType::ClipboardRead => "clipboardRead",
                    PermissionType::ClipboardWrite => "clipboardWrite",
                    PermissionType::DurableStorage => "durableStorage",
                    PermissionType::Flash => "flash",
                    PermissionType::Geolocation => "geolocation",
                    PermissionType::Midi => "midi",
                    PermissionType::MidiSysex => "midiSysex",
                    PermissionType::Notifications => "notifications",
                    PermissionType::PaymentHandler => "paymentHandler",
                    PermissionType::ProtectedMediaIdentifier => "protectedMediaIdentifier",
                    PermissionType::Sensors => "sensors",
                    PermissionType::VideoCapture => "videoCapture",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Chrome histogram bucket."]
    pub struct Bucket {
        #[serde(rename = "low")]
        #[doc = "Minimum value \\(inclusive\\)."]
        pub low: i32,
        #[serde(rename = "high")]
        #[doc = "Maximum value \\(exclusive\\)."]
        pub high: i32,
        #[serde(rename = "count")]
        #[doc = "Number of samples."]
        pub count: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Chrome histogram."]
    pub struct Histogram<'a> {
        #[serde(rename = "name")]
        #[doc = "Name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sum")]
        #[doc = "Sum of sample values."]
        pub sum: i32,
        #[serde(rename = "count")]
        #[doc = "Total number of samples."]
        pub count: i32,
        #[serde(rename = "buckets")]
        #[doc = "Buckets."]
        pub buckets: Vec<::browser::Bucket>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain exposes CSS read/write operations. All CSS objects \\(stylesheets, rules, and styles\\)\nhave an associated `id` used in subsequent operations on the related object. Each object type has\na specific `id` structure, and those are not interchangeable between objects of different kinds.\nCSS objects can be loaded using the `get\\*ForNode\\(\\)` calls \\(which accept a DOM node id\\). A client\ncan also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and\nsubsequently load the required stylesheet contents using the `getStyleSheet\\[Text\\]\\(\\)` methods.\n\n# CSS\n\n## Commands\n\n- [`CSS.addRule`](struct.AddRuleCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the\n  position specified by `location`.\n- [`CSS.collectClassNames`](struct.CollectClassNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all class names from specified stylesheet.\n- [`CSS.createStyleSheet`](struct.CreateStyleSheetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a new special \"via-inspector\" stylesheet in the frame with given `frameId`.\n- [`CSS.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables the CSS agent for the given page.\n- [`CSS.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been\n  enabled until the result of this command is received.\n- [`CSS.forcePseudoState`](struct.ForcePseudoStateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Ensures that the given node will have specified pseudo-classes whenever its style is computed by\n  the browser.\n- [`CSS.getBackgroundColors`](struct.GetBackgroundColorsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSS.getComputedStyleForNode`](struct.GetComputedStyleForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the computed style for a DOM node identified by `nodeId`.\n- [`CSS.getInlineStylesForNode`](struct.GetInlineStylesForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM\n  attributes\\) for a DOM node identified by `nodeId`.\n- [`CSS.getMatchedStylesForNode`](struct.GetMatchedStylesForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns requested styles for a DOM node identified by `nodeId`.\n- [`CSS.getMediaQueries`](struct.GetMediaQueriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all media queries parsed by the rendering engine.\n- [`CSS.getPlatformFontsForNode`](struct.GetPlatformFontsForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests information about platform fonts which we used to render child TextNodes in the given\n  node.\n- [`CSS.getStyleSheetText`](struct.GetStyleSheetTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the current textual content for a stylesheet.\n- [`CSS.setEffectivePropertyValueForNode`](struct.SetEffectivePropertyValueForNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Find a rule with the given active property for the given node and set the new value for this\n  property\n- [`CSS.setKeyframeKey`](struct.SetKeyframeKeyCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the keyframe rule key text.\n- [`CSS.setMediaText`](struct.SetMediaTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the rule selector.\n- [`CSS.setRuleSelector`](struct.SetRuleSelectorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Modifies the rule selector.\n- [`CSS.setStyleSheetText`](struct.SetStyleSheetTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the new stylesheet text.\n- [`CSS.setStyleTexts`](struct.SetStyleTextsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Applies specified style edits one after another in the given order.\n- [`CSS.startRuleUsageTracking`](struct.StartRuleUsageTrackingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables the selector recording.\n- [`CSS.stopRuleUsageTracking`](struct.StopRuleUsageTrackingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stop tracking rule usage and return the list of rules that were used since last call to\n  `takeCoverageDelta` \\(or since start of coverage instrumentation\\)\n- [`CSS.takeCoverageDelta`](struct.TakeCoverageDeltaCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Obtain list of rules that became used since last call to this method \\(or since start of coverage\n  instrumentation\\)\n\n## Events\n\n- [`CSS.fontsUpdated`](struct.FontsUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded\n  web font\n- [`CSS.mediaQueryResultChanged`](struct.MediaQueryResultChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fires whenever a MediaQuery result changes \\(for example, after a browser window has been\n  resized.\\) The current implementation considers only viewport-dependent media features.\n- [`CSS.styleSheetAdded`](struct.StyleSheetAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever an active document stylesheet is added.\n- [`CSS.styleSheetChanged`](struct.StyleSheetChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever a stylesheet is changed as a result of the client operation.\n- [`CSS.styleSheetRemoved`](struct.StyleSheetRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired whenever an active document stylesheet is removed.\n\n##Types\n\n- [`StyleSheetId`](type.StyleSheetId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`StyleSheetOrigin`](enum.StyleSheetOrigin.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stylesheet type: \"injected\" for stylesheets injected via extension, \"user-agent\" for user-agent\n  stylesheets, \"inspector\" for stylesheets created by the inspector \\(i.e. those holding the \"via\n  inspector\" rules\\), \"regular\" for regular stylesheets.\n- [`PseudoElementMatches`](struct.PseudoElementMatches.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS rule collection for a single pseudo style.\n- [`InheritedStyleEntry`](struct.InheritedStyleEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Inherited CSS rule collection from ancestor node.\n- [`RuleMatch`](struct.RuleMatch.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Match data for a CSS rule.\n- [`Value`](struct.Value.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data for a simple selector \\(these are delimited by commas in a selector list\\).\n- [`SelectorList`](struct.SelectorList.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Selector list data.\n- [`CSSStyleSheetHeader`](struct.CssStyleSheetHeader.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS stylesheet metainformation.\n- [`CSSRule`](struct.CssRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS rule representation.\n- [`RuleUsage`](struct.RuleUsage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS coverage information.\n- [`SourceRange`](struct.SourceRange.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Text range within a resource. All numbers are zero-based.\n- [`ShorthandEntry`](struct.ShorthandEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSSComputedStyleProperty`](struct.CssComputedStyleProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CSSStyle`](struct.CssStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS style representation.\n- [`CSSProperty`](struct.CssProperty.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS property declaration data.\n- [`CSSMedia`](struct.CssMedia.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS media rule descriptor.\n- [`MediaQuery`](struct.MediaQuery.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Media query descriptor.\n- [`MediaQueryExpression`](struct.MediaQueryExpression.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Media query expression descriptor.\n- [`PlatformFontUsage`](struct.PlatformFontUsage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about amount of glyphs that were rendered with given font.\n- [`FontFace`](struct.FontFace.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions\n- [`CSSKeyframesRule`](struct.CssKeyframesRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS keyframes rule representation.\n- [`CSSKeyframeRule`](struct.CssKeyframeRule.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  CSS keyframe rule representation.\n- [`StyleDeclarationEdit`](struct.StyleDeclarationEdit.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A descriptor of operation to mutate style declaration text.\n"]
pub mod css {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the\nposition specified by `location`.\n\n# Command `CSS.addRule`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::AddRuleCommand`](struct.AddRuleCommand.html)  \n*Response Struct:* [`cdp::css::AddRuleResponse`](struct.AddRuleResponse.html)"]
    pub struct AddRuleCommand<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier where a new rule should be inserted."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "ruleText")]
        #[doc = "The text of a new rule."]
        pub rule_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Text position of a new rule in the target style sheet."]
        pub location: ::css::SourceRange,
    }
    impl<'a> ::CdpCommand for AddRuleCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.addRule";
    }
    impl<'a> ::SerializeCdpCommand for AddRuleCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.addRule"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddRuleCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.addRule" {
                Ok(
                    <AddRuleCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the\nposition specified by `location`.\n\n# Command `CSS.addRule`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::AddRuleCommand`](struct.AddRuleCommand.html)  \n*Response Struct:* [`cdp::css::AddRuleResponse`](struct.AddRuleResponse.html)"]
    pub struct AddRuleResponse<'a> {
        #[serde(rename = "rule")]
        #[doc = "The newly created rule."]
        pub rule: ::css::CssRule<'a>,
    }
    impl<'a> ::CdpCommand for AddRuleResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.addRule";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddRuleCommand<'a> {
        type Response = AddRuleResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AddRuleResponse<'b> {
        type Command = AddRuleCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all class names from specified stylesheet.\n\n# Command `CSS.collectClassNames`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::CollectClassNamesCommand`](struct.CollectClassNamesCommand.html)  \n*Response Struct:* [`cdp::css::CollectClassNamesResponse`](struct.CollectClassNamesResponse.html)"]
    pub struct CollectClassNamesCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
    }
    impl<'a> ::CdpCommand for CollectClassNamesCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.collectClassNames";
    }
    impl<'a> ::SerializeCdpCommand for CollectClassNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.collectClassNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CollectClassNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.collectClassNames" {
                Ok ( < CollectClassNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all class names from specified stylesheet.\n\n# Command `CSS.collectClassNames`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::CollectClassNamesCommand`](struct.CollectClassNamesCommand.html)  \n*Response Struct:* [`cdp::css::CollectClassNamesResponse`](struct.CollectClassNamesResponse.html)"]
    pub struct CollectClassNamesResponse<'a> {
        #[serde(rename = "classNames")]
        #[doc = "Class name list."]
        pub class_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CollectClassNamesResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.collectClassNames";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CollectClassNamesCommand<'a> {
        type Response = CollectClassNamesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CollectClassNamesResponse<'b> {
        type Command = CollectClassNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new special \"via-inspector\" stylesheet in the frame with given `frameId`.\n\n# Command `CSS.createStyleSheet`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::CreateStyleSheetCommand`](struct.CreateStyleSheetCommand.html)  \n*Response Struct:* [`cdp::css::CreateStyleSheetResponse`](struct.CreateStyleSheetResponse.html)"]
    pub struct CreateStyleSheetCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame where \"via-inspector\" stylesheet should be created."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpCommand for CreateStyleSheetCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.createStyleSheet";
    }
    impl<'a> ::SerializeCdpCommand for CreateStyleSheetCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.createStyleSheet"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CreateStyleSheetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.createStyleSheet" {
                Ok ( < CreateStyleSheetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new special \"via-inspector\" stylesheet in the frame with given `frameId`.\n\n# Command `CSS.createStyleSheet`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::CreateStyleSheetCommand`](struct.CreateStyleSheetCommand.html)  \n*Response Struct:* [`cdp::css::CreateStyleSheetResponse`](struct.CreateStyleSheetResponse.html)"]
    pub struct CreateStyleSheetResponse<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "Identifier of the created \"via-inspector\" stylesheet."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
    }
    impl<'a> ::CdpCommand for CreateStyleSheetResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.createStyleSheet";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CreateStyleSheetCommand<'a> {
        type Response = CreateStyleSheetResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CreateStyleSheetResponse<'b> {
        type Command = CreateStyleSheetCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables the CSS agent for the given page.\n\n# Command `CSS.disable`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::css::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "CSS.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "CSS.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables the CSS agent for the given page.\n\n# Command `CSS.disable`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::css::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "CSS.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been\nenabled until the result of this command is received.\n\n# Command `CSS.enable`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::css::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "CSS.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "CSS.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been\nenabled until the result of this command is received.\n\n# Command `CSS.enable`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::css::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "CSS.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Ensures that the given node will have specified pseudo-classes whenever its style is computed by\nthe browser.\n\n# Command `CSS.forcePseudoState`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::ForcePseudoStateCommand`](struct.ForcePseudoStateCommand.html)  \n*Response Struct:* [`cdp::css::ForcePseudoStateResponse`](struct.ForcePseudoStateResponse.html)"]
    pub struct ForcePseudoStateCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "The element id for which to force the pseudo state."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "forcedPseudoClasses")]
        #[doc = "Element pseudo classes to force when computing the element's style."]
        pub forced_pseudo_classes: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for ForcePseudoStateCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.forcePseudoState";
    }
    impl<'a> ::SerializeCdpCommand for ForcePseudoStateCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.forcePseudoState"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ForcePseudoStateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.forcePseudoState" {
                Ok ( < ForcePseudoStateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Ensures that the given node will have specified pseudo-classes whenever its style is computed by\nthe browser.\n\n# Command `CSS.forcePseudoState`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::ForcePseudoStateCommand`](struct.ForcePseudoStateCommand.html)  \n*Response Struct:* [`cdp::css::ForcePseudoStateResponse`](struct.ForcePseudoStateResponse.html)"]
    pub struct ForcePseudoStateResponse;
    impl ::serde::Serialize for ForcePseudoStateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ForcePseudoStateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ForcePseudoStateResponse)
        }
    }
    impl ::CdpCommand for ForcePseudoStateResponse {
        const COMMAND_NAME: &'static str = "CSS.forcePseudoState";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ForcePseudoStateCommand<'a> {
        type Response = ForcePseudoStateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ForcePseudoStateResponse {
        type Command = ForcePseudoStateCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `CSS.getBackgroundColors`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetBackgroundColorsCommand`](struct.GetBackgroundColorsCommand.html)  \n*Response Struct:* [`cdp::css::GetBackgroundColorsResponse`](struct.GetBackgroundColorsResponse.html)"]
    pub struct GetBackgroundColorsCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get background colors for."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetBackgroundColorsCommand {
        const COMMAND_NAME: &'static str = "CSS.getBackgroundColors";
    }
    impl ::SerializeCdpCommand for GetBackgroundColorsCommand {
        fn command_name(&self) -> &str {
            "CSS.getBackgroundColors"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetBackgroundColorsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getBackgroundColors" {
                Ok ( < GetBackgroundColorsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `CSS.getBackgroundColors`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetBackgroundColorsCommand`](struct.GetBackgroundColorsCommand.html)  \n*Response Struct:* [`cdp::css::GetBackgroundColorsResponse`](struct.GetBackgroundColorsResponse.html)"]
    pub struct GetBackgroundColorsResponse<'a> {
        #[serde(rename = "backgroundColors", skip_serializing_if = "Option::is_none")]
        #[doc = "The range of background colors behind this element, if it contains any visible text. If no\nvisible text is present, this will be undefined. In the case of a flat background color,\nthis will consist of simply that color. In the case of a gradient, this will consist of each\nof the color stops. For anything more complicated, this will be an empty array. Images will\nbe ignored \\(as if the image had failed to load\\)."]
        pub background_colors: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "computedFontSize", skip_serializing_if = "Option::is_none")]
        #[doc = "The computed font size for this node, as a CSS computed value string \\(e.g. '12px'\\)."]
        pub computed_font_size: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "computedFontWeight", skip_serializing_if = "Option::is_none")]
        #[doc = "The computed font weight for this node, as a CSS computed value string \\(e.g. 'normal' or\n'100'\\)."]
        pub computed_font_weight: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "computedBodyFontSize", skip_serializing_if = "Option::is_none")]
        #[doc = "The computed font size for the document body, as a computed CSS value string \\(e.g. '16px'\\)."]
        pub computed_body_font_size: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetBackgroundColorsResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getBackgroundColors";
    }
    impl<'b> ::HasCdpResponse<'b> for GetBackgroundColorsCommand {
        type Response = GetBackgroundColorsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetBackgroundColorsResponse<'b> {
        type Command = GetBackgroundColorsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the computed style for a DOM node identified by `nodeId`.\n\n# Command `CSS.getComputedStyleForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetComputedStyleForNodeCommand`](struct.GetComputedStyleForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetComputedStyleForNodeResponse`](struct.GetComputedStyleForNodeResponse.html)"]
    pub struct GetComputedStyleForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetComputedStyleForNodeCommand {
        const COMMAND_NAME: &'static str = "CSS.getComputedStyleForNode";
    }
    impl ::SerializeCdpCommand for GetComputedStyleForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getComputedStyleForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetComputedStyleForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getComputedStyleForNode" {
                Ok ( < GetComputedStyleForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the computed style for a DOM node identified by `nodeId`.\n\n# Command `CSS.getComputedStyleForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetComputedStyleForNodeCommand`](struct.GetComputedStyleForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetComputedStyleForNodeResponse`](struct.GetComputedStyleForNodeResponse.html)"]
    pub struct GetComputedStyleForNodeResponse<'a> {
        #[serde(rename = "computedStyle")]
        #[doc = "Computed style for the specified DOM node."]
        pub computed_style: Vec<::css::CssComputedStyleProperty<'a>>,
    }
    impl<'a> ::CdpCommand for GetComputedStyleForNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getComputedStyleForNode";
    }
    impl<'b> ::HasCdpResponse<'b> for GetComputedStyleForNodeCommand {
        type Response = GetComputedStyleForNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetComputedStyleForNodeResponse<'b> {
        type Command = GetComputedStyleForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM\nattributes\\) for a DOM node identified by `nodeId`.\n\n# Command `CSS.getInlineStylesForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetInlineStylesForNodeCommand`](struct.GetInlineStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetInlineStylesForNodeResponse`](struct.GetInlineStylesForNodeResponse.html)"]
    pub struct GetInlineStylesForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetInlineStylesForNodeCommand {
        const COMMAND_NAME: &'static str = "CSS.getInlineStylesForNode";
    }
    impl ::SerializeCdpCommand for GetInlineStylesForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getInlineStylesForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetInlineStylesForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getInlineStylesForNode" {
                Ok ( < GetInlineStylesForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the styles defined inline \\(explicitly in the \"style\" attribute and implicitly, using DOM\nattributes\\) for a DOM node identified by `nodeId`.\n\n# Command `CSS.getInlineStylesForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetInlineStylesForNodeCommand`](struct.GetInlineStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetInlineStylesForNodeResponse`](struct.GetInlineStylesForNodeResponse.html)"]
    pub struct GetInlineStylesForNodeResponse<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Inline style for the specified DOM node."]
        pub inline_style: Option<::css::CssStyle<'a>>,
        #[serde(rename = "attributesStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute-defined element style \\(e.g. resulting from \"width=20 height=100%\"\\)."]
        pub attributes_style: Option<::css::CssStyle<'a>>,
    }
    impl<'a> ::CdpCommand for GetInlineStylesForNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getInlineStylesForNode";
    }
    impl<'b> ::HasCdpResponse<'b> for GetInlineStylesForNodeCommand {
        type Response = GetInlineStylesForNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetInlineStylesForNodeResponse<'b> {
        type Command = GetInlineStylesForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns requested styles for a DOM node identified by `nodeId`.\n\n# Command `CSS.getMatchedStylesForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetMatchedStylesForNodeCommand`](struct.GetMatchedStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetMatchedStylesForNodeResponse`](struct.GetMatchedStylesForNodeResponse.html)"]
    pub struct GetMatchedStylesForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetMatchedStylesForNodeCommand {
        const COMMAND_NAME: &'static str = "CSS.getMatchedStylesForNode";
    }
    impl ::SerializeCdpCommand for GetMatchedStylesForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getMatchedStylesForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetMatchedStylesForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getMatchedStylesForNode" {
                Ok ( < GetMatchedStylesForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns requested styles for a DOM node identified by `nodeId`.\n\n# Command `CSS.getMatchedStylesForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetMatchedStylesForNodeCommand`](struct.GetMatchedStylesForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetMatchedStylesForNodeResponse`](struct.GetMatchedStylesForNodeResponse.html)"]
    pub struct GetMatchedStylesForNodeResponse<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Inline style for the specified DOM node."]
        pub inline_style: Option<::css::CssStyle<'a>>,
        #[serde(rename = "attributesStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute-defined element style \\(e.g. resulting from \"width=20 height=100%\"\\)."]
        pub attributes_style: Option<::css::CssStyle<'a>>,
        #[serde(rename = "matchedCSSRules", skip_serializing_if = "Option::is_none")]
        #[doc = "CSS rules matching this node, from all applicable stylesheets."]
        pub matched_css_rules: Option<Vec<::css::RuleMatch<'a>>>,
        #[serde(rename = "pseudoElements", skip_serializing_if = "Option::is_none")]
        #[doc = "Pseudo style matches for this node."]
        pub pseudo_elements: Option<Vec<::css::PseudoElementMatches<'a>>>,
        #[serde(rename = "inherited", skip_serializing_if = "Option::is_none")]
        #[doc = "A chain of inherited styles \\(from the immediate node parent up to the DOM tree root\\)."]
        pub inherited: Option<Vec<::css::InheritedStyleEntry<'a>>>,
        #[serde(rename = "cssKeyframesRules", skip_serializing_if = "Option::is_none")]
        #[doc = "A list of CSS keyframed animations matching this node."]
        pub css_keyframes_rules: Option<Vec<::css::CssKeyframesRule<'a>>>,
    }
    impl<'a> ::CdpCommand for GetMatchedStylesForNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getMatchedStylesForNode";
    }
    impl<'b> ::HasCdpResponse<'b> for GetMatchedStylesForNodeCommand {
        type Response = GetMatchedStylesForNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetMatchedStylesForNodeResponse<'b> {
        type Command = GetMatchedStylesForNodeCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all media queries parsed by the rendering engine.\n\n# Command `CSS.getMediaQueries`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetMediaQueriesCommand`](struct.GetMediaQueriesCommand.html)  \n*Response Struct:* [`cdp::css::GetMediaQueriesResponse`](struct.GetMediaQueriesResponse.html)"]
    pub struct GetMediaQueriesCommand;
    impl ::serde::Serialize for GetMediaQueriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetMediaQueriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetMediaQueriesCommand)
        }
    }
    impl ::CdpCommand for GetMediaQueriesCommand {
        const COMMAND_NAME: &'static str = "CSS.getMediaQueries";
    }
    impl ::SerializeCdpCommand for GetMediaQueriesCommand {
        fn command_name(&self) -> &str {
            "CSS.getMediaQueries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetMediaQueriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getMediaQueries" {
                Ok(
                    <GetMediaQueriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all media queries parsed by the rendering engine.\n\n# Command `CSS.getMediaQueries`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetMediaQueriesCommand`](struct.GetMediaQueriesCommand.html)  \n*Response Struct:* [`cdp::css::GetMediaQueriesResponse`](struct.GetMediaQueriesResponse.html)"]
    pub struct GetMediaQueriesResponse<'a> {
        #[serde(rename = "medias")]
        pub medias: Vec<::css::CssMedia<'a>>,
    }
    impl<'a> ::CdpCommand for GetMediaQueriesResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getMediaQueries";
    }
    impl<'b> ::HasCdpResponse<'b> for GetMediaQueriesCommand {
        type Response = GetMediaQueriesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetMediaQueriesResponse<'b> {
        type Command = GetMediaQueriesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests information about platform fonts which we used to render child TextNodes in the given\nnode.\n\n# Command `CSS.getPlatformFontsForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetPlatformFontsForNodeCommand`](struct.GetPlatformFontsForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetPlatformFontsForNodeResponse`](struct.GetPlatformFontsForNodeResponse.html)"]
    pub struct GetPlatformFontsForNodeCommand {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetPlatformFontsForNodeCommand {
        const COMMAND_NAME: &'static str = "CSS.getPlatformFontsForNode";
    }
    impl ::SerializeCdpCommand for GetPlatformFontsForNodeCommand {
        fn command_name(&self) -> &str {
            "CSS.getPlatformFontsForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetPlatformFontsForNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getPlatformFontsForNode" {
                Ok ( < GetPlatformFontsForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests information about platform fonts which we used to render child TextNodes in the given\nnode.\n\n# Command `CSS.getPlatformFontsForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetPlatformFontsForNodeCommand`](struct.GetPlatformFontsForNodeCommand.html)  \n*Response Struct:* [`cdp::css::GetPlatformFontsForNodeResponse`](struct.GetPlatformFontsForNodeResponse.html)"]
    pub struct GetPlatformFontsForNodeResponse<'a> {
        #[serde(rename = "fonts")]
        #[doc = "Usage statistics for every employed platform font."]
        pub fonts: Vec<::css::PlatformFontUsage<'a>>,
    }
    impl<'a> ::CdpCommand for GetPlatformFontsForNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getPlatformFontsForNode";
    }
    impl<'b> ::HasCdpResponse<'b> for GetPlatformFontsForNodeCommand {
        type Response = GetPlatformFontsForNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetPlatformFontsForNodeResponse<'b> {
        type Command = GetPlatformFontsForNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current textual content for a stylesheet.\n\n# Command `CSS.getStyleSheetText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetStyleSheetTextCommand`](struct.GetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::css::GetStyleSheetTextResponse`](struct.GetStyleSheetTextResponse.html)"]
    pub struct GetStyleSheetTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
    }
    impl<'a> ::CdpCommand for GetStyleSheetTextCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.getStyleSheetText";
    }
    impl<'a> ::SerializeCdpCommand for GetStyleSheetTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.getStyleSheetText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetStyleSheetTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.getStyleSheetText" {
                Ok ( < GetStyleSheetTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the current textual content for a stylesheet.\n\n# Command `CSS.getStyleSheetText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::GetStyleSheetTextCommand`](struct.GetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::css::GetStyleSheetTextResponse`](struct.GetStyleSheetTextResponse.html)"]
    pub struct GetStyleSheetTextResponse<'a> {
        #[serde(rename = "text")]
        #[doc = "The stylesheet text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetStyleSheetTextResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.getStyleSheetText";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetStyleSheetTextCommand<'a> {
        type Response = GetStyleSheetTextResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetStyleSheetTextResponse<'b> {
        type Command = GetStyleSheetTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Find a rule with the given active property for the given node and set the new value for this\nproperty\n\n# Command `CSS.setEffectivePropertyValueForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetEffectivePropertyValueForNodeCommand`](struct.SetEffectivePropertyValueForNodeCommand.html)  \n*Response Struct:* [`cdp::css::SetEffectivePropertyValueForNodeResponse`](struct.SetEffectivePropertyValueForNodeResponse.html)"]
    pub struct SetEffectivePropertyValueForNodeCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "The element id for which to set property."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "propertyName")]
        pub property_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetEffectivePropertyValueForNodeCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setEffectivePropertyValueForNode";
    }
    impl<'a> ::SerializeCdpCommand for SetEffectivePropertyValueForNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setEffectivePropertyValueForNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetEffectivePropertyValueForNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setEffectivePropertyValueForNode" {
                Ok ( < SetEffectivePropertyValueForNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Find a rule with the given active property for the given node and set the new value for this\nproperty\n\n# Command `CSS.setEffectivePropertyValueForNode`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetEffectivePropertyValueForNodeCommand`](struct.SetEffectivePropertyValueForNodeCommand.html)  \n*Response Struct:* [`cdp::css::SetEffectivePropertyValueForNodeResponse`](struct.SetEffectivePropertyValueForNodeResponse.html)"]
    pub struct SetEffectivePropertyValueForNodeResponse;
    impl ::serde::Serialize for SetEffectivePropertyValueForNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEffectivePropertyValueForNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEffectivePropertyValueForNodeResponse)
        }
    }
    impl ::CdpCommand for SetEffectivePropertyValueForNodeResponse {
        const COMMAND_NAME: &'static str = "CSS.setEffectivePropertyValueForNode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetEffectivePropertyValueForNodeCommand<'a> {
        type Response = SetEffectivePropertyValueForNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetEffectivePropertyValueForNodeResponse {
        type Command = SetEffectivePropertyValueForNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the keyframe rule key text.\n\n# Command `CSS.setKeyframeKey`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetKeyframeKeyCommand`](struct.SetKeyframeKeyCommand.html)  \n*Response Struct:* [`cdp::css::SetKeyframeKeyResponse`](struct.SetKeyframeKeyResponse.html)"]
    pub struct SetKeyframeKeyCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::css::SourceRange,
        #[serde(rename = "keyText")]
        pub key_text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetKeyframeKeyCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setKeyframeKey";
    }
    impl<'a> ::SerializeCdpCommand for SetKeyframeKeyCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setKeyframeKey"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetKeyframeKeyCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setKeyframeKey" {
                Ok(
                    <SetKeyframeKeyCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the keyframe rule key text.\n\n# Command `CSS.setKeyframeKey`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetKeyframeKeyCommand`](struct.SetKeyframeKeyCommand.html)  \n*Response Struct:* [`cdp::css::SetKeyframeKeyResponse`](struct.SetKeyframeKeyResponse.html)"]
    pub struct SetKeyframeKeyResponse<'a> {
        #[serde(rename = "keyText")]
        #[doc = "The resulting key text after modification."]
        pub key_text: ::css::Value<'a>,
    }
    impl<'a> ::CdpCommand for SetKeyframeKeyResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.setKeyframeKey";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetKeyframeKeyCommand<'a> {
        type Response = SetKeyframeKeyResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetKeyframeKeyResponse<'b> {
        type Command = SetKeyframeKeyCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setMediaText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetMediaTextCommand`](struct.SetMediaTextCommand.html)  \n*Response Struct:* [`cdp::css::SetMediaTextResponse`](struct.SetMediaTextResponse.html)"]
    pub struct SetMediaTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::css::SourceRange,
        #[serde(rename = "text")]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetMediaTextCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setMediaText";
    }
    impl<'a> ::SerializeCdpCommand for SetMediaTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setMediaText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetMediaTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setMediaText" {
                Ok(
                    <SetMediaTextCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setMediaText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetMediaTextCommand`](struct.SetMediaTextCommand.html)  \n*Response Struct:* [`cdp::css::SetMediaTextResponse`](struct.SetMediaTextResponse.html)"]
    pub struct SetMediaTextResponse<'a> {
        #[serde(rename = "media")]
        #[doc = "The resulting CSS media rule after modification."]
        pub media: ::css::CssMedia<'a>,
    }
    impl<'a> ::CdpCommand for SetMediaTextResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.setMediaText";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetMediaTextCommand<'a> {
        type Response = SetMediaTextResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetMediaTextResponse<'b> {
        type Command = SetMediaTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setRuleSelector`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetRuleSelectorCommand`](struct.SetRuleSelectorCommand.html)  \n*Response Struct:* [`cdp::css::SetRuleSelectorResponse`](struct.SetRuleSelectorResponse.html)"]
    pub struct SetRuleSelectorCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        pub range: ::css::SourceRange,
        #[serde(rename = "selector")]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetRuleSelectorCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setRuleSelector";
    }
    impl<'a> ::SerializeCdpCommand for SetRuleSelectorCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setRuleSelector"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetRuleSelectorCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setRuleSelector" {
                Ok(
                    <SetRuleSelectorCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Modifies the rule selector.\n\n# Command `CSS.setRuleSelector`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetRuleSelectorCommand`](struct.SetRuleSelectorCommand.html)  \n*Response Struct:* [`cdp::css::SetRuleSelectorResponse`](struct.SetRuleSelectorResponse.html)"]
    pub struct SetRuleSelectorResponse<'a> {
        #[serde(rename = "selectorList")]
        #[doc = "The resulting selector list after modification."]
        pub selector_list: ::css::SelectorList<'a>,
    }
    impl<'a> ::CdpCommand for SetRuleSelectorResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.setRuleSelector";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetRuleSelectorCommand<'a> {
        type Response = SetRuleSelectorResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetRuleSelectorResponse<'b> {
        type Command = SetRuleSelectorCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the new stylesheet text.\n\n# Command `CSS.setStyleSheetText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetStyleSheetTextCommand`](struct.SetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::css::SetStyleSheetTextResponse`](struct.SetStyleSheetTextResponse.html)"]
    pub struct SetStyleSheetTextCommand<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "text")]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetStyleSheetTextCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setStyleSheetText";
    }
    impl<'a> ::SerializeCdpCommand for SetStyleSheetTextCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setStyleSheetText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetStyleSheetTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setStyleSheetText" {
                Ok ( < SetStyleSheetTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the new stylesheet text.\n\n# Command `CSS.setStyleSheetText`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetStyleSheetTextCommand`](struct.SetStyleSheetTextCommand.html)  \n*Response Struct:* [`cdp::css::SetStyleSheetTextResponse`](struct.SetStyleSheetTextResponse.html)"]
    pub struct SetStyleSheetTextResponse<'a> {
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetStyleSheetTextResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.setStyleSheetText";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetStyleSheetTextCommand<'a> {
        type Response = SetStyleSheetTextResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetStyleSheetTextResponse<'b> {
        type Command = SetStyleSheetTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Applies specified style edits one after another in the given order.\n\n# Command `CSS.setStyleTexts`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetStyleTextsCommand`](struct.SetStyleTextsCommand.html)  \n*Response Struct:* [`cdp::css::SetStyleTextsResponse`](struct.SetStyleTextsResponse.html)"]
    pub struct SetStyleTextsCommand<'a> {
        #[serde(rename = "edits")]
        pub edits: Vec<::css::StyleDeclarationEdit<'a>>,
    }
    impl<'a> ::CdpCommand for SetStyleTextsCommand<'a> {
        const COMMAND_NAME: &'static str = "CSS.setStyleTexts";
    }
    impl<'a> ::SerializeCdpCommand for SetStyleTextsCommand<'a> {
        fn command_name(&self) -> &str {
            "CSS.setStyleTexts"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetStyleTextsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.setStyleTexts" {
                Ok(
                    <SetStyleTextsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Applies specified style edits one after another in the given order.\n\n# Command `CSS.setStyleTexts`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::SetStyleTextsCommand`](struct.SetStyleTextsCommand.html)  \n*Response Struct:* [`cdp::css::SetStyleTextsResponse`](struct.SetStyleTextsResponse.html)"]
    pub struct SetStyleTextsResponse<'a> {
        #[serde(rename = "styles")]
        #[doc = "The resulting styles after modification."]
        pub styles: Vec<::css::CssStyle<'a>>,
    }
    impl<'a> ::CdpCommand for SetStyleTextsResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.setStyleTexts";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetStyleTextsCommand<'a> {
        type Response = SetStyleTextsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetStyleTextsResponse<'b> {
        type Command = SetStyleTextsCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the selector recording.\n\n# Command `CSS.startRuleUsageTracking`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::StartRuleUsageTrackingCommand`](struct.StartRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::css::StartRuleUsageTrackingResponse`](struct.StartRuleUsageTrackingResponse.html)"]
    pub struct StartRuleUsageTrackingCommand;
    impl ::serde::Serialize for StartRuleUsageTrackingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartRuleUsageTrackingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartRuleUsageTrackingCommand)
        }
    }
    impl ::CdpCommand for StartRuleUsageTrackingCommand {
        const COMMAND_NAME: &'static str = "CSS.startRuleUsageTracking";
    }
    impl ::SerializeCdpCommand for StartRuleUsageTrackingCommand {
        fn command_name(&self) -> &str {
            "CSS.startRuleUsageTracking"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartRuleUsageTrackingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.startRuleUsageTracking" {
                Ok ( < StartRuleUsageTrackingCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables the selector recording.\n\n# Command `CSS.startRuleUsageTracking`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::StartRuleUsageTrackingCommand`](struct.StartRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::css::StartRuleUsageTrackingResponse`](struct.StartRuleUsageTrackingResponse.html)"]
    pub struct StartRuleUsageTrackingResponse;
    impl ::serde::Serialize for StartRuleUsageTrackingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartRuleUsageTrackingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartRuleUsageTrackingResponse)
        }
    }
    impl ::CdpCommand for StartRuleUsageTrackingResponse {
        const COMMAND_NAME: &'static str = "CSS.startRuleUsageTracking";
    }
    impl<'b> ::HasCdpResponse<'b> for StartRuleUsageTrackingCommand {
        type Response = StartRuleUsageTrackingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartRuleUsageTrackingResponse {
        type Command = StartRuleUsageTrackingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop tracking rule usage and return the list of rules that were used since last call to\n`takeCoverageDelta` \\(or since start of coverage instrumentation\\)\n\n# Command `CSS.stopRuleUsageTracking`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::StopRuleUsageTrackingCommand`](struct.StopRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::css::StopRuleUsageTrackingResponse`](struct.StopRuleUsageTrackingResponse.html)"]
    pub struct StopRuleUsageTrackingCommand;
    impl ::serde::Serialize for StopRuleUsageTrackingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopRuleUsageTrackingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopRuleUsageTrackingCommand)
        }
    }
    impl ::CdpCommand for StopRuleUsageTrackingCommand {
        const COMMAND_NAME: &'static str = "CSS.stopRuleUsageTracking";
    }
    impl ::SerializeCdpCommand for StopRuleUsageTrackingCommand {
        fn command_name(&self) -> &str {
            "CSS.stopRuleUsageTracking"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopRuleUsageTrackingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.stopRuleUsageTracking" {
                Ok ( < StopRuleUsageTrackingCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop tracking rule usage and return the list of rules that were used since last call to\n`takeCoverageDelta` \\(or since start of coverage instrumentation\\)\n\n# Command `CSS.stopRuleUsageTracking`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::StopRuleUsageTrackingCommand`](struct.StopRuleUsageTrackingCommand.html)  \n*Response Struct:* [`cdp::css::StopRuleUsageTrackingResponse`](struct.StopRuleUsageTrackingResponse.html)"]
    pub struct StopRuleUsageTrackingResponse<'a> {
        #[serde(rename = "ruleUsage")]
        pub rule_usage: Vec<::css::RuleUsage<'a>>,
    }
    impl<'a> ::CdpCommand for StopRuleUsageTrackingResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.stopRuleUsageTracking";
    }
    impl<'b> ::HasCdpResponse<'b> for StopRuleUsageTrackingCommand {
        type Response = StopRuleUsageTrackingResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for StopRuleUsageTrackingResponse<'b> {
        type Command = StopRuleUsageTrackingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Obtain list of rules that became used since last call to this method \\(or since start of coverage\ninstrumentation\\)\n\n# Command `CSS.takeCoverageDelta`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::TakeCoverageDeltaCommand`](struct.TakeCoverageDeltaCommand.html)  \n*Response Struct:* [`cdp::css::TakeCoverageDeltaResponse`](struct.TakeCoverageDeltaResponse.html)"]
    pub struct TakeCoverageDeltaCommand;
    impl ::serde::Serialize for TakeCoverageDeltaCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakeCoverageDeltaCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakeCoverageDeltaCommand)
        }
    }
    impl ::CdpCommand for TakeCoverageDeltaCommand {
        const COMMAND_NAME: &'static str = "CSS.takeCoverageDelta";
    }
    impl ::SerializeCdpCommand for TakeCoverageDeltaCommand {
        fn command_name(&self) -> &str {
            "CSS.takeCoverageDelta"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for TakeCoverageDeltaCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.takeCoverageDelta" {
                Ok ( < TakeCoverageDeltaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Obtain list of rules that became used since last call to this method \\(or since start of coverage\ninstrumentation\\)\n\n# Command `CSS.takeCoverageDelta`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Command Struct:* [`cdp::css::TakeCoverageDeltaCommand`](struct.TakeCoverageDeltaCommand.html)  \n*Response Struct:* [`cdp::css::TakeCoverageDeltaResponse`](struct.TakeCoverageDeltaResponse.html)"]
    pub struct TakeCoverageDeltaResponse<'a> {
        #[serde(rename = "coverage")]
        pub coverage: Vec<::css::RuleUsage<'a>>,
    }
    impl<'a> ::CdpCommand for TakeCoverageDeltaResponse<'a> {
        const COMMAND_NAME: &'static str = "CSS.takeCoverageDelta";
    }
    impl<'b> ::HasCdpResponse<'b> for TakeCoverageDeltaCommand {
        type Response = TakeCoverageDeltaResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for TakeCoverageDeltaResponse<'b> {
        type Command = TakeCoverageDeltaCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded\nweb font\n\n# Event `CSS.fontsUpdated`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Event Struct:* [`cdp::css::FontsUpdatedEvent`](struct.FontsUpdatedEvent.html)"]
    pub struct FontsUpdatedEvent<'a> {
        #[serde(rename = "font", skip_serializing_if = "Option::is_none")]
        #[doc = "The web font that has loaded."]
        pub font: Option<::css::FontFace<'a>>,
    }
    impl<'a> ::CdpEvent for FontsUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "CSS.fontsUpdated";
    }
    impl<'a> ::SerializeCdpEvent for FontsUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.fontsUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FontsUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.fontsUpdated" {
                Ok(
                    <FontsUpdatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fires whenever a MediaQuery result changes \\(for example, after a browser window has been\nresized.\\) The current implementation considers only viewport-dependent media features.\n\n# Event `CSS.mediaQueryResultChanged`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Event Struct:* [`cdp::css::MediaQueryResultChangedEvent`](struct.MediaQueryResultChangedEvent.html)"]
    pub struct MediaQueryResultChangedEvent;
    impl ::serde::Serialize for MediaQueryResultChangedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MediaQueryResultChangedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MediaQueryResultChangedEvent)
        }
    }
    impl ::CdpEvent for MediaQueryResultChangedEvent {
        const EVENT_NAME: &'static str = "CSS.mediaQueryResultChanged";
    }
    impl ::SerializeCdpEvent for MediaQueryResultChangedEvent {
        fn event_name(&self) -> &str {
            "CSS.mediaQueryResultChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for MediaQueryResultChangedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.mediaQueryResultChanged" {
                Ok ( < MediaQueryResultChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever an active document stylesheet is added.\n\n# Event `CSS.styleSheetAdded`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Event Struct:* [`cdp::css::StyleSheetAddedEvent`](struct.StyleSheetAddedEvent.html)"]
    pub struct StyleSheetAddedEvent<'a> {
        #[serde(rename = "header")]
        #[doc = "Added stylesheet metainfo."]
        pub header: ::css::CssStyleSheetHeader<'a>,
    }
    impl<'a> ::CdpEvent for StyleSheetAddedEvent<'a> {
        const EVENT_NAME: &'static str = "CSS.styleSheetAdded";
    }
    impl<'a> ::SerializeCdpEvent for StyleSheetAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for StyleSheetAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetAdded" {
                Ok(
                    <StyleSheetAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever a stylesheet is changed as a result of the client operation.\n\n# Event `CSS.styleSheetChanged`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Event Struct:* [`cdp::css::StyleSheetChangedEvent`](struct.StyleSheetChangedEvent.html)"]
    pub struct StyleSheetChangedEvent<'a> {
        #[serde(rename = "styleSheetId")]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
    }
    impl<'a> ::CdpEvent for StyleSheetChangedEvent<'a> {
        const EVENT_NAME: &'static str = "CSS.styleSheetChanged";
    }
    impl<'a> ::SerializeCdpEvent for StyleSheetChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for StyleSheetChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetChanged" {
                Ok(
                    <StyleSheetChangedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired whenever an active document stylesheet is removed.\n\n# Event `CSS.styleSheetRemoved`\n\n*Domain Module:* [`cdp::css`](index.html)  \n*Event Struct:* [`cdp::css::StyleSheetRemovedEvent`](struct.StyleSheetRemovedEvent.html)"]
    pub struct StyleSheetRemovedEvent<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "Identifier of the removed stylesheet."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
    }
    impl<'a> ::CdpEvent for StyleSheetRemovedEvent<'a> {
        const EVENT_NAME: &'static str = "CSS.styleSheetRemoved";
    }
    impl<'a> ::SerializeCdpEvent for StyleSheetRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "CSS.styleSheetRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for StyleSheetRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CSS.styleSheetRemoved" {
                Ok(
                    <StyleSheetRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type StyleSheetId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stylesheet type: \"injected\" for stylesheets injected via extension, \"user-agent\" for user-agent\nstylesheets, \"inspector\" for stylesheets created by the inspector \\(i.e. those holding the \"via\ninspector\" rules\\), \"regular\" for regular stylesheets."]
    pub enum StyleSheetOrigin {
        #[serde(rename = "injected")]
        #[doc = "Represented as `\"injected\"`."]
        Injected,
        #[serde(rename = "user-agent")]
        #[doc = "Represented as `\"user-agent\"`."]
        UserAgent,
        #[serde(rename = "inspector")]
        #[doc = "Represented as `\"inspector\"`."]
        Inspector,
        #[serde(rename = "regular")]
        #[doc = "Represented as `\"regular\"`."]
        Regular,
    }
    impl StyleSheetOrigin {
        pub const ENUM_VALUES: &'static [StyleSheetOrigin] = &[
            StyleSheetOrigin::Injected,
            StyleSheetOrigin::UserAgent,
            StyleSheetOrigin::Inspector,
            StyleSheetOrigin::Regular,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["injected", "user-agent", "inspector", "regular"];
    }
    impl ::std::str::FromStr for StyleSheetOrigin {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "injected" => Ok(StyleSheetOrigin::Injected),
                "user-agent" => Ok(StyleSheetOrigin::UserAgent),
                "inspector" => Ok(StyleSheetOrigin::Inspector),
                "regular" => Ok(StyleSheetOrigin::Regular),
                _ => Err(::ParseEnumError {
                    expected: StyleSheetOrigin::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StyleSheetOrigin {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StyleSheetOrigin::Injected => "injected",
                    StyleSheetOrigin::UserAgent => "user-agent",
                    StyleSheetOrigin::Inspector => "inspector",
                    StyleSheetOrigin::Regular => "regular",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS rule collection for a single pseudo style."]
    pub struct PseudoElementMatches<'a> {
        #[serde(rename = "pseudoType")]
        #[doc = "Pseudo element type."]
        pub pseudo_type: ::dom::PseudoType,
        #[serde(rename = "matches")]
        #[doc = "Matches of CSS rules applicable to the pseudo style."]
        pub matches: Vec<::css::RuleMatch<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inherited CSS rule collection from ancestor node."]
    pub struct InheritedStyleEntry<'a> {
        #[serde(rename = "inlineStyle", skip_serializing_if = "Option::is_none")]
        #[doc = "The ancestor node's inline style, if any, in the style inheritance chain."]
        pub inline_style: Option<::css::CssStyle<'a>>,
        #[serde(rename = "matchedCSSRules")]
        #[doc = "Matches of CSS rules matching the ancestor node in the style inheritance chain."]
        pub matched_css_rules: Vec<::css::RuleMatch<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Match data for a CSS rule."]
    pub struct RuleMatch<'a> {
        #[serde(rename = "rule")]
        #[doc = "CSS rule in the match."]
        pub rule: ::css::CssRule<'a>,
        #[serde(rename = "matchingSelectors")]
        #[doc = "Matching selector indices in the rule's selectorList selectors \\(0-based\\)."]
        pub matching_selectors: Vec<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data for a simple selector \\(these are delimited by commas in a selector list\\)."]
    pub struct Value<'a> {
        #[serde(rename = "text")]
        #[doc = "Value text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "Value range in the underlying resource \\(if available\\)."]
        pub range: Option<::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Selector list data."]
    pub struct SelectorList<'a> {
        #[serde(rename = "selectors")]
        #[doc = "Selectors in the list."]
        pub selectors: Vec<::css::Value<'a>>,
        #[serde(rename = "text")]
        #[doc = "Rule selector text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS stylesheet metainformation."]
    pub struct CssStyleSheetHeader<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The stylesheet identifier."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "frameId")]
        #[doc = "Owner frame identifier."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "sourceURL")]
        #[doc = "Stylesheet resource URL."]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with the stylesheet \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "origin")]
        #[doc = "Stylesheet origin."]
        pub origin: ::css::StyleSheetOrigin,
        #[serde(rename = "title")]
        #[doc = "Stylesheet title."]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "ownerNode", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend id for the owner node of the stylesheet."]
        pub owner_node: Option<::dom::BackendNodeId>,
        #[serde(rename = "disabled")]
        #[doc = "Denotes whether the stylesheet is disabled."]
        pub disabled: bool,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the sourceURL field value comes from the sourceURL comment."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isInline")]
        #[doc = "Whether this stylesheet is created for STYLE tag by parser. This flag is not set for\ndocument.written STYLE tags."]
        pub is_inline: bool,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the stylesheet within the resource \\(zero based\\)."]
        pub start_line: f64,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the stylesheet within the resource \\(zero based\\)."]
        pub start_column: f64,
        #[serde(rename = "length")]
        #[doc = "Size of the content \\(in characters\\)."]
        pub length: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS rule representation."]
    pub struct CssRule<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified\nstylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::css::StyleSheetId<'a>>,
        #[serde(rename = "selectorList")]
        #[doc = "Rule selector data."]
        pub selector_list: ::css::SelectorList<'a>,
        #[serde(rename = "origin")]
        #[doc = "Parent stylesheet's origin."]
        pub origin: ::css::StyleSheetOrigin,
        #[serde(rename = "style")]
        #[doc = "Associated style declaration."]
        pub style: ::css::CssStyle<'a>,
        #[serde(rename = "media", skip_serializing_if = "Option::is_none")]
        #[doc = "Media list array \\(for rules involving media queries\\). The array enumerates media queries\nstarting with the innermost one, going outwards."]
        pub media: Option<Vec<::css::CssMedia<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS coverage information."]
    pub struct RuleUsage<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified\nstylesheet rules\\) this rule came from."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "startOffset")]
        #[doc = "Offset of the start of the rule \\(including selector\\) from the beginning of the stylesheet."]
        pub start_offset: f64,
        #[serde(rename = "endOffset")]
        #[doc = "Offset of the end of the rule body from the beginning of the stylesheet."]
        pub end_offset: f64,
        #[serde(rename = "used")]
        #[doc = "Indicates whether the rule was actually used by some element in the page."]
        pub used: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Text range within a resource. All numbers are zero-based."]
    pub struct SourceRange {
        #[serde(rename = "startLine")]
        #[doc = "Start line of range."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Start column of range \\(inclusive\\)."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "End line of range"]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "End column of range \\(exclusive\\)."]
        pub end_column: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct ShorthandEntry<'a> {
        #[serde(rename = "name")]
        #[doc = "Shorthand name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Shorthand value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "important", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property has \"!important\" annotation \\(implies `false` if absent\\)."]
        pub important: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct CssComputedStyleProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "Computed style property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Computed style property value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS style representation."]
    pub struct CssStyle<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified\nstylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::css::StyleSheetId<'a>>,
        #[serde(rename = "cssProperties")]
        #[doc = "CSS properties in the style."]
        pub css_properties: Vec<::css::CssProperty<'a>>,
        #[serde(rename = "shorthandEntries")]
        #[doc = "Computed values for all shorthands found in the style."]
        pub shorthand_entries: Vec<::css::ShorthandEntry<'a>>,
        #[serde(rename = "cssText", skip_serializing_if = "Option::is_none")]
        #[doc = "Style declaration text \\(if available\\)."]
        pub css_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "Style declaration range in the enclosing stylesheet \\(if available\\)."]
        pub range: Option<::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS property declaration data."]
    pub struct CssProperty<'a> {
        #[serde(rename = "name")]
        #[doc = "The property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "The property value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "important", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property has \"!important\" annotation \\(implies `false` if absent\\)."]
        pub important: Option<bool>,
        #[serde(rename = "implicit", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is implicit \\(implies `false` if absent\\)."]
        pub implicit: Option<bool>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "The full property text as specified in the style."]
        pub text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "parsedOk", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is understood by the browser \\(implies `true` if absent\\)."]
        pub parsed_ok: Option<bool>,
        #[serde(rename = "disabled", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the property is disabled by the user \\(present for source-based properties only\\)."]
        pub disabled: Option<bool>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "The entire property range in the enclosing style declaration \\(if available\\)."]
        pub range: Option<::css::SourceRange>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::css::CssMedia::source`](struct.CssMedia.html#structfield.source)."]
    pub enum CssMediaSource {
        #[serde(rename = "mediaRule")]
        #[doc = "Represented as `\"mediaRule\"`."]
        MediaRule,
        #[serde(rename = "importRule")]
        #[doc = "Represented as `\"importRule\"`."]
        ImportRule,
        #[serde(rename = "linkedSheet")]
        #[doc = "Represented as `\"linkedSheet\"`."]
        LinkedSheet,
        #[serde(rename = "inlineSheet")]
        #[doc = "Represented as `\"inlineSheet\"`."]
        InlineSheet,
    }
    impl CssMediaSource {
        pub const ENUM_VALUES: &'static [CssMediaSource] = &[
            CssMediaSource::MediaRule,
            CssMediaSource::ImportRule,
            CssMediaSource::LinkedSheet,
            CssMediaSource::InlineSheet,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mediaRule", "importRule", "linkedSheet", "inlineSheet"];
    }
    impl ::std::str::FromStr for CssMediaSource {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mediaRule" => Ok(CssMediaSource::MediaRule),
                "importRule" => Ok(CssMediaSource::ImportRule),
                "linkedSheet" => Ok(CssMediaSource::LinkedSheet),
                "inlineSheet" => Ok(CssMediaSource::InlineSheet),
                _ => Err(::ParseEnumError {
                    expected: CssMediaSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CssMediaSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CssMediaSource::MediaRule => "mediaRule",
                    CssMediaSource::ImportRule => "importRule",
                    CssMediaSource::LinkedSheet => "linkedSheet",
                    CssMediaSource::InlineSheet => "inlineSheet",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS media rule descriptor."]
    pub struct CssMedia<'a> {
        #[serde(rename = "text")]
        #[doc = "Media query text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "source")]
        #[doc = "Source of the media query: \"mediaRule\" if specified by a @media rule, \"importRule\" if\nspecified by an @import rule, \"linkedSheet\" if specified by a \"media\" attribute in a linked\nstylesheet's LINK tag, \"inlineSheet\" if specified by a \"media\" attribute in an inline\nstylesheet's STYLE tag."]
        pub source: ::css::CssMediaSource,
        #[serde(rename = "sourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the document containing the media query description."]
        pub source_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "range", skip_serializing_if = "Option::is_none")]
        #[doc = "The associated rule \\(@media or @import\\) header range in the enclosing stylesheet \\(if\navailable\\)."]
        pub range: Option<::css::SourceRange>,
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the stylesheet containing this object \\(if exists\\)."]
        pub style_sheet_id: Option<::css::StyleSheetId<'a>>,
        #[serde(rename = "mediaList", skip_serializing_if = "Option::is_none")]
        #[doc = "Array of media queries."]
        pub media_list: Option<Vec<::css::MediaQuery<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Media query descriptor."]
    pub struct MediaQuery<'a> {
        #[serde(rename = "expressions")]
        #[doc = "Array of media query expressions."]
        pub expressions: Vec<::css::MediaQueryExpression<'a>>,
        #[serde(rename = "active")]
        #[doc = "Whether the media query condition is satisfied."]
        pub active: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Media query expression descriptor."]
    pub struct MediaQueryExpression<'a> {
        #[serde(rename = "value")]
        #[doc = "Media query expression value."]
        pub value: f64,
        #[serde(rename = "unit")]
        #[doc = "Media query expression units."]
        pub unit: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "feature")]
        #[doc = "Media query expression feature."]
        pub feature: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "valueRange", skip_serializing_if = "Option::is_none")]
        #[doc = "The associated range of the value text in the enclosing stylesheet \\(if available\\)."]
        pub value_range: Option<::css::SourceRange>,
        #[serde(rename = "computedLength", skip_serializing_if = "Option::is_none")]
        #[doc = "Computed length of media query expression \\(if applicable\\)."]
        pub computed_length: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about amount of glyphs that were rendered with given font."]
    pub struct PlatformFontUsage<'a> {
        #[serde(rename = "familyName")]
        #[doc = "Font's family name reported by platform."]
        pub family_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isCustomFont")]
        #[doc = "Indicates if the font was downloaded or resolved locally."]
        pub is_custom_font: bool,
        #[serde(rename = "glyphCount")]
        #[doc = "Amount of glyphs that were rendered with this font."]
        pub glyph_count: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions"]
    pub struct FontFace<'a> {
        #[serde(rename = "fontFamily")]
        #[doc = "The font-family."]
        pub font_family: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fontStyle")]
        #[doc = "The font-style."]
        pub font_style: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fontVariant")]
        #[doc = "The font-variant."]
        pub font_variant: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fontWeight")]
        #[doc = "The font-weight."]
        pub font_weight: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fontStretch")]
        #[doc = "The font-stretch."]
        pub font_stretch: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "unicodeRange")]
        #[doc = "The unicode-range."]
        pub unicode_range: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "src")]
        #[doc = "The src."]
        pub src: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "platformFontFamily")]
        #[doc = "The resolved platform font family"]
        pub platform_font_family: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS keyframes rule representation."]
    pub struct CssKeyframesRule<'a> {
        #[serde(rename = "animationName")]
        #[doc = "Animation name."]
        pub animation_name: ::css::Value<'a>,
        #[serde(rename = "keyframes")]
        #[doc = "List of keyframes."]
        pub keyframes: Vec<::css::CssKeyframeRule<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> CSS keyframe rule representation."]
    pub struct CssKeyframeRule<'a> {
        #[serde(rename = "styleSheetId", skip_serializing_if = "Option::is_none")]
        #[doc = "The css style sheet identifier \\(absent for user agent stylesheet and user-specified\nstylesheet rules\\) this rule came from."]
        pub style_sheet_id: Option<::css::StyleSheetId<'a>>,
        #[serde(rename = "origin")]
        #[doc = "Parent stylesheet's origin."]
        pub origin: ::css::StyleSheetOrigin,
        #[serde(rename = "keyText")]
        #[doc = "Associated key text."]
        pub key_text: ::css::Value<'a>,
        #[serde(rename = "style")]
        #[doc = "Associated style declaration."]
        pub style: ::css::CssStyle<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A descriptor of operation to mutate style declaration text."]
    pub struct StyleDeclarationEdit<'a> {
        #[serde(rename = "styleSheetId")]
        #[doc = "The css style sheet identifier."]
        pub style_sheet_id: ::css::StyleSheetId<'a>,
        #[serde(rename = "range")]
        #[doc = "The range of the style text in the enclosing stylesheet."]
        pub range: ::css::SourceRange,
        #[serde(rename = "text")]
        #[doc = "New style text."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# CacheStorage\n\n## Commands\n\n- [`CacheStorage.deleteCache`](struct.DeleteCacheCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a cache.\n- [`CacheStorage.deleteEntry`](struct.DeleteEntryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a cache entry.\n- [`CacheStorage.requestCacheNames`](struct.RequestCacheNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests cache names.\n- [`CacheStorage.requestCachedResponse`](struct.RequestCachedResponseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fetches cache entry.\n- [`CacheStorage.requestEntries`](struct.RequestEntriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests data from cache.\n\n##Types\n\n- [`CacheId`](type.CacheId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of the Cache object.\n- [`DataEntry`](struct.DataEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data entry.\n- [`Cache`](struct.Cache.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Cache identifier.\n- [`Header`](struct.Header.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`CachedResponse`](struct.CachedResponse.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Cached response\n"]
pub mod cache_storage {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache.\n\n# Command `CacheStorage.deleteCache`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::DeleteCacheCommand`](struct.DeleteCacheCommand.html)  \n*Response Struct:* [`cdp::cache_storage::DeleteCacheResponse`](struct.DeleteCacheResponse.html)"]
    pub struct DeleteCacheCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "Id of cache for deletion."]
        pub cache_id: ::cache_storage::CacheId<'a>,
    }
    impl<'a> ::CdpCommand for DeleteCacheCommand<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.deleteCache";
    }
    impl<'a> ::SerializeCdpCommand for DeleteCacheCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.deleteCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteCacheCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.deleteCache" {
                Ok(
                    <DeleteCacheCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache.\n\n# Command `CacheStorage.deleteCache`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::DeleteCacheCommand`](struct.DeleteCacheCommand.html)  \n*Response Struct:* [`cdp::cache_storage::DeleteCacheResponse`](struct.DeleteCacheResponse.html)"]
    pub struct DeleteCacheResponse;
    impl ::serde::Serialize for DeleteCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCacheResponse)
        }
    }
    impl ::CdpCommand for DeleteCacheResponse {
        const COMMAND_NAME: &'static str = "CacheStorage.deleteCache";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteCacheCommand<'a> {
        type Response = DeleteCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteCacheResponse {
        type Command = DeleteCacheCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache entry.\n\n# Command `CacheStorage.deleteEntry`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::DeleteEntryCommand`](struct.DeleteEntryCommand.html)  \n*Response Struct:* [`cdp::cache_storage::DeleteEntryResponse`](struct.DeleteEntryResponse.html)"]
    pub struct DeleteEntryCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "Id of cache where the entry will be deleted."]
        pub cache_id: ::cache_storage::CacheId<'a>,
        #[serde(rename = "request")]
        #[doc = "URL spec of the request."]
        pub request: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for DeleteEntryCommand<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.deleteEntry";
    }
    impl<'a> ::SerializeCdpCommand for DeleteEntryCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.deleteEntry"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteEntryCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.deleteEntry" {
                Ok(
                    <DeleteEntryCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a cache entry.\n\n# Command `CacheStorage.deleteEntry`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::DeleteEntryCommand`](struct.DeleteEntryCommand.html)  \n*Response Struct:* [`cdp::cache_storage::DeleteEntryResponse`](struct.DeleteEntryResponse.html)"]
    pub struct DeleteEntryResponse;
    impl ::serde::Serialize for DeleteEntryResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteEntryResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteEntryResponse)
        }
    }
    impl ::CdpCommand for DeleteEntryResponse {
        const COMMAND_NAME: &'static str = "CacheStorage.deleteEntry";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteEntryCommand<'a> {
        type Response = DeleteEntryResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteEntryResponse {
        type Command = DeleteEntryCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests cache names.\n\n# Command `CacheStorage.requestCacheNames`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestCacheNamesCommand`](struct.RequestCacheNamesCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestCacheNamesResponse`](struct.RequestCacheNamesResponse.html)"]
    pub struct RequestCacheNamesCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RequestCacheNamesCommand<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestCacheNames";
    }
    impl<'a> ::SerializeCdpCommand for RequestCacheNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.requestCacheNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestCacheNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.requestCacheNames" {
                Ok ( < RequestCacheNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests cache names.\n\n# Command `CacheStorage.requestCacheNames`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestCacheNamesCommand`](struct.RequestCacheNamesCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestCacheNamesResponse`](struct.RequestCacheNamesResponse.html)"]
    pub struct RequestCacheNamesResponse<'a> {
        #[serde(rename = "caches")]
        #[doc = "Caches for the security origin."]
        pub caches: Vec<::cache_storage::Cache<'a>>,
    }
    impl<'a> ::CdpCommand for RequestCacheNamesResponse<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestCacheNames";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestCacheNamesCommand<'a> {
        type Response = RequestCacheNamesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestCacheNamesResponse<'b> {
        type Command = RequestCacheNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches cache entry.\n\n# Command `CacheStorage.requestCachedResponse`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestCachedResponseCommand`](struct.RequestCachedResponseCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestCachedResponseResponse`](struct.RequestCachedResponseResponse.html)"]
    pub struct RequestCachedResponseCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "Id of cache that contains the enty."]
        pub cache_id: ::cache_storage::CacheId<'a>,
        #[serde(rename = "requestURL")]
        #[doc = "URL spec of the request."]
        pub request_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RequestCachedResponseCommand<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestCachedResponse";
    }
    impl<'a> ::SerializeCdpCommand for RequestCachedResponseCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.requestCachedResponse"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestCachedResponseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.requestCachedResponse" {
                Ok ( < RequestCachedResponseCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fetches cache entry.\n\n# Command `CacheStorage.requestCachedResponse`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestCachedResponseCommand`](struct.RequestCachedResponseCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestCachedResponseResponse`](struct.RequestCachedResponseResponse.html)"]
    pub struct RequestCachedResponseResponse<'a> {
        #[serde(rename = "response")]
        #[doc = "Response read from the cache."]
        pub response: ::cache_storage::CachedResponse<'a>,
    }
    impl<'a> ::CdpCommand for RequestCachedResponseResponse<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestCachedResponse";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestCachedResponseCommand<'a> {
        type Response = RequestCachedResponseResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestCachedResponseResponse<'b> {
        type Command = RequestCachedResponseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from cache.\n\n# Command `CacheStorage.requestEntries`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestEntriesCommand`](struct.RequestEntriesCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestEntriesResponse`](struct.RequestEntriesResponse.html)"]
    pub struct RequestEntriesCommand<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "ID of cache to get entries from."]
        pub cache_id: ::cache_storage::CacheId<'a>,
        #[serde(rename = "skipCount")]
        #[doc = "Number of records to skip."]
        pub skip_count: i32,
        #[serde(rename = "pageSize")]
        #[doc = "Number of records to fetch."]
        pub page_size: i32,
    }
    impl<'a> ::CdpCommand for RequestEntriesCommand<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestEntries";
    }
    impl<'a> ::SerializeCdpCommand for RequestEntriesCommand<'a> {
        fn command_name(&self) -> &str {
            "CacheStorage.requestEntries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestEntriesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "CacheStorage.requestEntries" {
                Ok(
                    <RequestEntriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from cache.\n\n# Command `CacheStorage.requestEntries`\n\n*Domain Module:* [`cdp::cache_storage`](index.html)  \n*Command Struct:* [`cdp::cache_storage::RequestEntriesCommand`](struct.RequestEntriesCommand.html)  \n*Response Struct:* [`cdp::cache_storage::RequestEntriesResponse`](struct.RequestEntriesResponse.html)"]
    pub struct RequestEntriesResponse<'a> {
        #[serde(rename = "cacheDataEntries")]
        #[doc = "Array of object store data entries."]
        pub cache_data_entries: Vec<::cache_storage::DataEntry<'a>>,
        #[serde(rename = "hasMore")]
        #[doc = "If true, there are more entries to fetch in the given range."]
        pub has_more: bool,
    }
    impl<'a> ::CdpCommand for RequestEntriesResponse<'a> {
        const COMMAND_NAME: &'static str = "CacheStorage.requestEntries";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestEntriesCommand<'a> {
        type Response = RequestEntriesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestEntriesResponse<'b> {
        type Command = RequestEntriesCommand<'a>;
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of the Cache object."]
    pub type CacheId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data entry."]
    pub struct DataEntry<'a> {
        #[serde(rename = "requestURL")]
        #[doc = "Request URL."]
        pub request_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestMethod")]
        #[doc = "Request method."]
        pub request_method: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestHeaders")]
        #[doc = "Request headers"]
        pub request_headers: Vec<::cache_storage::Header<'a>>,
        #[serde(rename = "responseTime")]
        #[doc = "Number of seconds since epoch."]
        pub response_time: f64,
        #[serde(rename = "responseStatus")]
        #[doc = "HTTP response status code."]
        pub response_status: i32,
        #[serde(rename = "responseStatusText")]
        #[doc = "HTTP response status text."]
        pub response_status_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "responseHeaders")]
        #[doc = "Response headers"]
        pub response_headers: Vec<::cache_storage::Header<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Cache identifier."]
    pub struct Cache<'a> {
        #[serde(rename = "cacheId")]
        #[doc = "An opaque unique id of the cache."]
        pub cache_id: ::cache_storage::CacheId<'a>,
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin of the cache."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "cacheName")]
        #[doc = "The name of the cache."]
        pub cache_name: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct Header<'a> {
        #[serde(rename = "name")]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Cached response"]
    pub struct CachedResponse<'a> {
        #[serde(rename = "body")]
        #[doc = "Entry content, base64-encoded."]
        pub body: ::std::borrow::Cow<'a, str>,
    }
}
#[doc = "This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object\nthat has an `id`. This `id` can be used to get additional information on the Node, resolve it into\nthe JavaScript object wrapper, etc. It is important that client receives DOM events only for the\nnodes that are known to the client. Backend keeps track of the nodes that were sent to the client\nand never sends the same node twice. It is client's responsibility to collect information about\nthe nodes that were sent to the client.<p>Note that `iframe` owner elements will return\ncorresponding document elements as their child nodes.</p>\n\n# DOM\n\n## Commands\n\n- [`DOM.collectClassNamesFromSubtree`](struct.CollectClassNamesFromSubtreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Collects class names for the node with given id and all of it's child nodes.\n- [`DOM.copyTo`](struct.CopyToCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a deep copy of the specified node and places it into the target container before the\n  given anchor.\n- [`DOM.describeNode`](struct.DescribeNodeCommand.html)\n\n  Describes node given its id, does not require domain to be enabled. Does not start tracking any\n  objects, can be used for automation.\n- [`DOM.disable`](struct.DisableCommand.html)\n\n  Disables DOM agent for the given page.\n- [`DOM.discardSearchResults`](struct.DiscardSearchResultsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Discards search results from the session with the given id. `getSearchResults` should no longer\n  be called for that search.\n- [`DOM.enable`](struct.EnableCommand.html)\n\n  Enables DOM agent for the given page.\n- [`DOM.focus`](struct.FocusCommand.html)\n\n  Focuses the given element.\n- [`DOM.getAttributes`](struct.GetAttributesCommand.html)\n\n  Returns attributes for the specified node.\n- [`DOM.getBoxModel`](struct.GetBoxModelCommand.html)\n\n  Returns boxes for the given node.\n- [`DOM.getContentQuads`](struct.GetContentQuadsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns quads that describe node position on the page. This method\n  might return multiple quads for inline nodes.\n- [`DOM.getDocument`](struct.GetDocumentCommand.html)\n\n  Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n- [`DOM.getFlattenedDocument`](struct.GetFlattenedDocumentCommand.html)\n\n  Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n- [`DOM.getNodeForLocation`](struct.GetNodeForLocationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns node id at given location.\n- [`DOM.getOuterHTML`](struct.GetOuterHtmlCommand.html)\n\n  Returns node's HTML markup.\n- [`DOM.getRelayoutBoundary`](struct.GetRelayoutBoundaryCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the id of the nearest ancestor that is a relayout boundary.\n- [`DOM.getSearchResults`](struct.GetSearchResultsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns search results from given `fromIndex` to given `toIndex` from the search with the given\n  identifier.\n- [`DOM.hideHighlight`](struct.HideHighlightCommand.html)\n\n  Hides any highlight.\n- [`DOM.highlightNode`](struct.HighlightNodeCommand.html)\n\n  Highlights DOM node.\n- [`DOM.highlightRect`](struct.HighlightRectCommand.html)\n\n  Highlights given rectangle.\n- [`DOM.markUndoableState`](struct.MarkUndoableStateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Marks last undoable state.\n- [`DOM.moveTo`](struct.MoveToCommand.html)\n\n  Moves node into the new container, places it before the given anchor.\n- [`DOM.performSearch`](struct.PerformSearchCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or\n  `cancelSearch` to end this search session.\n- [`DOM.pushNodeByPathToFrontend`](struct.PushNodeByPathToFrontendCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that the node is sent to the caller given its path. // FIXME, use XPath\n- [`DOM.pushNodesByBackendIdsToFrontend`](struct.PushNodesByBackendIdsToFrontendCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that a batch of nodes is sent to the caller given their backend node ids.\n- [`DOM.querySelector`](struct.QuerySelectorCommand.html)\n\n  Executes `querySelector` on a given node.\n- [`DOM.querySelectorAll`](struct.QuerySelectorAllCommand.html)\n\n  Executes `querySelectorAll` on a given node.\n- [`DOM.redo`](struct.RedoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Re-does the last undone action.\n- [`DOM.removeAttribute`](struct.RemoveAttributeCommand.html)\n\n  Removes attribute with given name from an element with given id.\n- [`DOM.removeNode`](struct.RemoveNodeCommand.html)\n\n  Removes node with given id.\n- [`DOM.requestChildNodes`](struct.RequestChildNodesCommand.html)\n\n  Requests that children of the node with given id are returned to the caller in form of\n  `setChildNodes` events where not only immediate children are retrieved, but all children down to\n  the specified depth.\n- [`DOM.requestNode`](struct.RequestNodeCommand.html)\n\n  Requests that the node is sent to the caller given the JavaScript node object reference. All\n  nodes that form the path from the node to the root are also sent to the client as a series of\n  `setChildNodes` notifications.\n- [`DOM.resolveNode`](struct.ResolveNodeCommand.html)\n\n  Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n- [`DOM.setAttributeValue`](struct.SetAttributeValueCommand.html)\n\n  Sets attribute for an element with given id.\n- [`DOM.setAttributesAsText`](struct.SetAttributesAsTextCommand.html)\n\n  Sets attributes on element with given id. This method is useful when user edits some existing\n  attribute value and types in several attribute name/value pairs.\n- [`DOM.setFileInputFiles`](struct.SetFileInputFilesCommand.html)\n\n  Sets files for the given file input element.\n- [`DOM.setInspectedNode`](struct.SetInspectedNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n  $x functions\\).\n- [`DOM.setNodeName`](struct.SetNodeNameCommand.html)\n\n  Sets node name for a node with given id.\n- [`DOM.setNodeValue`](struct.SetNodeValueCommand.html)\n\n  Sets node value for a node with given id.\n- [`DOM.setOuterHTML`](struct.SetOuterHtmlCommand.html)\n\n  Sets node HTML markup, returns new node id.\n- [`DOM.undo`](struct.UndoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Undoes the last performed action.\n- [`DOM.getFrameOwner`](struct.GetFrameOwnerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns iframe node that owns iframe with the given domain.\n\n## Events\n\n- [`DOM.attributeModified`](struct.AttributeModifiedEvent.html)\n\n  Fired when `Element`'s attribute is modified.\n- [`DOM.attributeRemoved`](struct.AttributeRemovedEvent.html)\n\n  Fired when `Element`'s attribute is removed.\n- [`DOM.characterDataModified`](struct.CharacterDataModifiedEvent.html)\n\n  Mirrors `DOMCharacterDataModified` event.\n- [`DOM.childNodeCountUpdated`](struct.ChildNodeCountUpdatedEvent.html)\n\n  Fired when `Container`'s child node count has changed.\n- [`DOM.childNodeInserted`](struct.ChildNodeInsertedEvent.html)\n\n  Mirrors `DOMNodeInserted` event.\n- [`DOM.childNodeRemoved`](struct.ChildNodeRemovedEvent.html)\n\n  Mirrors `DOMNodeRemoved` event.\n- [`DOM.distributedNodesUpdated`](struct.DistributedNodesUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when distrubution is changed.\n- [`DOM.documentUpdated`](struct.DocumentUpdatedEvent.html)\n\n  Fired when `Document` has been totally updated. Node ids are no longer valid.\n- [`DOM.inlineStyleInvalidated`](struct.InlineStyleInvalidatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when `Element`'s inline style is modified via a CSS property modification.\n- [`DOM.pseudoElementAdded`](struct.PseudoElementAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when a pseudo element is added to an element.\n- [`DOM.pseudoElementRemoved`](struct.PseudoElementRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when a pseudo element is removed from an element.\n- [`DOM.setChildNodes`](struct.SetChildNodesEvent.html)\n\n  Fired when backend wants to provide client with the missing DOM structure. This happens upon\n  most of the calls requesting node ids.\n- [`DOM.shadowRootPopped`](struct.ShadowRootPoppedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when shadow root is popped from the element.\n- [`DOM.shadowRootPushed`](struct.ShadowRootPushedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Called when shadow root is pushed into the element.\n\n##Types\n\n- [`NodeId`](type.NodeId.html)\n\n  Unique DOM node identifier.\n- [`BackendNodeId`](type.BackendNodeId.html)\n\n  Unique DOM node identifier used to reference a node that may not have been pushed to the\n  front-end.\n- [`BackendNode`](struct.BackendNode.html)\n\n  Backend node with a friendly name.\n- [`PseudoType`](enum.PseudoType.html)\n\n  Pseudo element type.\n- [`ShadowRootType`](enum.ShadowRootType.html)\n\n  Shadow root type.\n- [`Node`](struct.Node.html)\n\n  DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.\n  DOMNode is a base node mirror type.\n- [`RGBA`](struct.Rgba.html)\n\n  A structure holding an RGBA color.\n- [`Quad`](type.Quad.html)\n\n  An array of quad vertices, x immediately followed by y for each point, points clock-wise.\n- [`BoxModel`](struct.BoxModel.html)\n\n  Box model.\n- [`ShapeOutsideInfo`](struct.ShapeOutsideInfo.html)\n\n  CSS Shape Outside details.\n- [`Rect`](struct.Rect.html)\n\n  Rectangle.\n"]
pub mod dom {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collects class names for the node with given id and all of it's child nodes.\n\n# Command `DOM.collectClassNamesFromSubtree`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::CollectClassNamesFromSubtreeCommand`](struct.CollectClassNamesFromSubtreeCommand.html)  \n*Response Struct:* [`cdp::dom::CollectClassNamesFromSubtreeResponse`](struct.CollectClassNamesFromSubtreeResponse.html)"]
    pub struct CollectClassNamesFromSubtreeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to collect class names."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for CollectClassNamesFromSubtreeCommand {
        const COMMAND_NAME: &'static str = "DOM.collectClassNamesFromSubtree";
    }
    impl ::SerializeCdpCommand for CollectClassNamesFromSubtreeCommand {
        fn command_name(&self) -> &str {
            "DOM.collectClassNamesFromSubtree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CollectClassNamesFromSubtreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.collectClassNamesFromSubtree" {
                Ok ( < CollectClassNamesFromSubtreeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collects class names for the node with given id and all of it's child nodes.\n\n# Command `DOM.collectClassNamesFromSubtree`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::CollectClassNamesFromSubtreeCommand`](struct.CollectClassNamesFromSubtreeCommand.html)  \n*Response Struct:* [`cdp::dom::CollectClassNamesFromSubtreeResponse`](struct.CollectClassNamesFromSubtreeResponse.html)"]
    pub struct CollectClassNamesFromSubtreeResponse<'a> {
        #[serde(rename = "classNames")]
        #[doc = "Class name list."]
        pub class_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CollectClassNamesFromSubtreeResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.collectClassNamesFromSubtree";
    }
    impl<'b> ::HasCdpResponse<'b> for CollectClassNamesFromSubtreeCommand {
        type Response = CollectClassNamesFromSubtreeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CollectClassNamesFromSubtreeResponse<'b> {
        type Command = CollectClassNamesFromSubtreeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a deep copy of the specified node and places it into the target container before the\ngiven anchor.\n\n# Command `DOM.copyTo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::CopyToCommand`](struct.CopyToCommand.html)  \n*Response Struct:* [`cdp::dom::CopyToResponse`](struct.CopyToResponse.html)"]
    pub struct CopyToCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to copy."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "targetNodeId")]
        #[doc = "Id of the element to drop the copy into."]
        pub target_node_id: ::dom::NodeId,
        #[serde(rename = "insertBeforeNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Drop the copy before this node \\(if absent, the copy becomes the last child of\n`targetNodeId`\\)."]
        pub insert_before_node_id: Option<::dom::NodeId>,
    }
    impl ::CdpCommand for CopyToCommand {
        const COMMAND_NAME: &'static str = "DOM.copyTo";
    }
    impl ::SerializeCdpCommand for CopyToCommand {
        fn command_name(&self) -> &str {
            "DOM.copyTo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CopyToCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.copyTo" {
                Ok(
                    <CopyToCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a deep copy of the specified node and places it into the target container before the\ngiven anchor.\n\n# Command `DOM.copyTo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::CopyToCommand`](struct.CopyToCommand.html)  \n*Response Struct:* [`cdp::dom::CopyToResponse`](struct.CopyToResponse.html)"]
    pub struct CopyToResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node clone."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for CopyToResponse {
        const COMMAND_NAME: &'static str = "DOM.copyTo";
    }
    impl<'b> ::HasCdpResponse<'b> for CopyToCommand {
        type Response = CopyToResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CopyToResponse {
        type Command = CopyToCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Describes node given its id, does not require domain to be enabled. Does not start tracking any\nobjects, can be used for automation.\n\n# Command `DOM.describeNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DescribeNodeCommand`](struct.DescribeNodeCommand.html)  \n*Response Struct:* [`cdp::dom::DescribeNodeResponse`](struct.DescribeNodeResponse.html)"]
    pub struct DescribeNodeCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n\\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl<'a> ::CdpCommand for DescribeNodeCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.describeNode";
    }
    impl<'a> ::SerializeCdpCommand for DescribeNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.describeNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DescribeNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.describeNode" {
                Ok(
                    <DescribeNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Describes node given its id, does not require domain to be enabled. Does not start tracking any\nobjects, can be used for automation.\n\n# Command `DOM.describeNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DescribeNodeCommand`](struct.DescribeNodeCommand.html)  \n*Response Struct:* [`cdp::dom::DescribeNodeResponse`](struct.DescribeNodeResponse.html)"]
    pub struct DescribeNodeResponse<'a> {
        #[serde(rename = "node")]
        #[doc = "Node description."]
        pub node: ::dom::Node<'a>,
    }
    impl<'a> ::CdpCommand for DescribeNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.describeNode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DescribeNodeCommand<'a> {
        type Response = DescribeNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for DescribeNodeResponse<'b> {
        type Command = DescribeNodeCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables DOM agent for the given page.\n\n# Command `DOM.disable`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "DOM.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "DOM.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables DOM agent for the given page.\n\n# Command `DOM.disable`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "DOM.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Discards search results from the session with the given id. `getSearchResults` should no longer\nbe called for that search.\n\n# Command `DOM.discardSearchResults`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DiscardSearchResultsCommand`](struct.DiscardSearchResultsCommand.html)  \n*Response Struct:* [`cdp::dom::DiscardSearchResultsResponse`](struct.DiscardSearchResultsResponse.html)"]
    pub struct DiscardSearchResultsCommand<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for DiscardSearchResultsCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.discardSearchResults";
    }
    impl<'a> ::SerializeCdpCommand for DiscardSearchResultsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.discardSearchResults"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DiscardSearchResultsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.discardSearchResults" {
                Ok ( < DiscardSearchResultsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Discards search results from the session with the given id. `getSearchResults` should no longer\nbe called for that search.\n\n# Command `DOM.discardSearchResults`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::DiscardSearchResultsCommand`](struct.DiscardSearchResultsCommand.html)  \n*Response Struct:* [`cdp::dom::DiscardSearchResultsResponse`](struct.DiscardSearchResultsResponse.html)"]
    pub struct DiscardSearchResultsResponse;
    impl ::serde::Serialize for DiscardSearchResultsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardSearchResultsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardSearchResultsResponse)
        }
    }
    impl ::CdpCommand for DiscardSearchResultsResponse {
        const COMMAND_NAME: &'static str = "DOM.discardSearchResults";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DiscardSearchResultsCommand<'a> {
        type Response = DiscardSearchResultsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DiscardSearchResultsResponse {
        type Command = DiscardSearchResultsCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables DOM agent for the given page.\n\n# Command `DOM.enable`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "DOM.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "DOM.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables DOM agent for the given page.\n\n# Command `DOM.enable`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "DOM.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Focuses the given element.\n\n# Command `DOM.focus`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::FocusCommand`](struct.FocusCommand.html)  \n*Response Struct:* [`cdp::dom::FocusResponse`](struct.FocusResponse.html)"]
    pub struct FocusCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for FocusCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.focus";
    }
    impl<'a> ::SerializeCdpCommand for FocusCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.focus"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for FocusCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.focus" {
                Ok(
                    <FocusCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Focuses the given element.\n\n# Command `DOM.focus`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::FocusCommand`](struct.FocusCommand.html)  \n*Response Struct:* [`cdp::dom::FocusResponse`](struct.FocusResponse.html)"]
    pub struct FocusResponse;
    impl ::serde::Serialize for FocusResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FocusResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| FocusResponse)
        }
    }
    impl ::CdpCommand for FocusResponse {
        const COMMAND_NAME: &'static str = "DOM.focus";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for FocusCommand<'a> {
        type Response = FocusResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for FocusResponse {
        type Command = FocusCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns attributes for the specified node.\n\n# Command `DOM.getAttributes`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetAttributesCommand`](struct.GetAttributesCommand.html)  \n*Response Struct:* [`cdp::dom::GetAttributesResponse`](struct.GetAttributesResponse.html)"]
    pub struct GetAttributesCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to retrieve attibutes for."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetAttributesCommand {
        const COMMAND_NAME: &'static str = "DOM.getAttributes";
    }
    impl ::SerializeCdpCommand for GetAttributesCommand {
        fn command_name(&self) -> &str {
            "DOM.getAttributes"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetAttributesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getAttributes" {
                Ok(
                    <GetAttributesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns attributes for the specified node.\n\n# Command `DOM.getAttributes`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetAttributesCommand`](struct.GetAttributesCommand.html)  \n*Response Struct:* [`cdp::dom::GetAttributesResponse`](struct.GetAttributesResponse.html)"]
    pub struct GetAttributesResponse<'a> {
        #[serde(rename = "attributes")]
        #[doc = "An interleaved array of node attribute names and values."]
        pub attributes: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetAttributesResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.getAttributes";
    }
    impl<'b> ::HasCdpResponse<'b> for GetAttributesCommand {
        type Response = GetAttributesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetAttributesResponse<'b> {
        type Command = GetAttributesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns boxes for the given node.\n\n# Command `DOM.getBoxModel`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetBoxModelCommand`](struct.GetBoxModelCommand.html)  \n*Response Struct:* [`cdp::dom::GetBoxModelResponse`](struct.GetBoxModelResponse.html)"]
    pub struct GetBoxModelCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for GetBoxModelCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.getBoxModel";
    }
    impl<'a> ::SerializeCdpCommand for GetBoxModelCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getBoxModel"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetBoxModelCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getBoxModel" {
                Ok(
                    <GetBoxModelCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns boxes for the given node.\n\n# Command `DOM.getBoxModel`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetBoxModelCommand`](struct.GetBoxModelCommand.html)  \n*Response Struct:* [`cdp::dom::GetBoxModelResponse`](struct.GetBoxModelResponse.html)"]
    pub struct GetBoxModelResponse {
        #[serde(rename = "model")]
        #[doc = "Box model for the node."]
        pub model: ::dom::BoxModel,
    }
    impl ::CdpCommand for GetBoxModelResponse {
        const COMMAND_NAME: &'static str = "DOM.getBoxModel";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetBoxModelCommand<'a> {
        type Response = GetBoxModelResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetBoxModelResponse {
        type Command = GetBoxModelCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns quads that describe node position on the page. This method\nmight return multiple quads for inline nodes.\n\n# Command `DOM.getContentQuads`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetContentQuadsCommand`](struct.GetContentQuadsCommand.html)  \n*Response Struct:* [`cdp::dom::GetContentQuadsResponse`](struct.GetContentQuadsResponse.html)"]
    pub struct GetContentQuadsCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for GetContentQuadsCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.getContentQuads";
    }
    impl<'a> ::SerializeCdpCommand for GetContentQuadsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getContentQuads"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetContentQuadsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getContentQuads" {
                Ok(
                    <GetContentQuadsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns quads that describe node position on the page. This method\nmight return multiple quads for inline nodes.\n\n# Command `DOM.getContentQuads`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetContentQuadsCommand`](struct.GetContentQuadsCommand.html)  \n*Response Struct:* [`cdp::dom::GetContentQuadsResponse`](struct.GetContentQuadsResponse.html)"]
    pub struct GetContentQuadsResponse {
        #[serde(rename = "quads")]
        #[doc = "Quads that describe node layout relative to viewport."]
        pub quads: Vec<::dom::Quad>,
    }
    impl ::CdpCommand for GetContentQuadsResponse {
        const COMMAND_NAME: &'static str = "DOM.getContentQuads";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetContentQuadsCommand<'a> {
        type Response = GetContentQuadsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetContentQuadsResponse {
        type Command = GetContentQuadsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getDocument`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetDocumentCommand`](struct.GetDocumentCommand.html)  \n*Response Struct:* [`cdp::dom::GetDocumentResponse`](struct.GetDocumentResponse.html)"]
    pub struct GetDocumentCommand {
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n\\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::CdpCommand for GetDocumentCommand {
        const COMMAND_NAME: &'static str = "DOM.getDocument";
    }
    impl ::SerializeCdpCommand for GetDocumentCommand {
        fn command_name(&self) -> &str {
            "DOM.getDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetDocumentCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getDocument" {
                Ok(
                    <GetDocumentCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getDocument`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetDocumentCommand`](struct.GetDocumentCommand.html)  \n*Response Struct:* [`cdp::dom::GetDocumentResponse`](struct.GetDocumentResponse.html)"]
    pub struct GetDocumentResponse<'a> {
        #[serde(rename = "root")]
        #[doc = "Resulting node."]
        pub root: ::dom::Node<'a>,
    }
    impl<'a> ::CdpCommand for GetDocumentResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.getDocument";
    }
    impl<'b> ::HasCdpResponse<'b> for GetDocumentCommand {
        type Response = GetDocumentResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetDocumentResponse<'b> {
        type Command = GetDocumentCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getFlattenedDocument`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetFlattenedDocumentCommand`](struct.GetFlattenedDocumentCommand.html)  \n*Response Struct:* [`cdp::dom::GetFlattenedDocumentResponse`](struct.GetFlattenedDocumentResponse.html)"]
    pub struct GetFlattenedDocumentCommand {
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n\\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::CdpCommand for GetFlattenedDocumentCommand {
        const COMMAND_NAME: &'static str = "DOM.getFlattenedDocument";
    }
    impl ::SerializeCdpCommand for GetFlattenedDocumentCommand {
        fn command_name(&self) -> &str {
            "DOM.getFlattenedDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetFlattenedDocumentCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getFlattenedDocument" {
                Ok ( < GetFlattenedDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns the root DOM node \\(and optionally the subtree\\) to the caller.\n\n# Command `DOM.getFlattenedDocument`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetFlattenedDocumentCommand`](struct.GetFlattenedDocumentCommand.html)  \n*Response Struct:* [`cdp::dom::GetFlattenedDocumentResponse`](struct.GetFlattenedDocumentResponse.html)"]
    pub struct GetFlattenedDocumentResponse<'a> {
        #[serde(rename = "nodes")]
        #[doc = "Resulting node."]
        pub nodes: Vec<::dom::Node<'a>>,
    }
    impl<'a> ::CdpCommand for GetFlattenedDocumentResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.getFlattenedDocument";
    }
    impl<'b> ::HasCdpResponse<'b> for GetFlattenedDocumentCommand {
        type Response = GetFlattenedDocumentResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetFlattenedDocumentResponse<'b> {
        type Command = GetFlattenedDocumentCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns node id at given location.\n\n# Command `DOM.getNodeForLocation`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetNodeForLocationCommand`](struct.GetNodeForLocationCommand.html)  \n*Response Struct:* [`cdp::dom::GetNodeForLocationResponse`](struct.GetNodeForLocationResponse.html)"]
    pub struct GetNodeForLocationCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate."]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate."]
        pub y: i32,
        #[serde(rename = "includeUserAgentShadowDOM", skip_serializing_if = "Option::is_none")]
        #[doc = "False to skip to the nearest non-UA shadow root ancestor \\(default: false\\)."]
        pub include_user_agent_shadow_dom: Option<bool>,
    }
    impl ::CdpCommand for GetNodeForLocationCommand {
        const COMMAND_NAME: &'static str = "DOM.getNodeForLocation";
    }
    impl ::SerializeCdpCommand for GetNodeForLocationCommand {
        fn command_name(&self) -> &str {
            "DOM.getNodeForLocation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetNodeForLocationCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getNodeForLocation" {
                Ok ( < GetNodeForLocationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns node id at given location.\n\n# Command `DOM.getNodeForLocation`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetNodeForLocationCommand`](struct.GetNodeForLocationCommand.html)  \n*Response Struct:* [`cdp::dom::GetNodeForLocationResponse`](struct.GetNodeForLocationResponse.html)"]
    pub struct GetNodeForLocationResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node at given coordinates."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetNodeForLocationResponse {
        const COMMAND_NAME: &'static str = "DOM.getNodeForLocation";
    }
    impl<'b> ::HasCdpResponse<'b> for GetNodeForLocationCommand {
        type Response = GetNodeForLocationResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetNodeForLocationResponse {
        type Command = GetNodeForLocationCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns node's HTML markup.\n\n# Command `DOM.getOuterHTML`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetOuterHtmlCommand`](struct.GetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::dom::GetOuterHtmlResponse`](struct.GetOuterHtmlResponse.html)"]
    pub struct GetOuterHtmlCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for GetOuterHtmlCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.getOuterHTML";
    }
    impl<'a> ::SerializeCdpCommand for GetOuterHtmlCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getOuterHTML"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetOuterHtmlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getOuterHTML" {
                Ok(
                    <GetOuterHtmlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns node's HTML markup.\n\n# Command `DOM.getOuterHTML`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetOuterHtmlCommand`](struct.GetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::dom::GetOuterHtmlResponse`](struct.GetOuterHtmlResponse.html)"]
    pub struct GetOuterHtmlResponse<'a> {
        #[serde(rename = "outerHTML")]
        #[doc = "Outer HTML markup."]
        pub outer_html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetOuterHtmlResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.getOuterHTML";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetOuterHtmlCommand<'a> {
        type Response = GetOuterHtmlResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetOuterHtmlResponse<'b> {
        type Command = GetOuterHtmlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the id of the nearest ancestor that is a relayout boundary.\n\n# Command `DOM.getRelayoutBoundary`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetRelayoutBoundaryCommand`](struct.GetRelayoutBoundaryCommand.html)  \n*Response Struct:* [`cdp::dom::GetRelayoutBoundaryResponse`](struct.GetRelayoutBoundaryResponse.html)"]
    pub struct GetRelayoutBoundaryCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetRelayoutBoundaryCommand {
        const COMMAND_NAME: &'static str = "DOM.getRelayoutBoundary";
    }
    impl ::SerializeCdpCommand for GetRelayoutBoundaryCommand {
        fn command_name(&self) -> &str {
            "DOM.getRelayoutBoundary"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetRelayoutBoundaryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getRelayoutBoundary" {
                Ok ( < GetRelayoutBoundaryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the id of the nearest ancestor that is a relayout boundary.\n\n# Command `DOM.getRelayoutBoundary`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetRelayoutBoundaryCommand`](struct.GetRelayoutBoundaryCommand.html)  \n*Response Struct:* [`cdp::dom::GetRelayoutBoundaryResponse`](struct.GetRelayoutBoundaryResponse.html)"]
    pub struct GetRelayoutBoundaryResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Relayout boundary node id for the given node."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetRelayoutBoundaryResponse {
        const COMMAND_NAME: &'static str = "DOM.getRelayoutBoundary";
    }
    impl<'b> ::HasCdpResponse<'b> for GetRelayoutBoundaryCommand {
        type Response = GetRelayoutBoundaryResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetRelayoutBoundaryResponse {
        type Command = GetRelayoutBoundaryCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns search results from given `fromIndex` to given `toIndex` from the search with the given\nidentifier.\n\n# Command `DOM.getSearchResults`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetSearchResultsCommand`](struct.GetSearchResultsCommand.html)  \n*Response Struct:* [`cdp::dom::GetSearchResultsResponse`](struct.GetSearchResultsResponse.html)"]
    pub struct GetSearchResultsCommand<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "fromIndex")]
        #[doc = "Start index of the search result to be returned."]
        pub from_index: i32,
        #[serde(rename = "toIndex")]
        #[doc = "End index of the search result to be returned."]
        pub to_index: i32,
    }
    impl<'a> ::CdpCommand for GetSearchResultsCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.getSearchResults";
    }
    impl<'a> ::SerializeCdpCommand for GetSearchResultsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getSearchResults"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetSearchResultsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getSearchResults" {
                Ok ( < GetSearchResultsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns search results from given `fromIndex` to given `toIndex` from the search with the given\nidentifier.\n\n# Command `DOM.getSearchResults`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetSearchResultsCommand`](struct.GetSearchResultsCommand.html)  \n*Response Struct:* [`cdp::dom::GetSearchResultsResponse`](struct.GetSearchResultsResponse.html)"]
    pub struct GetSearchResultsResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "Ids of the search result nodes."]
        pub node_ids: Vec<::dom::NodeId>,
    }
    impl ::CdpCommand for GetSearchResultsResponse {
        const COMMAND_NAME: &'static str = "DOM.getSearchResults";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetSearchResultsCommand<'a> {
        type Response = GetSearchResultsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetSearchResultsResponse {
        type Command = GetSearchResultsCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Hides any highlight.\n\n# Command `DOM.hideHighlight`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::dom::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightCommand;
    impl ::serde::Serialize for HideHighlightCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightCommand)
        }
    }
    impl ::CdpCommand for HideHighlightCommand {
        const COMMAND_NAME: &'static str = "DOM.hideHighlight";
    }
    impl ::SerializeCdpCommand for HideHighlightCommand {
        fn command_name(&self) -> &str {
            "DOM.hideHighlight"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HideHighlightCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.hideHighlight" {
                Ok(
                    <HideHighlightCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Hides any highlight.\n\n# Command `DOM.hideHighlight`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::dom::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightResponse;
    impl ::serde::Serialize for HideHighlightResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightResponse)
        }
    }
    impl ::CdpCommand for HideHighlightResponse {
        const COMMAND_NAME: &'static str = "DOM.hideHighlight";
    }
    impl<'b> ::HasCdpResponse<'b> for HideHighlightCommand {
        type Response = HideHighlightResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HideHighlightResponse {
        type Command = HideHighlightCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights DOM node.\n\n# Command `DOM.highlightNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::dom::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeCommand;
    impl ::serde::Serialize for HighlightNodeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeCommand)
        }
    }
    impl ::CdpCommand for HighlightNodeCommand {
        const COMMAND_NAME: &'static str = "DOM.highlightNode";
    }
    impl ::SerializeCdpCommand for HighlightNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.highlightNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HighlightNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.highlightNode" {
                Ok(
                    <HighlightNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights DOM node.\n\n# Command `DOM.highlightNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::dom::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeResponse;
    impl ::serde::Serialize for HighlightNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeResponse)
        }
    }
    impl ::CdpCommand for HighlightNodeResponse {
        const COMMAND_NAME: &'static str = "DOM.highlightNode";
    }
    impl<'b> ::HasCdpResponse<'b> for HighlightNodeCommand {
        type Response = HighlightNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightNodeResponse {
        type Command = HighlightNodeCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights given rectangle.\n\n# Command `DOM.highlightRect`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::dom::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectCommand;
    impl ::serde::Serialize for HighlightRectCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectCommand)
        }
    }
    impl ::CdpCommand for HighlightRectCommand {
        const COMMAND_NAME: &'static str = "DOM.highlightRect";
    }
    impl ::SerializeCdpCommand for HighlightRectCommand {
        fn command_name(&self) -> &str {
            "DOM.highlightRect"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HighlightRectCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.highlightRect" {
                Ok(
                    <HighlightRectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Highlights given rectangle.\n\n# Command `DOM.highlightRect`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::dom::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectResponse;
    impl ::serde::Serialize for HighlightRectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectResponse)
        }
    }
    impl ::CdpCommand for HighlightRectResponse {
        const COMMAND_NAME: &'static str = "DOM.highlightRect";
    }
    impl<'b> ::HasCdpResponse<'b> for HighlightRectCommand {
        type Response = HighlightRectResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightRectResponse {
        type Command = HighlightRectCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Marks last undoable state.\n\n# Command `DOM.markUndoableState`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::MarkUndoableStateCommand`](struct.MarkUndoableStateCommand.html)  \n*Response Struct:* [`cdp::dom::MarkUndoableStateResponse`](struct.MarkUndoableStateResponse.html)"]
    pub struct MarkUndoableStateCommand;
    impl ::serde::Serialize for MarkUndoableStateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MarkUndoableStateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MarkUndoableStateCommand)
        }
    }
    impl ::CdpCommand for MarkUndoableStateCommand {
        const COMMAND_NAME: &'static str = "DOM.markUndoableState";
    }
    impl ::SerializeCdpCommand for MarkUndoableStateCommand {
        fn command_name(&self) -> &str {
            "DOM.markUndoableState"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for MarkUndoableStateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.markUndoableState" {
                Ok ( < MarkUndoableStateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Marks last undoable state.\n\n# Command `DOM.markUndoableState`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::MarkUndoableStateCommand`](struct.MarkUndoableStateCommand.html)  \n*Response Struct:* [`cdp::dom::MarkUndoableStateResponse`](struct.MarkUndoableStateResponse.html)"]
    pub struct MarkUndoableStateResponse;
    impl ::serde::Serialize for MarkUndoableStateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for MarkUndoableStateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| MarkUndoableStateResponse)
        }
    }
    impl ::CdpCommand for MarkUndoableStateResponse {
        const COMMAND_NAME: &'static str = "DOM.markUndoableState";
    }
    impl<'b> ::HasCdpResponse<'b> for MarkUndoableStateCommand {
        type Response = MarkUndoableStateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for MarkUndoableStateResponse {
        type Command = MarkUndoableStateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Moves node into the new container, places it before the given anchor.\n\n# Command `DOM.moveTo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::MoveToCommand`](struct.MoveToCommand.html)  \n*Response Struct:* [`cdp::dom::MoveToResponse`](struct.MoveToResponse.html)"]
    pub struct MoveToCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to move."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "targetNodeId")]
        #[doc = "Id of the element to drop the moved node into."]
        pub target_node_id: ::dom::NodeId,
        #[serde(rename = "insertBeforeNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Drop node before this one \\(if absent, the moved node becomes the last child of\n`targetNodeId`\\)."]
        pub insert_before_node_id: Option<::dom::NodeId>,
    }
    impl ::CdpCommand for MoveToCommand {
        const COMMAND_NAME: &'static str = "DOM.moveTo";
    }
    impl ::SerializeCdpCommand for MoveToCommand {
        fn command_name(&self) -> &str {
            "DOM.moveTo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for MoveToCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.moveTo" {
                Ok(
                    <MoveToCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Moves node into the new container, places it before the given anchor.\n\n# Command `DOM.moveTo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::MoveToCommand`](struct.MoveToCommand.html)  \n*Response Struct:* [`cdp::dom::MoveToResponse`](struct.MoveToResponse.html)"]
    pub struct MoveToResponse {
        #[serde(rename = "nodeId")]
        #[doc = "New id of the moved node."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for MoveToResponse {
        const COMMAND_NAME: &'static str = "DOM.moveTo";
    }
    impl<'b> ::HasCdpResponse<'b> for MoveToCommand {
        type Response = MoveToResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for MoveToResponse {
        type Command = MoveToCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or\n`cancelSearch` to end this search session.\n\n# Command `DOM.performSearch`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PerformSearchCommand`](struct.PerformSearchCommand.html)  \n*Response Struct:* [`cdp::dom::PerformSearchResponse`](struct.PerformSearchResponse.html)"]
    pub struct PerformSearchCommand<'a> {
        #[serde(rename = "query")]
        #[doc = "Plain text or query selector or XPath search query."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "includeUserAgentShadowDOM", skip_serializing_if = "Option::is_none")]
        #[doc = "True to search in user agent shadow DOM."]
        pub include_user_agent_shadow_dom: Option<bool>,
    }
    impl<'a> ::CdpCommand for PerformSearchCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.performSearch";
    }
    impl<'a> ::SerializeCdpCommand for PerformSearchCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.performSearch"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for PerformSearchCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.performSearch" {
                Ok(
                    <PerformSearchCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or\n`cancelSearch` to end this search session.\n\n# Command `DOM.performSearch`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PerformSearchCommand`](struct.PerformSearchCommand.html)  \n*Response Struct:* [`cdp::dom::PerformSearchResponse`](struct.PerformSearchResponse.html)"]
    pub struct PerformSearchResponse<'a> {
        #[serde(rename = "searchId")]
        #[doc = "Unique search session identifier."]
        pub search_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "resultCount")]
        #[doc = "Number of search results."]
        pub result_count: i32,
    }
    impl<'a> ::CdpCommand for PerformSearchResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.performSearch";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for PerformSearchCommand<'a> {
        type Response = PerformSearchResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for PerformSearchResponse<'b> {
        type Command = PerformSearchCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that the node is sent to the caller given its path. // FIXME, use XPath\n\n# Command `DOM.pushNodeByPathToFrontend`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PushNodeByPathToFrontendCommand`](struct.PushNodeByPathToFrontendCommand.html)  \n*Response Struct:* [`cdp::dom::PushNodeByPathToFrontendResponse`](struct.PushNodeByPathToFrontendResponse.html)"]
    pub struct PushNodeByPathToFrontendCommand<'a> {
        #[serde(rename = "path")]
        #[doc = "Path to node in the proprietary format."]
        pub path: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for PushNodeByPathToFrontendCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.pushNodeByPathToFrontend";
    }
    impl<'a> ::SerializeCdpCommand for PushNodeByPathToFrontendCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.pushNodeByPathToFrontend"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for PushNodeByPathToFrontendCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pushNodeByPathToFrontend" {
                Ok ( < PushNodeByPathToFrontendCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that the node is sent to the caller given its path. // FIXME, use XPath\n\n# Command `DOM.pushNodeByPathToFrontend`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PushNodeByPathToFrontendCommand`](struct.PushNodeByPathToFrontendCommand.html)  \n*Response Struct:* [`cdp::dom::PushNodeByPathToFrontendResponse`](struct.PushNodeByPathToFrontendResponse.html)"]
    pub struct PushNodeByPathToFrontendResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node for given path."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for PushNodeByPathToFrontendResponse {
        const COMMAND_NAME: &'static str = "DOM.pushNodeByPathToFrontend";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for PushNodeByPathToFrontendCommand<'a> {
        type Response = PushNodeByPathToFrontendResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for PushNodeByPathToFrontendResponse {
        type Command = PushNodeByPathToFrontendCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that a batch of nodes is sent to the caller given their backend node ids.\n\n# Command `DOM.pushNodesByBackendIdsToFrontend`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PushNodesByBackendIdsToFrontendCommand`](struct.PushNodesByBackendIdsToFrontendCommand.html)  \n*Response Struct:* [`cdp::dom::PushNodesByBackendIdsToFrontendResponse`](struct.PushNodesByBackendIdsToFrontendResponse.html)"]
    pub struct PushNodesByBackendIdsToFrontendCommand {
        #[serde(rename = "backendNodeIds")]
        #[doc = "The array of backend node ids."]
        pub backend_node_ids: Vec<::dom::BackendNodeId>,
    }
    impl ::CdpCommand for PushNodesByBackendIdsToFrontendCommand {
        const COMMAND_NAME: &'static str = "DOM.pushNodesByBackendIdsToFrontend";
    }
    impl ::SerializeCdpCommand for PushNodesByBackendIdsToFrontendCommand {
        fn command_name(&self) -> &str {
            "DOM.pushNodesByBackendIdsToFrontend"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for PushNodesByBackendIdsToFrontendCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pushNodesByBackendIdsToFrontend" {
                Ok ( < PushNodesByBackendIdsToFrontendCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that a batch of nodes is sent to the caller given their backend node ids.\n\n# Command `DOM.pushNodesByBackendIdsToFrontend`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::PushNodesByBackendIdsToFrontendCommand`](struct.PushNodesByBackendIdsToFrontendCommand.html)  \n*Response Struct:* [`cdp::dom::PushNodesByBackendIdsToFrontendResponse`](struct.PushNodesByBackendIdsToFrontendResponse.html)"]
    pub struct PushNodesByBackendIdsToFrontendResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "The array of ids of pushed nodes that correspond to the backend ids specified in\nbackendNodeIds."]
        pub node_ids: Vec<::dom::NodeId>,
    }
    impl ::CdpCommand for PushNodesByBackendIdsToFrontendResponse {
        const COMMAND_NAME: &'static str = "DOM.pushNodesByBackendIdsToFrontend";
    }
    impl<'b> ::HasCdpResponse<'b> for PushNodesByBackendIdsToFrontendCommand {
        type Response = PushNodesByBackendIdsToFrontendResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for PushNodesByBackendIdsToFrontendResponse {
        type Command = PushNodesByBackendIdsToFrontendCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes `querySelector` on a given node.\n\n# Command `DOM.querySelector`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::QuerySelectorCommand`](struct.QuerySelectorCommand.html)  \n*Response Struct:* [`cdp::dom::QuerySelectorResponse`](struct.QuerySelectorResponse.html)"]
    pub struct QuerySelectorCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to query upon."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "selector")]
        #[doc = "Selector string."]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for QuerySelectorCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.querySelector";
    }
    impl<'a> ::SerializeCdpCommand for QuerySelectorCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.querySelector"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for QuerySelectorCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.querySelector" {
                Ok(
                    <QuerySelectorCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes `querySelector` on a given node.\n\n# Command `DOM.querySelector`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::QuerySelectorCommand`](struct.QuerySelectorCommand.html)  \n*Response Struct:* [`cdp::dom::QuerySelectorResponse`](struct.QuerySelectorResponse.html)"]
    pub struct QuerySelectorResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Query selector result."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for QuerySelectorResponse {
        const COMMAND_NAME: &'static str = "DOM.querySelector";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for QuerySelectorCommand<'a> {
        type Response = QuerySelectorResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for QuerySelectorResponse {
        type Command = QuerySelectorCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes `querySelectorAll` on a given node.\n\n# Command `DOM.querySelectorAll`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::QuerySelectorAllCommand`](struct.QuerySelectorAllCommand.html)  \n*Response Struct:* [`cdp::dom::QuerySelectorAllResponse`](struct.QuerySelectorAllResponse.html)"]
    pub struct QuerySelectorAllCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to query upon."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "selector")]
        #[doc = "Selector string."]
        pub selector: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for QuerySelectorAllCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.querySelectorAll";
    }
    impl<'a> ::SerializeCdpCommand for QuerySelectorAllCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.querySelectorAll"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for QuerySelectorAllCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.querySelectorAll" {
                Ok ( < QuerySelectorAllCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Executes `querySelectorAll` on a given node.\n\n# Command `DOM.querySelectorAll`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::QuerySelectorAllCommand`](struct.QuerySelectorAllCommand.html)  \n*Response Struct:* [`cdp::dom::QuerySelectorAllResponse`](struct.QuerySelectorAllResponse.html)"]
    pub struct QuerySelectorAllResponse {
        #[serde(rename = "nodeIds")]
        #[doc = "Query selector result."]
        pub node_ids: Vec<::dom::NodeId>,
    }
    impl ::CdpCommand for QuerySelectorAllResponse {
        const COMMAND_NAME: &'static str = "DOM.querySelectorAll";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for QuerySelectorAllCommand<'a> {
        type Response = QuerySelectorAllResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for QuerySelectorAllResponse {
        type Command = QuerySelectorAllCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Re-does the last undone action.\n\n# Command `DOM.redo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RedoCommand`](struct.RedoCommand.html)  \n*Response Struct:* [`cdp::dom::RedoResponse`](struct.RedoResponse.html)"]
    pub struct RedoCommand;
    impl ::serde::Serialize for RedoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RedoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| RedoCommand)
        }
    }
    impl ::CdpCommand for RedoCommand {
        const COMMAND_NAME: &'static str = "DOM.redo";
    }
    impl ::SerializeCdpCommand for RedoCommand {
        fn command_name(&self) -> &str {
            "DOM.redo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RedoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.redo" {
                Ok(
                    <RedoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Re-does the last undone action.\n\n# Command `DOM.redo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RedoCommand`](struct.RedoCommand.html)  \n*Response Struct:* [`cdp::dom::RedoResponse`](struct.RedoResponse.html)"]
    pub struct RedoResponse;
    impl ::serde::Serialize for RedoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RedoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| RedoResponse)
        }
    }
    impl ::CdpCommand for RedoResponse {
        const COMMAND_NAME: &'static str = "DOM.redo";
    }
    impl<'b> ::HasCdpResponse<'b> for RedoCommand {
        type Response = RedoResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RedoResponse {
        type Command = RedoCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes attribute with given name from an element with given id.\n\n# Command `DOM.removeAttribute`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RemoveAttributeCommand`](struct.RemoveAttributeCommand.html)  \n*Response Struct:* [`cdp::dom::RemoveAttributeResponse`](struct.RemoveAttributeResponse.html)"]
    pub struct RemoveAttributeCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to remove attribute from."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Name of the attribute to remove."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RemoveAttributeCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.removeAttribute";
    }
    impl<'a> ::SerializeCdpCommand for RemoveAttributeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.removeAttribute"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveAttributeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.removeAttribute" {
                Ok(
                    <RemoveAttributeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes attribute with given name from an element with given id.\n\n# Command `DOM.removeAttribute`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RemoveAttributeCommand`](struct.RemoveAttributeCommand.html)  \n*Response Struct:* [`cdp::dom::RemoveAttributeResponse`](struct.RemoveAttributeResponse.html)"]
    pub struct RemoveAttributeResponse;
    impl ::serde::Serialize for RemoveAttributeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveAttributeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveAttributeResponse)
        }
    }
    impl ::CdpCommand for RemoveAttributeResponse {
        const COMMAND_NAME: &'static str = "DOM.removeAttribute";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveAttributeCommand<'a> {
        type Response = RemoveAttributeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveAttributeResponse {
        type Command = RemoveAttributeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes node with given id.\n\n# Command `DOM.removeNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RemoveNodeCommand`](struct.RemoveNodeCommand.html)  \n*Response Struct:* [`cdp::dom::RemoveNodeResponse`](struct.RemoveNodeResponse.html)"]
    pub struct RemoveNodeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to remove."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for RemoveNodeCommand {
        const COMMAND_NAME: &'static str = "DOM.removeNode";
    }
    impl ::SerializeCdpCommand for RemoveNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.removeNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RemoveNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.removeNode" {
                Ok(
                    <RemoveNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes node with given id.\n\n# Command `DOM.removeNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RemoveNodeCommand`](struct.RemoveNodeCommand.html)  \n*Response Struct:* [`cdp::dom::RemoveNodeResponse`](struct.RemoveNodeResponse.html)"]
    pub struct RemoveNodeResponse;
    impl ::serde::Serialize for RemoveNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveNodeResponse)
        }
    }
    impl ::CdpCommand for RemoveNodeResponse {
        const COMMAND_NAME: &'static str = "DOM.removeNode";
    }
    impl<'b> ::HasCdpResponse<'b> for RemoveNodeCommand {
        type Response = RemoveNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveNodeResponse {
        type Command = RemoveNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that children of the node with given id are returned to the caller in form of\n`setChildNodes` events where not only immediate children are retrieved, but all children down to\nthe specified depth.\n\n# Command `DOM.requestChildNodes`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RequestChildNodesCommand`](struct.RequestChildNodesCommand.html)  \n*Response Struct:* [`cdp::dom::RequestChildNodesResponse`](struct.RequestChildNodesResponse.html)"]
    pub struct RequestChildNodesCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get children for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not iframes and shadow roots should be traversed when returning the sub-tree\n\\(default is false\\)."]
        pub pierce: Option<bool>,
    }
    impl ::CdpCommand for RequestChildNodesCommand {
        const COMMAND_NAME: &'static str = "DOM.requestChildNodes";
    }
    impl ::SerializeCdpCommand for RequestChildNodesCommand {
        fn command_name(&self) -> &str {
            "DOM.requestChildNodes"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RequestChildNodesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.requestChildNodes" {
                Ok ( < RequestChildNodesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Requests that children of the node with given id are returned to the caller in form of\n`setChildNodes` events where not only immediate children are retrieved, but all children down to\nthe specified depth.\n\n# Command `DOM.requestChildNodes`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RequestChildNodesCommand`](struct.RequestChildNodesCommand.html)  \n*Response Struct:* [`cdp::dom::RequestChildNodesResponse`](struct.RequestChildNodesResponse.html)"]
    pub struct RequestChildNodesResponse;
    impl ::serde::Serialize for RequestChildNodesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestChildNodesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestChildNodesResponse)
        }
    }
    impl ::CdpCommand for RequestChildNodesResponse {
        const COMMAND_NAME: &'static str = "DOM.requestChildNodes";
    }
    impl<'b> ::HasCdpResponse<'b> for RequestChildNodesCommand {
        type Response = RequestChildNodesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RequestChildNodesResponse {
        type Command = RequestChildNodesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All\nnodes that form the path from the node to the root are also sent to the client as a series of\n`setChildNodes` notifications.\n\n# Command `DOM.requestNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RequestNodeCommand`](struct.RequestNodeCommand.html)  \n*Response Struct:* [`cdp::dom::RequestNodeResponse`](struct.RequestNodeResponse.html)"]
    pub struct RequestNodeCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "JavaScript object id to convert into node."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::CdpCommand for RequestNodeCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.requestNode";
    }
    impl<'a> ::SerializeCdpCommand for RequestNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.requestNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.requestNode" {
                Ok(
                    <RequestNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Requests that the node is sent to the caller given the JavaScript node object reference. All\nnodes that form the path from the node to the root are also sent to the client as a series of\n`setChildNodes` notifications.\n\n# Command `DOM.requestNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::RequestNodeCommand`](struct.RequestNodeCommand.html)  \n*Response Struct:* [`cdp::dom::RequestNodeResponse`](struct.RequestNodeResponse.html)"]
    pub struct RequestNodeResponse {
        #[serde(rename = "nodeId")]
        #[doc = "Node id for given object."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for RequestNodeResponse {
        const COMMAND_NAME: &'static str = "DOM.requestNode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestNodeCommand<'a> {
        type Response = RequestNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RequestNodeResponse {
        type Command = RequestNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n\n# Command `DOM.resolveNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::ResolveNodeCommand`](struct.ResolveNodeCommand.html)  \n*Response Struct:* [`cdp::dom::ResolveNodeResponse`](struct.ResolveNodeResponse.html)"]
    pub struct ResolveNodeCommand<'a> {
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Id of the node to resolve."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Backend identifier of the node to resolve."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for ResolveNodeCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.resolveNode";
    }
    impl<'a> ::SerializeCdpCommand for ResolveNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.resolveNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ResolveNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.resolveNode" {
                Ok(
                    <ResolveNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Resolves the JavaScript node object for a given NodeId or BackendNodeId.\n\n# Command `DOM.resolveNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::ResolveNodeCommand`](struct.ResolveNodeCommand.html)  \n*Response Struct:* [`cdp::dom::ResolveNodeResponse`](struct.ResolveNodeResponse.html)"]
    pub struct ResolveNodeResponse<'a> {
        #[serde(rename = "object")]
        #[doc = "JavaScript object wrapper for given node."]
        pub object: ::runtime::RemoteObject<'a>,
    }
    impl<'a> ::CdpCommand for ResolveNodeResponse<'a> {
        const COMMAND_NAME: &'static str = "DOM.resolveNode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ResolveNodeCommand<'a> {
        type Response = ResolveNodeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ResolveNodeResponse<'b> {
        type Command = ResolveNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets attribute for an element with given id.\n\n# Command `DOM.setAttributeValue`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetAttributeValueCommand`](struct.SetAttributeValueCommand.html)  \n*Response Struct:* [`cdp::dom::SetAttributeValueResponse`](struct.SetAttributeValueResponse.html)"]
    pub struct SetAttributeValueCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to set attribute for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Attribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetAttributeValueCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setAttributeValue";
    }
    impl<'a> ::SerializeCdpCommand for SetAttributeValueCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setAttributeValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetAttributeValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setAttributeValue" {
                Ok ( < SetAttributeValueCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets attribute for an element with given id.\n\n# Command `DOM.setAttributeValue`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetAttributeValueCommand`](struct.SetAttributeValueCommand.html)  \n*Response Struct:* [`cdp::dom::SetAttributeValueResponse`](struct.SetAttributeValueResponse.html)"]
    pub struct SetAttributeValueResponse;
    impl ::serde::Serialize for SetAttributeValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAttributeValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAttributeValueResponse)
        }
    }
    impl ::CdpCommand for SetAttributeValueResponse {
        const COMMAND_NAME: &'static str = "DOM.setAttributeValue";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetAttributeValueCommand<'a> {
        type Response = SetAttributeValueResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAttributeValueResponse {
        type Command = SetAttributeValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing\nattribute value and types in several attribute name/value pairs.\n\n# Command `DOM.setAttributesAsText`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetAttributesAsTextCommand`](struct.SetAttributesAsTextCommand.html)  \n*Response Struct:* [`cdp::dom::SetAttributesAsTextResponse`](struct.SetAttributesAsTextResponse.html)"]
    pub struct SetAttributesAsTextCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the element to set attributes for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "text")]
        #[doc = "Text with a number of attributes. Will parse this text using HTML parser."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "Attribute name to replace with new attributes derived from text in case text parsed\nsuccessfully."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetAttributesAsTextCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setAttributesAsText";
    }
    impl<'a> ::SerializeCdpCommand for SetAttributesAsTextCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setAttributesAsText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetAttributesAsTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setAttributesAsText" {
                Ok ( < SetAttributesAsTextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets attributes on element with given id. This method is useful when user edits some existing\nattribute value and types in several attribute name/value pairs.\n\n# Command `DOM.setAttributesAsText`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetAttributesAsTextCommand`](struct.SetAttributesAsTextCommand.html)  \n*Response Struct:* [`cdp::dom::SetAttributesAsTextResponse`](struct.SetAttributesAsTextResponse.html)"]
    pub struct SetAttributesAsTextResponse;
    impl ::serde::Serialize for SetAttributesAsTextResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAttributesAsTextResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAttributesAsTextResponse)
        }
    }
    impl ::CdpCommand for SetAttributesAsTextResponse {
        const COMMAND_NAME: &'static str = "DOM.setAttributesAsText";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetAttributesAsTextCommand<'a> {
        type Response = SetAttributesAsTextResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAttributesAsTextResponse {
        type Command = SetAttributesAsTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets files for the given file input element.\n\n# Command `DOM.setFileInputFiles`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetFileInputFilesCommand`](struct.SetFileInputFilesCommand.html)  \n*Response Struct:* [`cdp::dom::SetFileInputFilesResponse`](struct.SetFileInputFilesResponse.html)"]
    pub struct SetFileInputFilesCommand<'a> {
        #[serde(rename = "files")]
        #[doc = "Array of file paths to set."]
        pub files: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node wrapper."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for SetFileInputFilesCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setFileInputFiles";
    }
    impl<'a> ::SerializeCdpCommand for SetFileInputFilesCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setFileInputFiles"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetFileInputFilesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setFileInputFiles" {
                Ok ( < SetFileInputFilesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets files for the given file input element.\n\n# Command `DOM.setFileInputFiles`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetFileInputFilesCommand`](struct.SetFileInputFilesCommand.html)  \n*Response Struct:* [`cdp::dom::SetFileInputFilesResponse`](struct.SetFileInputFilesResponse.html)"]
    pub struct SetFileInputFilesResponse;
    impl ::serde::Serialize for SetFileInputFilesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetFileInputFilesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetFileInputFilesResponse)
        }
    }
    impl ::CdpCommand for SetFileInputFilesResponse {
        const COMMAND_NAME: &'static str = "DOM.setFileInputFiles";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetFileInputFilesCommand<'a> {
        type Response = SetFileInputFilesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetFileInputFilesResponse {
        type Command = SetFileInputFilesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n$x functions\\).\n\n# Command `DOM.setInspectedNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetInspectedNodeCommand`](struct.SetInspectedNodeCommand.html)  \n*Response Struct:* [`cdp::dom::SetInspectedNodeResponse`](struct.SetInspectedNodeResponse.html)"]
    pub struct SetInspectedNodeCommand {
        #[serde(rename = "nodeId")]
        #[doc = "DOM node id to be accessible by means of $x command line API."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for SetInspectedNodeCommand {
        const COMMAND_NAME: &'static str = "DOM.setInspectedNode";
    }
    impl ::SerializeCdpCommand for SetInspectedNodeCommand {
        fn command_name(&self) -> &str {
            "DOM.setInspectedNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetInspectedNodeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setInspectedNode" {
                Ok ( < SetInspectedNodeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n$x functions\\).\n\n# Command `DOM.setInspectedNode`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetInspectedNodeCommand`](struct.SetInspectedNodeCommand.html)  \n*Response Struct:* [`cdp::dom::SetInspectedNodeResponse`](struct.SetInspectedNodeResponse.html)"]
    pub struct SetInspectedNodeResponse;
    impl ::serde::Serialize for SetInspectedNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInspectedNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInspectedNodeResponse)
        }
    }
    impl ::CdpCommand for SetInspectedNodeResponse {
        const COMMAND_NAME: &'static str = "DOM.setInspectedNode";
    }
    impl<'b> ::HasCdpResponse<'b> for SetInspectedNodeCommand {
        type Response = SetInspectedNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetInspectedNodeResponse {
        type Command = SetInspectedNodeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node name for a node with given id.\n\n# Command `DOM.setNodeName`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetNodeNameCommand`](struct.SetNodeNameCommand.html)  \n*Response Struct:* [`cdp::dom::SetNodeNameResponse`](struct.SetNodeNameResponse.html)"]
    pub struct SetNodeNameCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set name for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "New node's name."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetNodeNameCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setNodeName";
    }
    impl<'a> ::SerializeCdpCommand for SetNodeNameCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setNodeName"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetNodeNameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setNodeName" {
                Ok(
                    <SetNodeNameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node name for a node with given id.\n\n# Command `DOM.setNodeName`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetNodeNameCommand`](struct.SetNodeNameCommand.html)  \n*Response Struct:* [`cdp::dom::SetNodeNameResponse`](struct.SetNodeNameResponse.html)"]
    pub struct SetNodeNameResponse {
        #[serde(rename = "nodeId")]
        #[doc = "New node's id."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for SetNodeNameResponse {
        const COMMAND_NAME: &'static str = "DOM.setNodeName";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetNodeNameCommand<'a> {
        type Response = SetNodeNameResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetNodeNameResponse {
        type Command = SetNodeNameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node value for a node with given id.\n\n# Command `DOM.setNodeValue`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetNodeValueCommand`](struct.SetNodeValueCommand.html)  \n*Response Struct:* [`cdp::dom::SetNodeValueResponse`](struct.SetNodeValueResponse.html)"]
    pub struct SetNodeValueCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set value for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "value")]
        #[doc = "New node's value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetNodeValueCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setNodeValue";
    }
    impl<'a> ::SerializeCdpCommand for SetNodeValueCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setNodeValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetNodeValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setNodeValue" {
                Ok(
                    <SetNodeValueCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets node value for a node with given id.\n\n# Command `DOM.setNodeValue`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetNodeValueCommand`](struct.SetNodeValueCommand.html)  \n*Response Struct:* [`cdp::dom::SetNodeValueResponse`](struct.SetNodeValueResponse.html)"]
    pub struct SetNodeValueResponse;
    impl ::serde::Serialize for SetNodeValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetNodeValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetNodeValueResponse)
        }
    }
    impl ::CdpCommand for SetNodeValueResponse {
        const COMMAND_NAME: &'static str = "DOM.setNodeValue";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetNodeValueCommand<'a> {
        type Response = SetNodeValueResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetNodeValueResponse {
        type Command = SetNodeValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets node HTML markup, returns new node id.\n\n# Command `DOM.setOuterHTML`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetOuterHtmlCommand`](struct.SetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::dom::SetOuterHtmlResponse`](struct.SetOuterHtmlResponse.html)"]
    pub struct SetOuterHtmlCommand<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to set markup for."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "outerHTML")]
        #[doc = "Outer HTML markup to set."]
        pub outer_html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetOuterHtmlCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.setOuterHTML";
    }
    impl<'a> ::SerializeCdpCommand for SetOuterHtmlCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.setOuterHTML"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetOuterHtmlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setOuterHTML" {
                Ok(
                    <SetOuterHtmlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets node HTML markup, returns new node id.\n\n# Command `DOM.setOuterHTML`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::SetOuterHtmlCommand`](struct.SetOuterHtmlCommand.html)  \n*Response Struct:* [`cdp::dom::SetOuterHtmlResponse`](struct.SetOuterHtmlResponse.html)"]
    pub struct SetOuterHtmlResponse;
    impl ::serde::Serialize for SetOuterHtmlResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetOuterHtmlResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetOuterHtmlResponse)
        }
    }
    impl ::CdpCommand for SetOuterHtmlResponse {
        const COMMAND_NAME: &'static str = "DOM.setOuterHTML";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetOuterHtmlCommand<'a> {
        type Response = SetOuterHtmlResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetOuterHtmlResponse {
        type Command = SetOuterHtmlCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Undoes the last performed action.\n\n# Command `DOM.undo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::UndoCommand`](struct.UndoCommand.html)  \n*Response Struct:* [`cdp::dom::UndoResponse`](struct.UndoResponse.html)"]
    pub struct UndoCommand;
    impl ::serde::Serialize for UndoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UndoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| UndoCommand)
        }
    }
    impl ::CdpCommand for UndoCommand {
        const COMMAND_NAME: &'static str = "DOM.undo";
    }
    impl ::SerializeCdpCommand for UndoCommand {
        fn command_name(&self) -> &str {
            "DOM.undo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for UndoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.undo" {
                Ok(
                    <UndoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Undoes the last performed action.\n\n# Command `DOM.undo`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::UndoCommand`](struct.UndoCommand.html)  \n*Response Struct:* [`cdp::dom::UndoResponse`](struct.UndoResponse.html)"]
    pub struct UndoResponse;
    impl ::serde::Serialize for UndoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UndoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| UndoResponse)
        }
    }
    impl ::CdpCommand for UndoResponse {
        const COMMAND_NAME: &'static str = "DOM.undo";
    }
    impl<'b> ::HasCdpResponse<'b> for UndoCommand {
        type Response = UndoResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UndoResponse {
        type Command = UndoCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns iframe node that owns iframe with the given domain.\n\n# Command `DOM.getFrameOwner`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetFrameOwnerCommand`](struct.GetFrameOwnerCommand.html)  \n*Response Struct:* [`cdp::dom::GetFrameOwnerResponse`](struct.GetFrameOwnerResponse.html)"]
    pub struct GetFrameOwnerCommand<'a> {
        #[serde(rename = "frameId")]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpCommand for GetFrameOwnerCommand<'a> {
        const COMMAND_NAME: &'static str = "DOM.getFrameOwner";
    }
    impl<'a> ::SerializeCdpCommand for GetFrameOwnerCommand<'a> {
        fn command_name(&self) -> &str {
            "DOM.getFrameOwner"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetFrameOwnerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.getFrameOwner" {
                Ok(
                    <GetFrameOwnerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns iframe node that owns iframe with the given domain.\n\n# Command `DOM.getFrameOwner`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Command Struct:* [`cdp::dom::GetFrameOwnerCommand`](struct.GetFrameOwnerCommand.html)  \n*Response Struct:* [`cdp::dom::GetFrameOwnerResponse`](struct.GetFrameOwnerResponse.html)"]
    pub struct GetFrameOwnerResponse {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetFrameOwnerResponse {
        const COMMAND_NAME: &'static str = "DOM.getFrameOwner";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetFrameOwnerCommand<'a> {
        type Response = GetFrameOwnerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetFrameOwnerResponse {
        type Command = GetFrameOwnerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when `Element`'s attribute is modified.\n\n# Event `DOM.attributeModified`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::AttributeModifiedEvent`](struct.AttributeModifiedEvent.html)"]
    pub struct AttributeModifiedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "Attribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AttributeModifiedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.attributeModified";
    }
    impl<'a> ::SerializeCdpEvent for AttributeModifiedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.attributeModified"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AttributeModifiedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.attributeModified" {
                Ok(
                    <AttributeModifiedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when `Element`'s attribute is removed.\n\n# Event `DOM.attributeRemoved`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::AttributeRemovedEvent`](struct.AttributeRemovedEvent.html)"]
    pub struct AttributeRemovedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "name")]
        #[doc = "A ttribute name."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AttributeRemovedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.attributeRemoved";
    }
    impl<'a> ::SerializeCdpEvent for AttributeRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.attributeRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AttributeRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.attributeRemoved" {
                Ok(
                    <AttributeRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors `DOMCharacterDataModified` event.\n\n# Event `DOM.characterDataModified`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::CharacterDataModifiedEvent`](struct.CharacterDataModifiedEvent.html)"]
    pub struct CharacterDataModifiedEvent<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "characterData")]
        #[doc = "New text value."]
        pub character_data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for CharacterDataModifiedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.characterDataModified";
    }
    impl<'a> ::SerializeCdpEvent for CharacterDataModifiedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.characterDataModified"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for CharacterDataModifiedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.characterDataModified" {
                Ok ( < CharacterDataModifiedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when `Container`'s child node count has changed.\n\n# Event `DOM.childNodeCountUpdated`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::ChildNodeCountUpdatedEvent`](struct.ChildNodeCountUpdatedEvent.html)"]
    pub struct ChildNodeCountUpdatedEvent {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has changed."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "childNodeCount")]
        #[doc = "New node count."]
        pub child_node_count: i32,
    }
    impl ::CdpEvent for ChildNodeCountUpdatedEvent {
        const EVENT_NAME: &'static str = "DOM.childNodeCountUpdated";
    }
    impl ::SerializeCdpEvent for ChildNodeCountUpdatedEvent {
        fn event_name(&self) -> &str {
            "DOM.childNodeCountUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ChildNodeCountUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeCountUpdated" {
                Ok ( < ChildNodeCountUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors `DOMNodeInserted` event.\n\n# Event `DOM.childNodeInserted`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::ChildNodeInsertedEvent`](struct.ChildNodeInsertedEvent.html)"]
    pub struct ChildNodeInsertedEvent<'a> {
        #[serde(rename = "parentNodeId")]
        #[doc = "Id of the node that has changed."]
        pub parent_node_id: ::dom::NodeId,
        #[serde(rename = "previousNodeId")]
        #[doc = "If of the previous siblint."]
        pub previous_node_id: ::dom::NodeId,
        #[serde(rename = "node")]
        #[doc = "Inserted node data."]
        pub node: ::dom::Node<'a>,
    }
    impl<'a> ::CdpEvent for ChildNodeInsertedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.childNodeInserted";
    }
    impl<'a> ::SerializeCdpEvent for ChildNodeInsertedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.childNodeInserted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ChildNodeInsertedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeInserted" {
                Ok(
                    <ChildNodeInsertedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirrors `DOMNodeRemoved` event.\n\n# Event `DOM.childNodeRemoved`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::ChildNodeRemovedEvent`](struct.ChildNodeRemovedEvent.html)"]
    pub struct ChildNodeRemovedEvent {
        #[serde(rename = "parentNodeId")]
        #[doc = "Parent id."]
        pub parent_node_id: ::dom::NodeId,
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node that has been removed."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpEvent for ChildNodeRemovedEvent {
        const EVENT_NAME: &'static str = "DOM.childNodeRemoved";
    }
    impl ::SerializeCdpEvent for ChildNodeRemovedEvent {
        fn event_name(&self) -> &str {
            "DOM.childNodeRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ChildNodeRemovedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.childNodeRemoved" {
                Ok(
                    <ChildNodeRemovedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when distrubution is changed.\n\n# Event `DOM.distributedNodesUpdated`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::DistributedNodesUpdatedEvent`](struct.DistributedNodesUpdatedEvent.html)"]
    pub struct DistributedNodesUpdatedEvent<'a> {
        #[serde(rename = "insertionPointId")]
        #[doc = "Insertion point where distrubuted nodes were updated."]
        pub insertion_point_id: ::dom::NodeId,
        #[serde(rename = "distributedNodes")]
        #[doc = "Distributed nodes for given insertion point."]
        pub distributed_nodes: Vec<::dom::BackendNode<'a>>,
    }
    impl<'a> ::CdpEvent for DistributedNodesUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.distributedNodesUpdated";
    }
    impl<'a> ::SerializeCdpEvent for DistributedNodesUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.distributedNodesUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DistributedNodesUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.distributedNodesUpdated" {
                Ok ( < DistributedNodesUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when `Document` has been totally updated. Node ids are no longer valid.\n\n# Event `DOM.documentUpdated`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::DocumentUpdatedEvent`](struct.DocumentUpdatedEvent.html)"]
    pub struct DocumentUpdatedEvent;
    impl ::serde::Serialize for DocumentUpdatedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DocumentUpdatedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DocumentUpdatedEvent)
        }
    }
    impl ::CdpEvent for DocumentUpdatedEvent {
        const EVENT_NAME: &'static str = "DOM.documentUpdated";
    }
    impl ::SerializeCdpEvent for DocumentUpdatedEvent {
        fn event_name(&self) -> &str {
            "DOM.documentUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for DocumentUpdatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.documentUpdated" {
                Ok(
                    <DocumentUpdatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when `Element`'s inline style is modified via a CSS property modification.\n\n# Event `DOM.inlineStyleInvalidated`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::InlineStyleInvalidatedEvent`](struct.InlineStyleInvalidatedEvent.html)"]
    pub struct InlineStyleInvalidatedEvent {
        #[serde(rename = "nodeIds")]
        #[doc = "Ids of the nodes for which the inline styles have been invalidated."]
        pub node_ids: Vec<::dom::NodeId>,
    }
    impl ::CdpEvent for InlineStyleInvalidatedEvent {
        const EVENT_NAME: &'static str = "DOM.inlineStyleInvalidated";
    }
    impl ::SerializeCdpEvent for InlineStyleInvalidatedEvent {
        fn event_name(&self) -> &str {
            "DOM.inlineStyleInvalidated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for InlineStyleInvalidatedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.inlineStyleInvalidated" {
                Ok ( < InlineStyleInvalidatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when a pseudo element is added to an element.\n\n# Event `DOM.pseudoElementAdded`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::PseudoElementAddedEvent`](struct.PseudoElementAddedEvent.html)"]
    pub struct PseudoElementAddedEvent<'a> {
        #[serde(rename = "parentId")]
        #[doc = "Pseudo element's parent element id."]
        pub parent_id: ::dom::NodeId,
        #[serde(rename = "pseudoElement")]
        #[doc = "The added pseudo element."]
        pub pseudo_element: ::dom::Node<'a>,
    }
    impl<'a> ::CdpEvent for PseudoElementAddedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.pseudoElementAdded";
    }
    impl<'a> ::SerializeCdpEvent for PseudoElementAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.pseudoElementAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for PseudoElementAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pseudoElementAdded" {
                Ok ( < PseudoElementAddedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when a pseudo element is removed from an element.\n\n# Event `DOM.pseudoElementRemoved`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::PseudoElementRemovedEvent`](struct.PseudoElementRemovedEvent.html)"]
    pub struct PseudoElementRemovedEvent {
        #[serde(rename = "parentId")]
        #[doc = "Pseudo element's parent element id."]
        pub parent_id: ::dom::NodeId,
        #[serde(rename = "pseudoElementId")]
        #[doc = "The removed pseudo element id."]
        pub pseudo_element_id: ::dom::NodeId,
    }
    impl ::CdpEvent for PseudoElementRemovedEvent {
        const EVENT_NAME: &'static str = "DOM.pseudoElementRemoved";
    }
    impl ::SerializeCdpEvent for PseudoElementRemovedEvent {
        fn event_name(&self) -> &str {
            "DOM.pseudoElementRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for PseudoElementRemovedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.pseudoElementRemoved" {
                Ok ( < PseudoElementRemovedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when backend wants to provide client with the missing DOM structure. This happens upon\nmost of the calls requesting node ids.\n\n# Event `DOM.setChildNodes`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::SetChildNodesEvent`](struct.SetChildNodesEvent.html)"]
    pub struct SetChildNodesEvent<'a> {
        #[serde(rename = "parentId")]
        #[doc = "Parent node id to populate with children."]
        pub parent_id: ::dom::NodeId,
        #[serde(rename = "nodes")]
        #[doc = "Child nodes array."]
        pub nodes: Vec<::dom::Node<'a>>,
    }
    impl<'a> ::CdpEvent for SetChildNodesEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.setChildNodes";
    }
    impl<'a> ::SerializeCdpEvent for SetChildNodesEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.setChildNodes"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for SetChildNodesEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.setChildNodes" {
                Ok(
                    <SetChildNodesEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when shadow root is popped from the element.\n\n# Event `DOM.shadowRootPopped`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::ShadowRootPoppedEvent`](struct.ShadowRootPoppedEvent.html)"]
    pub struct ShadowRootPoppedEvent {
        #[serde(rename = "hostId")]
        #[doc = "Host element id."]
        pub host_id: ::dom::NodeId,
        #[serde(rename = "rootId")]
        #[doc = "Shadow root id."]
        pub root_id: ::dom::NodeId,
    }
    impl ::CdpEvent for ShadowRootPoppedEvent {
        const EVENT_NAME: &'static str = "DOM.shadowRootPopped";
    }
    impl ::SerializeCdpEvent for ShadowRootPoppedEvent {
        fn event_name(&self) -> &str {
            "DOM.shadowRootPopped"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ShadowRootPoppedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.shadowRootPopped" {
                Ok(
                    <ShadowRootPoppedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Called when shadow root is pushed into the element.\n\n# Event `DOM.shadowRootPushed`\n\n*Domain Module:* [`cdp::dom`](index.html)  \n*Event Struct:* [`cdp::dom::ShadowRootPushedEvent`](struct.ShadowRootPushedEvent.html)"]
    pub struct ShadowRootPushedEvent<'a> {
        #[serde(rename = "hostId")]
        #[doc = "Host element id."]
        pub host_id: ::dom::NodeId,
        #[serde(rename = "root")]
        #[doc = "Shadow root."]
        pub root: ::dom::Node<'a>,
    }
    impl<'a> ::CdpEvent for ShadowRootPushedEvent<'a> {
        const EVENT_NAME: &'static str = "DOM.shadowRootPushed";
    }
    impl<'a> ::SerializeCdpEvent for ShadowRootPushedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOM.shadowRootPushed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ShadowRootPushedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOM.shadowRootPushed" {
                Ok(
                    <ShadowRootPushedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique DOM node identifier."]
    pub type NodeId = i32;
    #[doc = "Unique DOM node identifier used to reference a node that may not have been pushed to the\nfront-end."]
    pub type BackendNodeId = i32;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Backend node with a friendly name."]
    pub struct BackendNode<'a> {
        #[serde(rename = "nodeType")]
        #[doc = "`Node`'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "`Node`'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "backendNodeId")]
        pub backend_node_id: ::dom::BackendNodeId,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Pseudo element type."]
    pub enum PseudoType {
        #[serde(rename = "first-line")]
        #[doc = "Represented as `\"first-line\"`."]
        FirstLine,
        #[serde(rename = "first-letter")]
        #[doc = "Represented as `\"first-letter\"`."]
        FirstLetter,
        #[serde(rename = "before")]
        #[doc = "Represented as `\"before\"`."]
        Before,
        #[serde(rename = "after")]
        #[doc = "Represented as `\"after\"`."]
        After,
        #[serde(rename = "backdrop")]
        #[doc = "Represented as `\"backdrop\"`."]
        Backdrop,
        #[serde(rename = "selection")]
        #[doc = "Represented as `\"selection\"`."]
        Selection,
        #[serde(rename = "first-line-inherited")]
        #[doc = "Represented as `\"first-line-inherited\"`."]
        FirstLineInherited,
        #[serde(rename = "scrollbar")]
        #[doc = "Represented as `\"scrollbar\"`."]
        Scrollbar,
        #[serde(rename = "scrollbar-thumb")]
        #[doc = "Represented as `\"scrollbar-thumb\"`."]
        ScrollbarThumb,
        #[serde(rename = "scrollbar-button")]
        #[doc = "Represented as `\"scrollbar-button\"`."]
        ScrollbarButton,
        #[serde(rename = "scrollbar-track")]
        #[doc = "Represented as `\"scrollbar-track\"`."]
        ScrollbarTrack,
        #[serde(rename = "scrollbar-track-piece")]
        #[doc = "Represented as `\"scrollbar-track-piece\"`."]
        ScrollbarTrackPiece,
        #[serde(rename = "scrollbar-corner")]
        #[doc = "Represented as `\"scrollbar-corner\"`."]
        ScrollbarCorner,
        #[serde(rename = "resizer")]
        #[doc = "Represented as `\"resizer\"`."]
        Resizer,
        #[serde(rename = "input-list-button")]
        #[doc = "Represented as `\"input-list-button\"`."]
        InputListButton,
    }
    impl PseudoType {
        pub const ENUM_VALUES: &'static [PseudoType] = &[
            PseudoType::FirstLine,
            PseudoType::FirstLetter,
            PseudoType::Before,
            PseudoType::After,
            PseudoType::Backdrop,
            PseudoType::Selection,
            PseudoType::FirstLineInherited,
            PseudoType::Scrollbar,
            PseudoType::ScrollbarThumb,
            PseudoType::ScrollbarButton,
            PseudoType::ScrollbarTrack,
            PseudoType::ScrollbarTrackPiece,
            PseudoType::ScrollbarCorner,
            PseudoType::Resizer,
            PseudoType::InputListButton,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "first-line",
            "first-letter",
            "before",
            "after",
            "backdrop",
            "selection",
            "first-line-inherited",
            "scrollbar",
            "scrollbar-thumb",
            "scrollbar-button",
            "scrollbar-track",
            "scrollbar-track-piece",
            "scrollbar-corner",
            "resizer",
            "input-list-button",
        ];
    }
    impl ::std::str::FromStr for PseudoType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "first-line" => Ok(PseudoType::FirstLine),
                "first-letter" => Ok(PseudoType::FirstLetter),
                "before" => Ok(PseudoType::Before),
                "after" => Ok(PseudoType::After),
                "backdrop" => Ok(PseudoType::Backdrop),
                "selection" => Ok(PseudoType::Selection),
                "first-line-inherited" => Ok(PseudoType::FirstLineInherited),
                "scrollbar" => Ok(PseudoType::Scrollbar),
                "scrollbar-thumb" => Ok(PseudoType::ScrollbarThumb),
                "scrollbar-button" => Ok(PseudoType::ScrollbarButton),
                "scrollbar-track" => Ok(PseudoType::ScrollbarTrack),
                "scrollbar-track-piece" => Ok(PseudoType::ScrollbarTrackPiece),
                "scrollbar-corner" => Ok(PseudoType::ScrollbarCorner),
                "resizer" => Ok(PseudoType::Resizer),
                "input-list-button" => Ok(PseudoType::InputListButton),
                _ => Err(::ParseEnumError {
                    expected: PseudoType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PseudoType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PseudoType::FirstLine => "first-line",
                    PseudoType::FirstLetter => "first-letter",
                    PseudoType::Before => "before",
                    PseudoType::After => "after",
                    PseudoType::Backdrop => "backdrop",
                    PseudoType::Selection => "selection",
                    PseudoType::FirstLineInherited => "first-line-inherited",
                    PseudoType::Scrollbar => "scrollbar",
                    PseudoType::ScrollbarThumb => "scrollbar-thumb",
                    PseudoType::ScrollbarButton => "scrollbar-button",
                    PseudoType::ScrollbarTrack => "scrollbar-track",
                    PseudoType::ScrollbarTrackPiece => "scrollbar-track-piece",
                    PseudoType::ScrollbarCorner => "scrollbar-corner",
                    PseudoType::Resizer => "resizer",
                    PseudoType::InputListButton => "input-list-button",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Shadow root type."]
    pub enum ShadowRootType {
        #[serde(rename = "user-agent")]
        #[doc = "Represented as `\"user-agent\"`."]
        UserAgent,
        #[serde(rename = "open")]
        #[doc = "Represented as `\"open\"`."]
        Open,
        #[serde(rename = "closed")]
        #[doc = "Represented as `\"closed\"`."]
        Closed,
    }
    impl ShadowRootType {
        pub const ENUM_VALUES: &'static [ShadowRootType] = &[
            ShadowRootType::UserAgent,
            ShadowRootType::Open,
            ShadowRootType::Closed,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["user-agent", "open", "closed"];
    }
    impl ::std::str::FromStr for ShadowRootType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "user-agent" => Ok(ShadowRootType::UserAgent),
                "open" => Ok(ShadowRootType::Open),
                "closed" => Ok(ShadowRootType::Closed),
                _ => Err(::ParseEnumError {
                    expected: ShadowRootType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ShadowRootType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ShadowRootType::UserAgent => "user-agent",
                    ShadowRootType::Open => "open",
                    ShadowRootType::Closed => "closed",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.\nDOMNode is a base node mirror type."]
    pub struct Node<'a> {
        #[serde(rename = "nodeId")]
        #[doc = "Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend\nwill only push node with given `id` once. It is aware of all requested nodes and will only\nfire DOM events for nodes known to the client."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "parentId", skip_serializing_if = "Option::is_none")]
        #[doc = "The id of the parent node if any."]
        pub parent_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId")]
        #[doc = "The BackendNodeId for this node."]
        pub backend_node_id: ::dom::BackendNodeId,
        #[serde(rename = "nodeType")]
        #[doc = "`Node`'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "`Node`'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "localName")]
        #[doc = "`Node`'s localName."]
        pub local_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "nodeValue")]
        #[doc = "`Node`'s nodeValue."]
        pub node_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "childNodeCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Child count for `Container` nodes."]
        pub child_node_count: Option<i32>,
        #[serde(rename = "children", skip_serializing_if = "Option::is_none")]
        #[doc = "Child nodes of this node when requested with children."]
        pub children: Option<Vec<Box<::dom::Node<'a>>>>,
        #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
        #[doc = "Attributes of the `Element` node in the form of flat array `\\[name1, value1, name2, value2\\]`."]
        pub attributes: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "documentURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
        pub document_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "baseURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
        pub base_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "publicId", skip_serializing_if = "Option::is_none")]
        #[doc = "`DocumentType`'s publicId."]
        pub public_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
        #[doc = "`DocumentType`'s systemId."]
        pub system_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "internalSubset", skip_serializing_if = "Option::is_none")]
        #[doc = "`DocumentType`'s internalSubset."]
        pub internal_subset: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "xmlVersion", skip_serializing_if = "Option::is_none")]
        #[doc = "`Document`'s XML version in case of XML documents."]
        pub xml_version: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "`Attr`'s name."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "`Attr`'s value."]
        pub value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "pseudoType", skip_serializing_if = "Option::is_none")]
        #[doc = "Pseudo element type for this node."]
        pub pseudo_type: Option<::dom::PseudoType>,
        #[serde(rename = "shadowRootType", skip_serializing_if = "Option::is_none")]
        #[doc = "Shadow root type."]
        pub shadow_root_type: Option<::dom::ShadowRootType>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame ID for frame owner elements."]
        pub frame_id: Option<::page::FrameId<'a>>,
        #[serde(rename = "contentDocument", skip_serializing_if = "Option::is_none")]
        #[doc = "Content document for frame owner elements."]
        pub content_document: Option<Box<::dom::Node<'a>>>,
        #[serde(rename = "shadowRoots", skip_serializing_if = "Option::is_none")]
        #[doc = "Shadow root list for given element host."]
        pub shadow_roots: Option<Vec<Box<::dom::Node<'a>>>>,
        #[serde(rename = "templateContent", skip_serializing_if = "Option::is_none")]
        #[doc = "Content document fragment for template elements."]
        pub template_content: Option<Box<::dom::Node<'a>>>,
        #[serde(rename = "pseudoElements", skip_serializing_if = "Option::is_none")]
        #[doc = "Pseudo elements associated with this node."]
        pub pseudo_elements: Option<Vec<Box<::dom::Node<'a>>>>,
        #[serde(rename = "importedDocument", skip_serializing_if = "Option::is_none")]
        #[doc = "Import document for the HTMLImport links."]
        pub imported_document: Option<Box<::dom::Node<'a>>>,
        #[serde(rename = "distributedNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "Distributed nodes for given insertion point."]
        pub distributed_nodes: Option<Vec<::dom::BackendNode<'a>>>,
        #[serde(rename = "isSVG", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the node is SVG."]
        pub is_svg: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "A structure holding an RGBA color."]
    pub struct Rgba {
        #[serde(rename = "r")]
        #[doc = "The red component, in the \\[0-255\\] range."]
        pub r: i32,
        #[serde(rename = "g")]
        #[doc = "The green component, in the \\[0-255\\] range."]
        pub g: i32,
        #[serde(rename = "b")]
        #[doc = "The blue component, in the \\[0-255\\] range."]
        pub b: i32,
        #[serde(rename = "a", skip_serializing_if = "Option::is_none")]
        #[doc = "The alpha component, in the \\[0-1\\] range \\(default: 1\\)."]
        pub a: Option<f64>,
    }
    #[doc = "An array of quad vertices, x immediately followed by y for each point, points clock-wise."]
    pub type Quad = Vec<f64>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Box model."]
    pub struct BoxModel {
        #[serde(rename = "content")]
        #[doc = "Content box"]
        pub content: ::dom::Quad,
        #[serde(rename = "padding")]
        #[doc = "Padding box"]
        pub padding: ::dom::Quad,
        #[serde(rename = "border")]
        #[doc = "Border box"]
        pub border: ::dom::Quad,
        #[serde(rename = "margin")]
        #[doc = "Margin box"]
        pub margin: ::dom::Quad,
        #[serde(rename = "width")]
        #[doc = "Node width"]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Node height"]
        pub height: i32,
        #[serde(rename = "shapeOutside", skip_serializing_if = "Option::is_none")]
        #[doc = "Shape outside coordinates"]
        pub shape_outside: Option<::dom::ShapeOutsideInfo>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "CSS Shape Outside details."]
    pub struct ShapeOutsideInfo {
        #[serde(rename = "bounds")]
        #[doc = "Shape bounds"]
        pub bounds: ::dom::Quad,
        #[serde(rename = "shape")]
        #[doc = "Shape coordinate details"]
        pub shape: Vec<::serde_json::Value>,
        #[serde(rename = "marginShape")]
        #[doc = "Margin shape bounds"]
        pub margin_shape: Vec<::serde_json::Value>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Rectangle."]
    pub struct Rect {
        #[serde(rename = "x")]
        #[doc = "X coordinate"]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate"]
        pub y: f64,
        #[serde(rename = "width")]
        #[doc = "Rectangle width"]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Rectangle height"]
        pub height: f64,
    }
}
#[doc = "DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript\nexecution will stop on these operations as if there was a regular breakpoint set.\n\n# DOMDebugger\n\n## Commands\n\n- [`DOMDebugger.getEventListeners`](struct.GetEventListenersCommand.html)\n\n  Returns event listeners of the given object.\n- [`DOMDebugger.removeDOMBreakpoint`](struct.RemoveDomBreakpointCommand.html)\n\n  Removes DOM breakpoint that was set using `setDOMBreakpoint`.\n- [`DOMDebugger.removeEventListenerBreakpoint`](struct.RemoveEventListenerBreakpointCommand.html)\n\n  Removes breakpoint on particular DOM event.\n- [`DOMDebugger.removeInstrumentationBreakpoint`](struct.RemoveInstrumentationBreakpointCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Removes breakpoint on particular native event.\n- [`DOMDebugger.removeXHRBreakpoint`](struct.RemoveXhrBreakpointCommand.html)\n\n  Removes breakpoint from XMLHttpRequest.\n- [`DOMDebugger.setDOMBreakpoint`](struct.SetDomBreakpointCommand.html)\n\n  Sets breakpoint on particular operation with DOM.\n- [`DOMDebugger.setEventListenerBreakpoint`](struct.SetEventListenerBreakpointCommand.html)\n\n  Sets breakpoint on particular DOM event.\n- [`DOMDebugger.setInstrumentationBreakpoint`](struct.SetInstrumentationBreakpointCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets breakpoint on particular native event.\n- [`DOMDebugger.setXHRBreakpoint`](struct.SetXhrBreakpointCommand.html)\n\n  Sets breakpoint on XMLHttpRequest.\n\n##Types\n\n- [`DOMBreakpointType`](enum.DomBreakpointType.html)\n\n  DOM breakpoint type.\n- [`EventListener`](struct.EventListener.html)\n\n  Object event listener.\n"]
pub mod dom_debugger {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns event listeners of the given object.\n\n# Command `DOMDebugger.getEventListeners`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::GetEventListenersCommand`](struct.GetEventListenersCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::GetEventListenersResponse`](struct.GetEventListenersResponse.html)"]
    pub struct GetEventListenersCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to return listeners for."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "depth", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the\nentire subtree or provide an integer larger than 0."]
        pub depth: Option<i32>,
        #[serde(rename = "pierce", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not iframes and shadow roots should be traversed when returning the subtree\n\\(default is false\\). Reports listeners for all contexts if pierce is enabled."]
        pub pierce: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetEventListenersCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.getEventListeners";
    }
    impl<'a> ::SerializeCdpCommand for GetEventListenersCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.getEventListeners"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetEventListenersCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.getEventListeners" {
                Ok ( < GetEventListenersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns event listeners of the given object.\n\n# Command `DOMDebugger.getEventListeners`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::GetEventListenersCommand`](struct.GetEventListenersCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::GetEventListenersResponse`](struct.GetEventListenersResponse.html)"]
    pub struct GetEventListenersResponse<'a> {
        #[serde(rename = "listeners")]
        #[doc = "Array of relevant listeners."]
        pub listeners: Vec<::dom_debugger::EventListener<'a>>,
    }
    impl<'a> ::CdpCommand for GetEventListenersResponse<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.getEventListeners";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetEventListenersCommand<'a> {
        type Response = GetEventListenersResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetEventListenersResponse<'b> {
        type Command = GetEventListenersCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes DOM breakpoint that was set using `setDOMBreakpoint`.\n\n# Command `DOMDebugger.removeDOMBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveDomBreakpointCommand`](struct.RemoveDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveDomBreakpointResponse`](struct.RemoveDomBreakpointResponse.html)"]
    pub struct RemoveDomBreakpointCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Identifier of the node to remove breakpoint from."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "type")]
        #[doc = "Type of the breakpoint to remove."]
        pub ty: ::dom_debugger::DomBreakpointType,
    }
    impl ::CdpCommand for RemoveDomBreakpointCommand {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeDOMBreakpoint";
    }
    impl ::SerializeCdpCommand for RemoveDomBreakpointCommand {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeDOMBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RemoveDomBreakpointCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeDOMBreakpoint" {
                Ok ( < RemoveDomBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes DOM breakpoint that was set using `setDOMBreakpoint`.\n\n# Command `DOMDebugger.removeDOMBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveDomBreakpointCommand`](struct.RemoveDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveDomBreakpointResponse`](struct.RemoveDomBreakpointResponse.html)"]
    pub struct RemoveDomBreakpointResponse;
    impl ::serde::Serialize for RemoveDomBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveDomBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveDomBreakpointResponse)
        }
    }
    impl ::CdpCommand for RemoveDomBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeDOMBreakpoint";
    }
    impl<'b> ::HasCdpResponse<'b> for RemoveDomBreakpointCommand {
        type Response = RemoveDomBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveDomBreakpointResponse {
        type Command = RemoveDomBreakpointCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint on particular DOM event.\n\n# Command `DOMDebugger.removeEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveEventListenerBreakpointCommand`](struct.RemoveEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveEventListenerBreakpointResponse`](struct.RemoveEventListenerBreakpointResponse.html)"]
    pub struct RemoveEventListenerBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Event name."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetName", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> EventTarget interface name."]
        pub target_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for RemoveEventListenerBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeEventListenerBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for RemoveEventListenerBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeEventListenerBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveEventListenerBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeEventListenerBreakpoint" {
                Ok ( < RemoveEventListenerBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint on particular DOM event.\n\n# Command `DOMDebugger.removeEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveEventListenerBreakpointCommand`](struct.RemoveEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveEventListenerBreakpointResponse`](struct.RemoveEventListenerBreakpointResponse.html)"]
    pub struct RemoveEventListenerBreakpointResponse;
    impl ::serde::Serialize for RemoveEventListenerBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveEventListenerBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveEventListenerBreakpointResponse)
        }
    }
    impl ::CdpCommand for RemoveEventListenerBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeEventListenerBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveEventListenerBreakpointCommand<'a> {
        type Response = RemoveEventListenerBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveEventListenerBreakpointResponse {
        type Command = RemoveEventListenerBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes breakpoint on particular native event.\n\n# Command `DOMDebugger.removeInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveInstrumentationBreakpointCommand`](struct.RemoveInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveInstrumentationBreakpointResponse`](struct.RemoveInstrumentationBreakpointResponse.html)"]
    pub struct RemoveInstrumentationBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Instrumentation name to stop on."]
        pub event_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RemoveInstrumentationBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeInstrumentationBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for RemoveInstrumentationBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeInstrumentationBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveInstrumentationBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeInstrumentationBreakpoint" {
                Ok ( < RemoveInstrumentationBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Removes breakpoint on particular native event.\n\n# Command `DOMDebugger.removeInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveInstrumentationBreakpointCommand`](struct.RemoveInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveInstrumentationBreakpointResponse`](struct.RemoveInstrumentationBreakpointResponse.html)"]
    pub struct RemoveInstrumentationBreakpointResponse;
    impl ::serde::Serialize for RemoveInstrumentationBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveInstrumentationBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveInstrumentationBreakpointResponse)
        }
    }
    impl ::CdpCommand for RemoveInstrumentationBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeInstrumentationBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveInstrumentationBreakpointCommand<'a> {
        type Response = RemoveInstrumentationBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveInstrumentationBreakpointResponse {
        type Command = RemoveInstrumentationBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint from XMLHttpRequest.\n\n# Command `DOMDebugger.removeXHRBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveXhrBreakpointCommand`](struct.RemoveXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveXhrBreakpointResponse`](struct.RemoveXhrBreakpointResponse.html)"]
    pub struct RemoveXhrBreakpointCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL substring."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RemoveXhrBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeXHRBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for RemoveXhrBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.removeXHRBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveXhrBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.removeXHRBreakpoint" {
                Ok ( < RemoveXhrBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes breakpoint from XMLHttpRequest.\n\n# Command `DOMDebugger.removeXHRBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::RemoveXhrBreakpointCommand`](struct.RemoveXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::RemoveXhrBreakpointResponse`](struct.RemoveXhrBreakpointResponse.html)"]
    pub struct RemoveXhrBreakpointResponse;
    impl ::serde::Serialize for RemoveXhrBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveXhrBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveXhrBreakpointResponse)
        }
    }
    impl ::CdpCommand for RemoveXhrBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.removeXHRBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveXhrBreakpointCommand<'a> {
        type Response = RemoveXhrBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveXhrBreakpointResponse {
        type Command = RemoveXhrBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular operation with DOM.\n\n# Command `DOMDebugger.setDOMBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetDomBreakpointCommand`](struct.SetDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetDomBreakpointResponse`](struct.SetDomBreakpointResponse.html)"]
    pub struct SetDomBreakpointCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Identifier of the node to set breakpoint on."]
        pub node_id: ::dom::NodeId,
        #[serde(rename = "type")]
        #[doc = "Type of the operation to stop upon."]
        pub ty: ::dom_debugger::DomBreakpointType,
    }
    impl ::CdpCommand for SetDomBreakpointCommand {
        const COMMAND_NAME: &'static str = "DOMDebugger.setDOMBreakpoint";
    }
    impl ::SerializeCdpCommand for SetDomBreakpointCommand {
        fn command_name(&self) -> &str {
            "DOMDebugger.setDOMBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDomBreakpointCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setDOMBreakpoint" {
                Ok ( < SetDomBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular operation with DOM.\n\n# Command `DOMDebugger.setDOMBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetDomBreakpointCommand`](struct.SetDomBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetDomBreakpointResponse`](struct.SetDomBreakpointResponse.html)"]
    pub struct SetDomBreakpointResponse;
    impl ::serde::Serialize for SetDomBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDomBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDomBreakpointResponse)
        }
    }
    impl ::CdpCommand for SetDomBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.setDOMBreakpoint";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDomBreakpointCommand {
        type Response = SetDomBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDomBreakpointResponse {
        type Command = SetDomBreakpointCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular DOM event.\n\n# Command `DOMDebugger.setEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetEventListenerBreakpointCommand`](struct.SetEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetEventListenerBreakpointResponse`](struct.SetEventListenerBreakpointResponse.html)"]
    pub struct SetEventListenerBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "DOM Event name to stop on \\(any DOM event will do\\)."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetName", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> EventTarget interface name to stop on. If equal to `\"\\*\"` or not provided, will stop on any\nEventTarget."]
        pub target_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetEventListenerBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.setEventListenerBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for SetEventListenerBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setEventListenerBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetEventListenerBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setEventListenerBreakpoint" {
                Ok ( < SetEventListenerBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on particular DOM event.\n\n# Command `DOMDebugger.setEventListenerBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetEventListenerBreakpointCommand`](struct.SetEventListenerBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetEventListenerBreakpointResponse`](struct.SetEventListenerBreakpointResponse.html)"]
    pub struct SetEventListenerBreakpointResponse;
    impl ::serde::Serialize for SetEventListenerBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEventListenerBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEventListenerBreakpointResponse)
        }
    }
    impl ::CdpCommand for SetEventListenerBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.setEventListenerBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetEventListenerBreakpointCommand<'a> {
        type Response = SetEventListenerBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetEventListenerBreakpointResponse {
        type Command = SetEventListenerBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets breakpoint on particular native event.\n\n# Command `DOMDebugger.setInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetInstrumentationBreakpointCommand`](struct.SetInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetInstrumentationBreakpointResponse`](struct.SetInstrumentationBreakpointResponse.html)"]
    pub struct SetInstrumentationBreakpointCommand<'a> {
        #[serde(rename = "eventName")]
        #[doc = "Instrumentation name to stop on."]
        pub event_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetInstrumentationBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.setInstrumentationBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for SetInstrumentationBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setInstrumentationBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetInstrumentationBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setInstrumentationBreakpoint" {
                Ok ( < SetInstrumentationBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets breakpoint on particular native event.\n\n# Command `DOMDebugger.setInstrumentationBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetInstrumentationBreakpointCommand`](struct.SetInstrumentationBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetInstrumentationBreakpointResponse`](struct.SetInstrumentationBreakpointResponse.html)"]
    pub struct SetInstrumentationBreakpointResponse;
    impl ::serde::Serialize for SetInstrumentationBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInstrumentationBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInstrumentationBreakpointResponse)
        }
    }
    impl ::CdpCommand for SetInstrumentationBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.setInstrumentationBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetInstrumentationBreakpointCommand<'a> {
        type Response = SetInstrumentationBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetInstrumentationBreakpointResponse {
        type Command = SetInstrumentationBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on XMLHttpRequest.\n\n# Command `DOMDebugger.setXHRBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetXhrBreakpointCommand`](struct.SetXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetXhrBreakpointResponse`](struct.SetXhrBreakpointResponse.html)"]
    pub struct SetXhrBreakpointCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL substring. All XHRs having this substring in the URL will get stopped upon."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetXhrBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMDebugger.setXHRBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for SetXhrBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMDebugger.setXHRBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetXhrBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMDebugger.setXHRBreakpoint" {
                Ok ( < SetXhrBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets breakpoint on XMLHttpRequest.\n\n# Command `DOMDebugger.setXHRBreakpoint`\n\n*Domain Module:* [`cdp::dom_debugger`](index.html)  \n*Command Struct:* [`cdp::dom_debugger::SetXhrBreakpointCommand`](struct.SetXhrBreakpointCommand.html)  \n*Response Struct:* [`cdp::dom_debugger::SetXhrBreakpointResponse`](struct.SetXhrBreakpointResponse.html)"]
    pub struct SetXhrBreakpointResponse;
    impl ::serde::Serialize for SetXhrBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetXhrBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetXhrBreakpointResponse)
        }
    }
    impl ::CdpCommand for SetXhrBreakpointResponse {
        const COMMAND_NAME: &'static str = "DOMDebugger.setXHRBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetXhrBreakpointCommand<'a> {
        type Response = SetXhrBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetXhrBreakpointResponse {
        type Command = SetXhrBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "DOM breakpoint type."]
    pub enum DomBreakpointType {
        #[serde(rename = "subtree-modified")]
        #[doc = "Represented as `\"subtree-modified\"`."]
        SubtreeModified,
        #[serde(rename = "attribute-modified")]
        #[doc = "Represented as `\"attribute-modified\"`."]
        AttributeModified,
        #[serde(rename = "node-removed")]
        #[doc = "Represented as `\"node-removed\"`."]
        NodeRemoved,
    }
    impl DomBreakpointType {
        pub const ENUM_VALUES: &'static [DomBreakpointType] = &[
            DomBreakpointType::SubtreeModified,
            DomBreakpointType::AttributeModified,
            DomBreakpointType::NodeRemoved,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["subtree-modified", "attribute-modified", "node-removed"];
    }
    impl ::std::str::FromStr for DomBreakpointType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "subtree-modified" => Ok(DomBreakpointType::SubtreeModified),
                "attribute-modified" => Ok(DomBreakpointType::AttributeModified),
                "node-removed" => Ok(DomBreakpointType::NodeRemoved),
                _ => Err(::ParseEnumError {
                    expected: DomBreakpointType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DomBreakpointType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DomBreakpointType::SubtreeModified => "subtree-modified",
                    DomBreakpointType::AttributeModified => "attribute-modified",
                    DomBreakpointType::NodeRemoved => "node-removed",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Object event listener."]
    pub struct EventListener<'a> {
        #[serde(rename = "type")]
        #[doc = "`EventListener`'s type."]
        pub ty: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "useCapture")]
        #[doc = "`EventListener`'s useCapture."]
        pub use_capture: bool,
        #[serde(rename = "passive")]
        #[doc = "`EventListener`'s passive flag."]
        pub passive: bool,
        #[serde(rename = "once")]
        #[doc = "`EventListener`'s once flag."]
        pub once: bool,
        #[serde(rename = "scriptId")]
        #[doc = "Script id of the handler code."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: i32,
        #[serde(rename = "handler", skip_serializing_if = "Option::is_none")]
        #[doc = "Event handler function value."]
        pub handler: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "originalHandler", skip_serializing_if = "Option::is_none")]
        #[doc = "Event original handler function value."]
        pub original_handler: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Node the listener is added to \\(if any\\)."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain facilitates obtaining document snapshots with DOM, layout, and style information.\n\n# DOMSnapshot\n\n## Commands\n\n- [`DOMSnapshot.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables DOM snapshot agent for the given page.\n- [`DOMSnapshot.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables DOM snapshot agent for the given page.\n- [`DOMSnapshot.getSnapshot`](struct.GetSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\n  template contents, and imported documents\\) in a flattened array, as well as layout and\n  white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\n  flattened.\n- [`DOMSnapshot.captureSnapshot`](struct.CaptureSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\n  template contents, and imported documents\\) in a flattened array, as well as layout and\n  white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\n  flattened.\n\n##Types\n\n- [`DOMNode`](struct.DomNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A Node in the DOM tree.\n- [`InlineTextBox`](struct.InlineTextBox.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of post layout rendered text positions. The exact layout should not be regarded as\n  stable and may change between versions.\n- [`LayoutTreeNode`](struct.LayoutTreeNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of an element in the DOM tree with a LayoutObject.\n- [`ComputedStyle`](struct.ComputedStyle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A subset of the full ComputedStyle as defined by the request whitelist.\n- [`NameValue`](struct.NameValue.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A name/value pair.\n- [`StringIndex`](type.StringIndex.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Index of the string in the strings table.\n- [`ArrayOfStrings`](type.ArrayOfStrings.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Index of the string in the strings table.\n- [`RareStringData`](struct.RareStringData.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data that is only present on rare nodes.\n- [`RareBooleanData`](struct.RareBooleanData.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`RareIntegerData`](struct.RareIntegerData.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Rectangle`](type.Rectangle.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DocumentSnapshot`](struct.DocumentSnapshot.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Document snapshot.\n- [`NodeTreeSnapshot`](struct.NodeTreeSnapshot.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Table containing nodes.\n- [`LayoutTreeSnapshot`](struct.LayoutTreeSnapshot.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of an element in the DOM tree with a LayoutObject.\n- [`TextBoxSnapshot`](struct.TextBoxSnapshot.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of post layout rendered text positions. The exact layout should not be regarded as\n  stable and may change between versions.\n"]
pub mod dom_snapshot {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables DOM snapshot agent for the given page.\n\n# Command `DOMSnapshot.disable`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "DOMSnapshot.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "DOMSnapshot.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMSnapshot.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables DOM snapshot agent for the given page.\n\n# Command `DOMSnapshot.disable`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "DOMSnapshot.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables DOM snapshot agent for the given page.\n\n# Command `DOMSnapshot.enable`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "DOMSnapshot.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "DOMSnapshot.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMSnapshot.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables DOM snapshot agent for the given page.\n\n# Command `DOMSnapshot.enable`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "DOMSnapshot.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\ntemplate contents, and imported documents\\) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n\n# Command `DOMSnapshot.getSnapshot`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::GetSnapshotCommand`](struct.GetSnapshotCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::GetSnapshotResponse`](struct.GetSnapshotResponse.html)"]
    #[deprecated]
    pub struct GetSnapshotCommand<'a> {
        #[serde(rename = "computedStyleWhitelist")]
        #[doc = "Whitelist of computed styles to return."]
        pub computed_style_whitelist: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "includeEventListeners", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not to retrieve details of DOM listeners \\(default false\\)."]
        pub include_event_listeners: Option<bool>,
        #[serde(rename = "includePaintOrder", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to determine and include the paint order index of LayoutTreeNodes \\(default false\\)."]
        pub include_paint_order: Option<bool>,
        #[serde(rename = "includeUserAgentShadowTree", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to include UA shadow tree in the snapshot \\(default false\\)."]
        pub include_user_agent_shadow_tree: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMSnapshot.getSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for GetSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMSnapshot.getSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMSnapshot.getSnapshot" {
                Ok(
                    <GetSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\ntemplate contents, and imported documents\\) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n\n# Command `DOMSnapshot.getSnapshot`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::GetSnapshotCommand`](struct.GetSnapshotCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::GetSnapshotResponse`](struct.GetSnapshotResponse.html)"]
    #[deprecated]
    pub struct GetSnapshotResponse<'a> {
        #[serde(rename = "domNodes")]
        #[doc = "The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document."]
        pub dom_nodes: Vec<::dom_snapshot::DomNode<'a>>,
        #[serde(rename = "layoutTreeNodes")]
        #[doc = "The nodes in the layout tree."]
        pub layout_tree_nodes: Vec<::dom_snapshot::LayoutTreeNode<'a>>,
        #[serde(rename = "computedStyles")]
        #[doc = "Whitelisted ComputedStyle properties for each node in the layout tree."]
        pub computed_styles: Vec<::dom_snapshot::ComputedStyle<'a>>,
    }
    impl<'a> ::CdpCommand for GetSnapshotResponse<'a> {
        const COMMAND_NAME: &'static str = "DOMSnapshot.getSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetSnapshotCommand<'a> {
        type Response = GetSnapshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetSnapshotResponse<'b> {
        type Command = GetSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\ntemplate contents, and imported documents\\) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n\n# Command `DOMSnapshot.captureSnapshot`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::CaptureSnapshotCommand`](struct.CaptureSnapshotCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::CaptureSnapshotResponse`](struct.CaptureSnapshotResponse.html)"]
    pub struct CaptureSnapshotCommand<'a> {
        #[serde(rename = "computedStyles")]
        #[doc = "Whitelist of computed styles to return."]
        pub computed_styles: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CaptureSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMSnapshot.captureSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for CaptureSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMSnapshot.captureSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CaptureSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMSnapshot.captureSnapshot" {
                Ok(
                    <CaptureSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a document snapshot, including the full DOM tree of the root node \\(including iframes,\ntemplate contents, and imported documents\\) in a flattened array, as well as layout and\nwhite-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is\nflattened.\n\n# Command `DOMSnapshot.captureSnapshot`\n\n*Domain Module:* [`cdp::dom_snapshot`](index.html)  \n*Command Struct:* [`cdp::dom_snapshot::CaptureSnapshotCommand`](struct.CaptureSnapshotCommand.html)  \n*Response Struct:* [`cdp::dom_snapshot::CaptureSnapshotResponse`](struct.CaptureSnapshotResponse.html)"]
    pub struct CaptureSnapshotResponse<'a> {
        #[serde(rename = "documents")]
        #[doc = "The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document."]
        pub documents: Vec<::dom_snapshot::DocumentSnapshot>,
        #[serde(rename = "strings")]
        #[doc = "Shared string table that all string properties refer to with indexes."]
        pub strings: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CaptureSnapshotResponse<'a> {
        const COMMAND_NAME: &'static str = "DOMSnapshot.captureSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CaptureSnapshotCommand<'a> {
        type Response = CaptureSnapshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CaptureSnapshotResponse<'b> {
        type Command = CaptureSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A Node in the DOM tree."]
    pub struct DomNode<'a> {
        #[serde(rename = "nodeType")]
        #[doc = "`Node`'s nodeType."]
        pub node_type: i32,
        #[serde(rename = "nodeName")]
        #[doc = "`Node`'s nodeName."]
        pub node_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "nodeValue")]
        #[doc = "`Node`'s nodeValue."]
        pub node_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "textValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for textarea elements, contains the text value."]
        pub text_value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inputValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for input elements, contains the input's associated text value."]
        pub input_value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inputChecked", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for radio and checkbox input elements, indicates if the element has been checked"]
        pub input_checked: Option<bool>,
        #[serde(rename = "optionSelected", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for option elements, indicates if the element has been selected"]
        pub option_selected: Option<bool>,
        #[serde(rename = "backendNodeId")]
        #[doc = "`Node`'s id, corresponds to DOM.Node.backendNodeId."]
        pub backend_node_id: ::dom::BackendNodeId,
        #[serde(rename = "childNodeIndexes", skip_serializing_if = "Option::is_none")]
        #[doc = "The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if\nany."]
        pub child_node_indexes: Option<Vec<i32>>,
        #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
        #[doc = "Attributes of an `Element` node."]
        pub attributes: Option<Vec<::dom_snapshot::NameValue<'a>>>,
        #[serde(rename = "pseudoElementIndexes", skip_serializing_if = "Option::is_none")]
        #[doc = "Indexes of pseudo elements associated with this node in the `domNodes` array returned by\n`getSnapshot`, if any."]
        pub pseudo_element_indexes: Option<Vec<i32>>,
        #[serde(rename = "layoutNodeIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of the node's related layout tree node in the `layoutTreeNodes` array returned by\n`getSnapshot`, if any."]
        pub layout_node_index: Option<i32>,
        #[serde(rename = "documentURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
        pub document_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "baseURL", skip_serializing_if = "Option::is_none")]
        #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
        pub base_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "contentLanguage", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for documents, contains the document's content language."]
        pub content_language: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "documentEncoding", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for documents, contains the document's character set encoding."]
        pub document_encoding: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "publicId", skip_serializing_if = "Option::is_none")]
        #[doc = "`DocumentType` node's publicId."]
        pub public_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "systemId", skip_serializing_if = "Option::is_none")]
        #[doc = "`DocumentType` node's systemId."]
        pub system_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame ID for frame owner elements and also for the document node."]
        pub frame_id: Option<::page::FrameId<'a>>,
        #[serde(rename = "contentDocumentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of a frame owner element's content document in the `domNodes` array returned by\n`getSnapshot`, if any."]
        pub content_document_index: Option<i32>,
        #[serde(rename = "pseudoType", skip_serializing_if = "Option::is_none")]
        #[doc = "Type of a pseudo element node."]
        pub pseudo_type: Option<::dom::PseudoType>,
        #[serde(rename = "shadowRootType", skip_serializing_if = "Option::is_none")]
        #[doc = "Shadow root type."]
        pub shadow_root_type: Option<::dom::ShadowRootType>,
        #[serde(rename = "isClickable", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether this DOM node responds to mouse clicks. This includes nodes that have had click\nevent listeners attached via JavaScript as well as anchor tags that naturally navigate when\nclicked."]
        pub is_clickable: Option<bool>,
        #[serde(rename = "eventListeners", skip_serializing_if = "Option::is_none")]
        #[doc = "Details of the node's event listeners, if any."]
        pub event_listeners: Option<Vec<::dom_debugger::EventListener<'a>>>,
        #[serde(rename = "currentSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "The selected url for nodes with a srcset attribute."]
        pub current_source_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "originURL", skip_serializing_if = "Option::is_none")]
        #[doc = "The url of the script \\(if any\\) that generates this node."]
        pub origin_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "scrollOffsetX", skip_serializing_if = "Option::is_none")]
        #[doc = "Scroll offsets, set when this node is a Document."]
        pub scroll_offset_x: Option<f64>,
        #[serde(rename = "scrollOffsetY", skip_serializing_if = "Option::is_none")]
        pub scroll_offset_y: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of post layout rendered text positions. The exact layout should not be regarded as\nstable and may change between versions."]
    pub struct InlineTextBox {
        #[serde(rename = "boundingBox")]
        #[doc = "The bounding box in document coordinates. Note that scroll offset of the document is ignored."]
        pub bounding_box: ::dom::Rect,
        #[serde(rename = "startCharacterIndex")]
        #[doc = "The starting index in characters, for this post layout textbox substring. Characters that\nwould be represented as a surrogate pair in UTF-16 have length 2."]
        pub start_character_index: i32,
        #[serde(rename = "numCharacters")]
        #[doc = "The number of characters in this post layout textbox substring. Characters that would be\nrepresented as a surrogate pair in UTF-16 have length 2."]
        pub num_characters: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of an element in the DOM tree with a LayoutObject."]
    pub struct LayoutTreeNode<'a> {
        #[serde(rename = "domNodeIndex")]
        #[doc = "The index of the related DOM node in the `domNodes` array returned by `getSnapshot`."]
        pub dom_node_index: i32,
        #[serde(rename = "boundingBox")]
        #[doc = "The bounding box in document coordinates. Note that scroll offset of the document is ignored."]
        pub bounding_box: ::dom::Rect,
        #[serde(rename = "layoutText", skip_serializing_if = "Option::is_none")]
        #[doc = "Contents of the LayoutText, if any."]
        pub layout_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "inlineTextNodes", skip_serializing_if = "Option::is_none")]
        #[doc = "The post-layout inline text nodes, if any."]
        pub inline_text_nodes: Option<Vec<::dom_snapshot::InlineTextBox>>,
        #[serde(rename = "styleIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "Index into the `computedStyles` array returned by `getSnapshot`."]
        pub style_index: Option<i32>,
        #[serde(rename = "paintOrder", skip_serializing_if = "Option::is_none")]
        #[doc = "Global paint order index, which is determined by the stacking order of the nodes. Nodes\nthat are painted together will have the same index. Only provided if includePaintOrder in\ngetSnapshot was true."]
        pub paint_order: Option<i32>,
        #[serde(rename = "isStackingContext", skip_serializing_if = "Option::is_none")]
        #[doc = "Set to true to indicate the element begins a new stacking context."]
        pub is_stacking_context: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A subset of the full ComputedStyle as defined by the request whitelist."]
    pub struct ComputedStyle<'a> {
        #[serde(rename = "properties")]
        #[doc = "Name/value pairs of computed style properties."]
        pub properties: Vec<::dom_snapshot::NameValue<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A name/value pair."]
    pub struct NameValue<'a> {
        #[serde(rename = "name")]
        #[doc = "Attribute/property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Attribute/property value."]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Index of the string in the strings table."]
    pub type StringIndex = i32;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Index of the string in the strings table."]
    pub type ArrayOfStrings = Vec<::dom_snapshot::StringIndex>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data that is only present on rare nodes."]
    pub struct RareStringData {
        #[serde(rename = "index")]
        pub index: Vec<i32>,
        #[serde(rename = "value")]
        pub value: Vec<::dom_snapshot::StringIndex>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct RareBooleanData {
        #[serde(rename = "index")]
        pub index: Vec<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct RareIntegerData {
        #[serde(rename = "index")]
        pub index: Vec<i32>,
        #[serde(rename = "value")]
        pub value: Vec<i32>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type Rectangle = Vec<f64>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Document snapshot."]
    pub struct DocumentSnapshot {
        #[serde(rename = "documentURL")]
        #[doc = "Document URL that `Document` or `FrameOwner` node points to."]
        pub document_url: ::dom_snapshot::StringIndex,
        #[serde(rename = "baseURL")]
        #[doc = "Base URL that `Document` or `FrameOwner` node uses for URL completion."]
        pub base_url: ::dom_snapshot::StringIndex,
        #[serde(rename = "contentLanguage")]
        #[doc = "Contains the document's content language."]
        pub content_language: ::dom_snapshot::StringIndex,
        #[serde(rename = "encodingName")]
        #[doc = "Contains the document's character set encoding."]
        pub encoding_name: ::dom_snapshot::StringIndex,
        #[serde(rename = "publicId")]
        #[doc = "`DocumentType` node's publicId."]
        pub public_id: ::dom_snapshot::StringIndex,
        #[serde(rename = "systemId")]
        #[doc = "`DocumentType` node's systemId."]
        pub system_id: ::dom_snapshot::StringIndex,
        #[serde(rename = "frameId")]
        #[doc = "Frame ID for frame owner elements and also for the document node."]
        pub frame_id: ::dom_snapshot::StringIndex,
        #[serde(rename = "nodes")]
        #[doc = "A table with dom nodes."]
        pub nodes: ::dom_snapshot::NodeTreeSnapshot,
        #[serde(rename = "layout")]
        #[doc = "The nodes in the layout tree."]
        pub layout: ::dom_snapshot::LayoutTreeSnapshot,
        #[serde(rename = "textBoxes")]
        #[doc = "The post-layout inline text nodes."]
        pub text_boxes: ::dom_snapshot::TextBoxSnapshot,
        #[serde(rename = "scrollOffsetX", skip_serializing_if = "Option::is_none")]
        #[doc = "Scroll offsets."]
        pub scroll_offset_x: Option<f64>,
        #[serde(rename = "scrollOffsetY", skip_serializing_if = "Option::is_none")]
        pub scroll_offset_y: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Table containing nodes."]
    pub struct NodeTreeSnapshot {
        #[serde(rename = "parentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "Parent node index."]
        pub parent_index: Option<Vec<i32>>,
        #[serde(rename = "nodeType", skip_serializing_if = "Option::is_none")]
        #[doc = "`Node`'s nodeType."]
        pub node_type: Option<Vec<i32>>,
        #[serde(rename = "nodeName", skip_serializing_if = "Option::is_none")]
        #[doc = "`Node`'s nodeName."]
        pub node_name: Option<Vec<::dom_snapshot::StringIndex>>,
        #[serde(rename = "nodeValue", skip_serializing_if = "Option::is_none")]
        #[doc = "`Node`'s nodeValue."]
        pub node_value: Option<Vec<::dom_snapshot::StringIndex>>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "`Node`'s id, corresponds to DOM.Node.backendNodeId."]
        pub backend_node_id: Option<Vec<::dom::BackendNodeId>>,
        #[serde(rename = "attributes", skip_serializing_if = "Option::is_none")]
        #[doc = "Attributes of an `Element` node. Flatten name, value pairs."]
        pub attributes: Option<Vec<::dom_snapshot::ArrayOfStrings>>,
        #[serde(rename = "textValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for textarea elements, contains the text value."]
        pub text_value: Option<::dom_snapshot::RareStringData>,
        #[serde(rename = "inputValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for input elements, contains the input's associated text value."]
        pub input_value: Option<::dom_snapshot::RareStringData>,
        #[serde(rename = "inputChecked", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for radio and checkbox input elements, indicates if the element has been checked"]
        pub input_checked: Option<::dom_snapshot::RareBooleanData>,
        #[serde(rename = "optionSelected", skip_serializing_if = "Option::is_none")]
        #[doc = "Only set for option elements, indicates if the element has been selected"]
        pub option_selected: Option<::dom_snapshot::RareBooleanData>,
        #[serde(rename = "contentDocumentIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of the document in the list of the snapshot documents."]
        pub content_document_index: Option<::dom_snapshot::RareIntegerData>,
        #[serde(rename = "pseudoType", skip_serializing_if = "Option::is_none")]
        #[doc = "Type of a pseudo element node."]
        pub pseudo_type: Option<::dom_snapshot::RareStringData>,
        #[serde(rename = "isClickable", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether this DOM node responds to mouse clicks. This includes nodes that have had click\nevent listeners attached via JavaScript as well as anchor tags that naturally navigate when\nclicked."]
        pub is_clickable: Option<::dom_snapshot::RareBooleanData>,
        #[serde(rename = "currentSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "The selected url for nodes with a srcset attribute."]
        pub current_source_url: Option<::dom_snapshot::RareStringData>,
        #[serde(rename = "originURL", skip_serializing_if = "Option::is_none")]
        #[doc = "The url of the script \\(if any\\) that generates this node."]
        pub origin_url: Option<::dom_snapshot::RareStringData>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of an element in the DOM tree with a LayoutObject."]
    pub struct LayoutTreeSnapshot {
        #[serde(rename = "nodeIndex")]
        #[doc = "The index of the related DOM node in the `domNodes` array returned by `getSnapshot`."]
        pub node_index: Vec<i32>,
        #[serde(rename = "styles")]
        #[doc = "Index into the `computedStyles` array returned by `captureSnapshot`."]
        pub styles: Vec<::dom_snapshot::ArrayOfStrings>,
        #[serde(rename = "bounds")]
        #[doc = "The absolute position bounding box."]
        pub bounds: Vec<::dom_snapshot::Rectangle>,
        #[serde(rename = "text")]
        #[doc = "Contents of the LayoutText, if any."]
        pub text: Vec<::dom_snapshot::StringIndex>,
        #[serde(rename = "stackingContexts")]
        #[doc = "Stacking context information."]
        pub stacking_contexts: ::dom_snapshot::RareBooleanData,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of post layout rendered text positions. The exact layout should not be regarded as\nstable and may change between versions."]
    pub struct TextBoxSnapshot {
        #[serde(rename = "layoutIndex")]
        #[doc = "Intex of th elayout tree node that owns this box collection."]
        pub layout_index: Vec<i32>,
        #[serde(rename = "bounds")]
        #[doc = "The absolute position bounding box."]
        pub bounds: Vec<::dom_snapshot::Rectangle>,
        #[serde(rename = "start")]
        #[doc = "The starting index in characters, for this post layout textbox substring. Characters that\nwould be represented as a surrogate pair in UTF-16 have length 2."]
        pub start: Vec<i32>,
        #[serde(rename = "length")]
        #[doc = "The number of characters in this post layout textbox substring. Characters that would be\nrepresented as a surrogate pair in UTF-16 have length 2."]
        pub length: Vec<i32>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Query and modify DOM storage.\n\n# DOMStorage\n\n## Commands\n\n- [`DOMStorage.clear`](struct.ClearCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables storage tracking, prevents storage events from being sent to the client.\n- [`DOMStorage.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables storage tracking, storage events will now be delivered to the client.\n- [`DOMStorage.getDOMStorageItems`](struct.GetDomStorageItemsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.removeDOMStorageItem`](struct.RemoveDomStorageItemCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.setDOMStorageItem`](struct.SetDomStorageItemCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`DOMStorage.domStorageItemAdded`](struct.DomStorageItemAddedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemRemoved`](struct.DomStorageItemRemovedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemUpdated`](struct.DomStorageItemUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`DOMStorage.domStorageItemsCleared`](struct.DomStorageItemsClearedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`StorageId`](struct.StorageId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  DOM Storage identifier.\n- [`Item`](type.Item.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  DOM Storage item.\n"]
pub mod dom_storage {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.clear`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::dom_storage::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
    }
    impl<'a> ::CdpCommand for ClearCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMStorage.clear";
    }
    impl<'a> ::SerializeCdpCommand for ClearCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.clear"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ClearCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.clear" {
                Ok(
                    <ClearCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.clear`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::dom_storage::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearResponse;
    impl ::serde::Serialize for ClearResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| ClearResponse)
        }
    }
    impl ::CdpCommand for ClearResponse {
        const COMMAND_NAME: &'static str = "DOMStorage.clear";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ClearCommand<'a> {
        type Response = ClearResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearResponse {
        type Command = ClearCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables storage tracking, prevents storage events from being sent to the client.\n\n# Command `DOMStorage.disable`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom_storage::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "DOMStorage.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "DOMStorage.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables storage tracking, prevents storage events from being sent to the client.\n\n# Command `DOMStorage.disable`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::dom_storage::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "DOMStorage.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables storage tracking, storage events will now be delivered to the client.\n\n# Command `DOMStorage.enable`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom_storage::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "DOMStorage.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "DOMStorage.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables storage tracking, storage events will now be delivered to the client.\n\n# Command `DOMStorage.enable`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::dom_storage::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "DOMStorage.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.getDOMStorageItems`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::GetDomStorageItemsCommand`](struct.GetDomStorageItemsCommand.html)  \n*Response Struct:* [`cdp::dom_storage::GetDomStorageItemsResponse`](struct.GetDomStorageItemsResponse.html)"]
    pub struct GetDomStorageItemsCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
    }
    impl<'a> ::CdpCommand for GetDomStorageItemsCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMStorage.getDOMStorageItems";
    }
    impl<'a> ::SerializeCdpCommand for GetDomStorageItemsCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.getDOMStorageItems"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetDomStorageItemsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.getDOMStorageItems" {
                Ok ( < GetDomStorageItemsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.getDOMStorageItems`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::GetDomStorageItemsCommand`](struct.GetDomStorageItemsCommand.html)  \n*Response Struct:* [`cdp::dom_storage::GetDomStorageItemsResponse`](struct.GetDomStorageItemsResponse.html)"]
    pub struct GetDomStorageItemsResponse<'a> {
        #[serde(rename = "entries")]
        pub entries: Vec<::dom_storage::Item<'a>>,
    }
    impl<'a> ::CdpCommand for GetDomStorageItemsResponse<'a> {
        const COMMAND_NAME: &'static str = "DOMStorage.getDOMStorageItems";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetDomStorageItemsCommand<'a> {
        type Response = GetDomStorageItemsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetDomStorageItemsResponse<'b> {
        type Command = GetDomStorageItemsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.removeDOMStorageItem`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::RemoveDomStorageItemCommand`](struct.RemoveDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::dom_storage::RemoveDomStorageItemResponse`](struct.RemoveDomStorageItemResponse.html)"]
    pub struct RemoveDomStorageItemCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RemoveDomStorageItemCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMStorage.removeDOMStorageItem";
    }
    impl<'a> ::SerializeCdpCommand for RemoveDomStorageItemCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.removeDOMStorageItem"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveDomStorageItemCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.removeDOMStorageItem" {
                Ok ( < RemoveDomStorageItemCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.removeDOMStorageItem`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::RemoveDomStorageItemCommand`](struct.RemoveDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::dom_storage::RemoveDomStorageItemResponse`](struct.RemoveDomStorageItemResponse.html)"]
    pub struct RemoveDomStorageItemResponse;
    impl ::serde::Serialize for RemoveDomStorageItemResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveDomStorageItemResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveDomStorageItemResponse)
        }
    }
    impl ::CdpCommand for RemoveDomStorageItemResponse {
        const COMMAND_NAME: &'static str = "DOMStorage.removeDOMStorageItem";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveDomStorageItemCommand<'a> {
        type Response = RemoveDomStorageItemResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveDomStorageItemResponse {
        type Command = RemoveDomStorageItemCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.setDOMStorageItem`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::SetDomStorageItemCommand`](struct.SetDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::dom_storage::SetDomStorageItemResponse`](struct.SetDomStorageItemResponse.html)"]
    pub struct SetDomStorageItemCommand<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        pub value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetDomStorageItemCommand<'a> {
        const COMMAND_NAME: &'static str = "DOMStorage.setDOMStorageItem";
    }
    impl<'a> ::SerializeCdpCommand for SetDomStorageItemCommand<'a> {
        fn command_name(&self) -> &str {
            "DOMStorage.setDOMStorageItem"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetDomStorageItemCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.setDOMStorageItem" {
                Ok ( < SetDomStorageItemCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `DOMStorage.setDOMStorageItem`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Command Struct:* [`cdp::dom_storage::SetDomStorageItemCommand`](struct.SetDomStorageItemCommand.html)  \n*Response Struct:* [`cdp::dom_storage::SetDomStorageItemResponse`](struct.SetDomStorageItemResponse.html)"]
    pub struct SetDomStorageItemResponse;
    impl ::serde::Serialize for SetDomStorageItemResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDomStorageItemResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDomStorageItemResponse)
        }
    }
    impl ::CdpCommand for SetDomStorageItemResponse {
        const COMMAND_NAME: &'static str = "DOMStorage.setDOMStorageItem";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetDomStorageItemCommand<'a> {
        type Response = SetDomStorageItemResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDomStorageItemResponse {
        type Command = SetDomStorageItemCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemAdded`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Event Struct:* [`cdp::dom_storage::DomStorageItemAddedEvent`](struct.DomStorageItemAddedEvent.html)"]
    pub struct DomStorageItemAddedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        pub new_value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for DomStorageItemAddedEvent<'a> {
        const EVENT_NAME: &'static str = "DOMStorage.domStorageItemAdded";
    }
    impl<'a> ::SerializeCdpEvent for DomStorageItemAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DomStorageItemAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemAdded" {
                Ok ( < DomStorageItemAddedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemRemoved`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Event Struct:* [`cdp::dom_storage::DomStorageItemRemovedEvent`](struct.DomStorageItemRemovedEvent.html)"]
    pub struct DomStorageItemRemovedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for DomStorageItemRemovedEvent<'a> {
        const EVENT_NAME: &'static str = "DOMStorage.domStorageItemRemoved";
    }
    impl<'a> ::SerializeCdpEvent for DomStorageItemRemovedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemRemoved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DomStorageItemRemovedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemRemoved" {
                Ok ( < DomStorageItemRemovedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemUpdated`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Event Struct:* [`cdp::dom_storage::DomStorageItemUpdatedEvent`](struct.DomStorageItemUpdatedEvent.html)"]
    pub struct DomStorageItemUpdatedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
        #[serde(rename = "key")]
        pub key: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "oldValue")]
        pub old_value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        pub new_value: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for DomStorageItemUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "DOMStorage.domStorageItemUpdated";
    }
    impl<'a> ::SerializeCdpEvent for DomStorageItemUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DomStorageItemUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemUpdated" {
                Ok ( < DomStorageItemUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `DOMStorage.domStorageItemsCleared`\n\n*Domain Module:* [`cdp::dom_storage`](index.html)  \n*Event Struct:* [`cdp::dom_storage::DomStorageItemsClearedEvent`](struct.DomStorageItemsClearedEvent.html)"]
    pub struct DomStorageItemsClearedEvent<'a> {
        #[serde(rename = "storageId")]
        pub storage_id: ::dom_storage::StorageId<'a>,
    }
    impl<'a> ::CdpEvent for DomStorageItemsClearedEvent<'a> {
        const EVENT_NAME: &'static str = "DOMStorage.domStorageItemsCleared";
    }
    impl<'a> ::SerializeCdpEvent for DomStorageItemsClearedEvent<'a> {
        fn event_name(&self) -> &str {
            "DOMStorage.domStorageItemsCleared"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DomStorageItemsClearedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DOMStorage.domStorageItemsCleared" {
                Ok ( < DomStorageItemsClearedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> DOM Storage identifier."]
    pub struct StorageId<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin for the storage."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isLocalStorage")]
        #[doc = "Whether the storage is local storage \\(not session storage\\)."]
        pub is_local_storage: bool,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> DOM Storage item."]
    pub type Item<'a> = Vec<::std::borrow::Cow<'a, str>>;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Database\n\n## Commands\n\n- [`Database.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables database tracking, prevents database events from being sent to the client.\n- [`Database.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables database tracking, database events will now be delivered to the client.\n- [`Database.executeSQL`](struct.ExecuteSqlCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Database.getDatabaseTableNames`](struct.GetDatabaseTableNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`Database.addDatabase`](struct.AddDatabaseEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`DatabaseId`](type.DatabaseId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of Database object.\n- [`Database`](struct.Database.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database object.\n- [`Error`](struct.Error.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database error.\n"]
pub mod database {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables database tracking, prevents database events from being sent to the client.\n\n# Command `Database.disable`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::database::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Database.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Database.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables database tracking, prevents database events from being sent to the client.\n\n# Command `Database.disable`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::database::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Database.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables database tracking, database events will now be delivered to the client.\n\n# Command `Database.enable`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::database::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Database.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Database.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables database tracking, database events will now be delivered to the client.\n\n# Command `Database.enable`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::database::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Database.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.executeSQL`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::ExecuteSqlCommand`](struct.ExecuteSqlCommand.html)  \n*Response Struct:* [`cdp::database::ExecuteSqlResponse`](struct.ExecuteSqlResponse.html)"]
    pub struct ExecuteSqlCommand<'a> {
        #[serde(rename = "databaseId")]
        pub database_id: ::database::DatabaseId<'a>,
        #[serde(rename = "query")]
        pub query: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ExecuteSqlCommand<'a> {
        const COMMAND_NAME: &'static str = "Database.executeSQL";
    }
    impl<'a> ::SerializeCdpCommand for ExecuteSqlCommand<'a> {
        fn command_name(&self) -> &str {
            "Database.executeSQL"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ExecuteSqlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.executeSQL" {
                Ok(
                    <ExecuteSqlCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.executeSQL`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::ExecuteSqlCommand`](struct.ExecuteSqlCommand.html)  \n*Response Struct:* [`cdp::database::ExecuteSqlResponse`](struct.ExecuteSqlResponse.html)"]
    pub struct ExecuteSqlResponse<'a> {
        #[serde(rename = "columnNames", skip_serializing_if = "Option::is_none")]
        pub column_names: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "values", skip_serializing_if = "Option::is_none")]
        pub values: Option<Vec<::serde_json::Value>>,
        #[serde(rename = "sqlError", skip_serializing_if = "Option::is_none")]
        pub sql_error: Option<::database::Error<'a>>,
    }
    impl<'a> ::CdpCommand for ExecuteSqlResponse<'a> {
        const COMMAND_NAME: &'static str = "Database.executeSQL";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ExecuteSqlCommand<'a> {
        type Response = ExecuteSqlResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ExecuteSqlResponse<'b> {
        type Command = ExecuteSqlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.getDatabaseTableNames`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::GetDatabaseTableNamesCommand`](struct.GetDatabaseTableNamesCommand.html)  \n*Response Struct:* [`cdp::database::GetDatabaseTableNamesResponse`](struct.GetDatabaseTableNamesResponse.html)"]
    pub struct GetDatabaseTableNamesCommand<'a> {
        #[serde(rename = "databaseId")]
        pub database_id: ::database::DatabaseId<'a>,
    }
    impl<'a> ::CdpCommand for GetDatabaseTableNamesCommand<'a> {
        const COMMAND_NAME: &'static str = "Database.getDatabaseTableNames";
    }
    impl<'a> ::SerializeCdpCommand for GetDatabaseTableNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "Database.getDatabaseTableNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetDatabaseTableNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.getDatabaseTableNames" {
                Ok ( < GetDatabaseTableNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Database.getDatabaseTableNames`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Command Struct:* [`cdp::database::GetDatabaseTableNamesCommand`](struct.GetDatabaseTableNamesCommand.html)  \n*Response Struct:* [`cdp::database::GetDatabaseTableNamesResponse`](struct.GetDatabaseTableNamesResponse.html)"]
    pub struct GetDatabaseTableNamesResponse<'a> {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetDatabaseTableNamesResponse<'a> {
        const COMMAND_NAME: &'static str = "Database.getDatabaseTableNames";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetDatabaseTableNamesCommand<'a> {
        type Response = GetDatabaseTableNamesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetDatabaseTableNamesResponse<'b> {
        type Command = GetDatabaseTableNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Database.addDatabase`\n\n*Domain Module:* [`cdp::database`](index.html)  \n*Event Struct:* [`cdp::database::AddDatabaseEvent`](struct.AddDatabaseEvent.html)"]
    pub struct AddDatabaseEvent<'a> {
        #[serde(rename = "database")]
        pub database: ::database::Database<'a>,
    }
    impl<'a> ::CdpEvent for AddDatabaseEvent<'a> {
        const EVENT_NAME: &'static str = "Database.addDatabase";
    }
    impl<'a> ::SerializeCdpEvent for AddDatabaseEvent<'a> {
        fn event_name(&self) -> &str {
            "Database.addDatabase"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AddDatabaseEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Database.addDatabase" {
                Ok(
                    <AddDatabaseEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of Database object."]
    pub type DatabaseId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database object."]
    pub struct Database<'a> {
        #[serde(rename = "id")]
        #[doc = "Database ID."]
        pub id: ::database::DatabaseId<'a>,
        #[serde(rename = "domain")]
        #[doc = "Database domain."]
        pub domain: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "Database name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Database version."]
        pub version: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database error."]
    pub struct Error<'a> {
        #[serde(rename = "message")]
        #[doc = "Error message."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "code")]
        #[doc = "Error code."]
        pub code: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# DeviceOrientation\n\n## Commands\n\n- [`DeviceOrientation.clearDeviceOrientationOverride`](struct.ClearDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears the overridden Device Orientation.\n- [`DeviceOrientation.setDeviceOrientationOverride`](struct.SetDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Overrides the Device Orientation.\n"]
pub mod device_orientation {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `DeviceOrientation.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::device_orientation`](index.html)  \n*Command Struct:* [`cdp::device_orientation::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::device_orientation::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideCommand;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearDeviceOrientationOverrideCommand {
        const COMMAND_NAME: &'static str = "DeviceOrientation.clearDeviceOrientationOverride";
    }
    impl ::SerializeCdpCommand for ClearDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "DeviceOrientation.clearDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DeviceOrientation.clearDeviceOrientationOverride" {
                Ok ( < ClearDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `DeviceOrientation.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::device_orientation`](index.html)  \n*Command Struct:* [`cdp::device_orientation::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::device_orientation::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    pub struct ClearDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearDeviceOrientationOverrideResponse {
        const COMMAND_NAME: &'static str = "DeviceOrientation.clearDeviceOrientationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearDeviceOrientationOverrideCommand {
        type Response = ClearDeviceOrientationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearDeviceOrientationOverrideResponse {
        type Command = ClearDeviceOrientationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `DeviceOrientation.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::device_orientation`](index.html)  \n*Command Struct:* [`cdp::device_orientation::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::device_orientation::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideCommand {
        #[serde(rename = "alpha")]
        #[doc = "Mock alpha"]
        pub alpha: f64,
        #[serde(rename = "beta")]
        #[doc = "Mock beta"]
        pub beta: f64,
        #[serde(rename = "gamma")]
        #[doc = "Mock gamma"]
        pub gamma: f64,
    }
    impl ::CdpCommand for SetDeviceOrientationOverrideCommand {
        const COMMAND_NAME: &'static str = "DeviceOrientation.setDeviceOrientationOverride";
    }
    impl ::SerializeCdpCommand for SetDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "DeviceOrientation.setDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "DeviceOrientation.setDeviceOrientationOverride" {
                Ok ( < SetDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `DeviceOrientation.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::device_orientation`](index.html)  \n*Command Struct:* [`cdp::device_orientation::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::device_orientation::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    pub struct SetDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for SetDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceOrientationOverrideResponse)
        }
    }
    impl ::CdpCommand for SetDeviceOrientationOverrideResponse {
        const COMMAND_NAME: &'static str = "DeviceOrientation.setDeviceOrientationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDeviceOrientationOverrideCommand {
        type Response = SetDeviceOrientationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDeviceOrientationOverrideResponse {
        type Command = SetDeviceOrientationOverrideCommand;
    }
}
#[doc = "This domain emulates different environments for the page.\n\n# Emulation\n\n## Commands\n\n- [`Emulation.canEmulate`](struct.CanEmulateCommand.html)\n\n  Tells whether emulation is supported.\n- [`Emulation.clearDeviceMetricsOverride`](struct.ClearDeviceMetricsOverrideCommand.html)\n\n  Clears the overriden device metrics.\n- [`Emulation.clearGeolocationOverride`](struct.ClearGeolocationOverrideCommand.html)\n\n  Clears the overriden Geolocation Position and Error.\n- [`Emulation.resetPageScaleFactor`](struct.ResetPageScaleFactorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that page scale factor is reset to initial values.\n- [`Emulation.setFocusEmulationEnabled`](struct.SetFocusEmulationEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables or disables simulating a focused and active page.\n- [`Emulation.setCPUThrottlingRate`](struct.SetCpuThrottlingRateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables CPU throttling to emulate slow CPUs.\n- [`Emulation.setDefaultBackgroundColorOverride`](struct.SetDefaultBackgroundColorOverrideCommand.html)\n\n  Sets or clears an override of the default background color of the frame. This override is used\n  if the content does not specify one.\n- [`Emulation.setDeviceMetricsOverride`](struct.SetDeviceMetricsOverrideCommand.html)\n\n  Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\n  window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\n  query results\\).\n- [`Emulation.setScrollbarsHidden`](struct.SetScrollbarsHiddenCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Emulation.setDocumentCookieDisabled`](struct.SetDocumentCookieDisabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Emulation.setEmitTouchEventsForMouse`](struct.SetEmitTouchEventsForMouseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Emulation.setEmulatedMedia`](struct.SetEmulatedMediaCommand.html)\n\n  Emulates the given media for CSS media queries.\n- [`Emulation.setGeolocationOverride`](struct.SetGeolocationOverrideCommand.html)\n\n  Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\n  unavailable.\n- [`Emulation.setNavigatorOverrides`](struct.SetNavigatorOverridesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Overrides value returned by the javascript navigator object.\n- [`Emulation.setPageScaleFactor`](struct.SetPageScaleFactorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets a specified page scale factor.\n- [`Emulation.setScriptExecutionDisabled`](struct.SetScriptExecutionDisabledCommand.html)\n\n  Switches script execution in the page.\n- [`Emulation.setTouchEmulationEnabled`](struct.SetTouchEmulationEnabledCommand.html)\n\n  Enables touch on platforms which do not support them.\n- [`Emulation.setVirtualTimePolicy`](struct.SetVirtualTimePolicyCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets\n  the current virtual time policy.  Note this supersedes any previous time budget.\n- [`Emulation.setVisibleSize`](struct.SetVisibleSizeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Resizes the frame/viewport of the page. Note that this does not affect the frame's container\n  \\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported\n  on Android.\n- [`Emulation.setUserAgentOverride`](struct.SetUserAgentOverrideCommand.html)\n\n  Allows overriding user agent with the given string.\n\n## Events\n\n- [`Emulation.virtualTimeAdvanced`](struct.VirtualTimeAdvancedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notification sent after the virtual time has advanced.\n- [`Emulation.virtualTimeBudgetExpired`](struct.VirtualTimeBudgetExpiredEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.\n- [`Emulation.virtualTimePaused`](struct.VirtualTimePausedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notification sent after the virtual time has paused.\n\n##Types\n\n- [`ScreenOrientation`](struct.ScreenOrientation.html)\n\n  Screen orientation.\n- [`VirtualTimePolicy`](enum.VirtualTimePolicy.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to\n  allow the next delayed task \\(if any\\) to run; pause: The virtual time base may not advance;\n  pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending\n  resource fetches.\n"]
pub mod emulation {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether emulation is supported.\n\n# Command `Emulation.canEmulate`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::CanEmulateCommand`](struct.CanEmulateCommand.html)  \n*Response Struct:* [`cdp::emulation::CanEmulateResponse`](struct.CanEmulateResponse.html)"]
    pub struct CanEmulateCommand;
    impl ::serde::Serialize for CanEmulateCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanEmulateCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanEmulateCommand)
        }
    }
    impl ::CdpCommand for CanEmulateCommand {
        const COMMAND_NAME: &'static str = "Emulation.canEmulate";
    }
    impl ::SerializeCdpCommand for CanEmulateCommand {
        fn command_name(&self) -> &str {
            "Emulation.canEmulate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CanEmulateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.canEmulate" {
                Ok(
                    <CanEmulateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether emulation is supported.\n\n# Command `Emulation.canEmulate`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::CanEmulateCommand`](struct.CanEmulateCommand.html)  \n*Response Struct:* [`cdp::emulation::CanEmulateResponse`](struct.CanEmulateResponse.html)"]
    pub struct CanEmulateResponse {
        #[serde(rename = "result")]
        #[doc = "True if emulation is supported."]
        pub result: bool,
    }
    impl ::CdpCommand for CanEmulateResponse {
        const COMMAND_NAME: &'static str = "Emulation.canEmulate";
    }
    impl<'b> ::HasCdpResponse<'b> for CanEmulateCommand {
        type Response = CanEmulateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CanEmulateResponse {
        type Command = CanEmulateCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden device metrics.\n\n# Command `Emulation.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideCommand;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearDeviceMetricsOverrideCommand {
        const COMMAND_NAME: &'static str = "Emulation.clearDeviceMetricsOverride";
    }
    impl ::SerializeCdpCommand for ClearDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.clearDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.clearDeviceMetricsOverride" {
                Ok ( < ClearDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden device metrics.\n\n# Command `Emulation.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    pub struct ClearDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearDeviceMetricsOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.clearDeviceMetricsOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearDeviceMetricsOverrideCommand {
        type Response = ClearDeviceMetricsOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearDeviceMetricsOverrideResponse {
        type Command = ClearDeviceMetricsOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Emulation.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideCommand;
    impl ::serde::Serialize for ClearGeolocationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearGeolocationOverrideCommand {
        const COMMAND_NAME: &'static str = "Emulation.clearGeolocationOverride";
    }
    impl ::SerializeCdpCommand for ClearGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.clearGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.clearGeolocationOverride" {
                Ok ( < ClearGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Emulation.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    pub struct ClearGeolocationOverrideResponse;
    impl ::serde::Serialize for ClearGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearGeolocationOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.clearGeolocationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearGeolocationOverrideCommand {
        type Response = ClearGeolocationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearGeolocationOverrideResponse {
        type Command = ClearGeolocationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that page scale factor is reset to initial values.\n\n# Command `Emulation.resetPageScaleFactor`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ResetPageScaleFactorCommand`](struct.ResetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::emulation::ResetPageScaleFactorResponse`](struct.ResetPageScaleFactorResponse.html)"]
    pub struct ResetPageScaleFactorCommand;
    impl ::serde::Serialize for ResetPageScaleFactorCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetPageScaleFactorCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetPageScaleFactorCommand)
        }
    }
    impl ::CdpCommand for ResetPageScaleFactorCommand {
        const COMMAND_NAME: &'static str = "Emulation.resetPageScaleFactor";
    }
    impl ::SerializeCdpCommand for ResetPageScaleFactorCommand {
        fn command_name(&self) -> &str {
            "Emulation.resetPageScaleFactor"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ResetPageScaleFactorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.resetPageScaleFactor" {
                Ok ( < ResetPageScaleFactorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that page scale factor is reset to initial values.\n\n# Command `Emulation.resetPageScaleFactor`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::ResetPageScaleFactorCommand`](struct.ResetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::emulation::ResetPageScaleFactorResponse`](struct.ResetPageScaleFactorResponse.html)"]
    pub struct ResetPageScaleFactorResponse;
    impl ::serde::Serialize for ResetPageScaleFactorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetPageScaleFactorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetPageScaleFactorResponse)
        }
    }
    impl ::CdpCommand for ResetPageScaleFactorResponse {
        const COMMAND_NAME: &'static str = "Emulation.resetPageScaleFactor";
    }
    impl<'b> ::HasCdpResponse<'b> for ResetPageScaleFactorCommand {
        type Response = ResetPageScaleFactorResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ResetPageScaleFactorResponse {
        type Command = ResetPageScaleFactorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables or disables simulating a focused and active page.\n\n# Command `Emulation.setFocusEmulationEnabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetFocusEmulationEnabledCommand`](struct.SetFocusEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetFocusEmulationEnabledResponse`](struct.SetFocusEmulationEnabledResponse.html)"]
    pub struct SetFocusEmulationEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether to enable to disable focus emulation."]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetFocusEmulationEnabledCommand {
        const COMMAND_NAME: &'static str = "Emulation.setFocusEmulationEnabled";
    }
    impl ::SerializeCdpCommand for SetFocusEmulationEnabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setFocusEmulationEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetFocusEmulationEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setFocusEmulationEnabled" {
                Ok ( < SetFocusEmulationEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables or disables simulating a focused and active page.\n\n# Command `Emulation.setFocusEmulationEnabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetFocusEmulationEnabledCommand`](struct.SetFocusEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetFocusEmulationEnabledResponse`](struct.SetFocusEmulationEnabledResponse.html)"]
    pub struct SetFocusEmulationEnabledResponse;
    impl ::serde::Serialize for SetFocusEmulationEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetFocusEmulationEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetFocusEmulationEnabledResponse)
        }
    }
    impl ::CdpCommand for SetFocusEmulationEnabledResponse {
        const COMMAND_NAME: &'static str = "Emulation.setFocusEmulationEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetFocusEmulationEnabledCommand {
        type Response = SetFocusEmulationEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetFocusEmulationEnabledResponse {
        type Command = SetFocusEmulationEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables CPU throttling to emulate slow CPUs.\n\n# Command `Emulation.setCPUThrottlingRate`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetCpuThrottlingRateCommand`](struct.SetCpuThrottlingRateCommand.html)  \n*Response Struct:* [`cdp::emulation::SetCpuThrottlingRateResponse`](struct.SetCpuThrottlingRateResponse.html)"]
    pub struct SetCpuThrottlingRateCommand {
        #[serde(rename = "rate")]
        #[doc = "Throttling rate as a slowdown factor \\(1 is no throttle, 2 is 2x slowdown, etc\\)."]
        pub rate: f64,
    }
    impl ::CdpCommand for SetCpuThrottlingRateCommand {
        const COMMAND_NAME: &'static str = "Emulation.setCPUThrottlingRate";
    }
    impl ::SerializeCdpCommand for SetCpuThrottlingRateCommand {
        fn command_name(&self) -> &str {
            "Emulation.setCPUThrottlingRate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetCpuThrottlingRateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setCPUThrottlingRate" {
                Ok ( < SetCpuThrottlingRateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables CPU throttling to emulate slow CPUs.\n\n# Command `Emulation.setCPUThrottlingRate`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetCpuThrottlingRateCommand`](struct.SetCpuThrottlingRateCommand.html)  \n*Response Struct:* [`cdp::emulation::SetCpuThrottlingRateResponse`](struct.SetCpuThrottlingRateResponse.html)"]
    pub struct SetCpuThrottlingRateResponse;
    impl ::serde::Serialize for SetCpuThrottlingRateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCpuThrottlingRateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCpuThrottlingRateResponse)
        }
    }
    impl ::CdpCommand for SetCpuThrottlingRateResponse {
        const COMMAND_NAME: &'static str = "Emulation.setCPUThrottlingRate";
    }
    impl<'b> ::HasCdpResponse<'b> for SetCpuThrottlingRateCommand {
        type Response = SetCpuThrottlingRateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetCpuThrottlingRateResponse {
        type Command = SetCpuThrottlingRateCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets or clears an override of the default background color of the frame. This override is used\nif the content does not specify one.\n\n# Command `Emulation.setDefaultBackgroundColorOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDefaultBackgroundColorOverrideCommand`](struct.SetDefaultBackgroundColorOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDefaultBackgroundColorOverrideResponse`](struct.SetDefaultBackgroundColorOverrideResponse.html)"]
    pub struct SetDefaultBackgroundColorOverrideCommand {
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "RGBA of the default background color. If not specified, any existing override will be\ncleared."]
        pub color: Option<::dom::Rgba>,
    }
    impl ::CdpCommand for SetDefaultBackgroundColorOverrideCommand {
        const COMMAND_NAME: &'static str = "Emulation.setDefaultBackgroundColorOverride";
    }
    impl ::SerializeCdpCommand for SetDefaultBackgroundColorOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setDefaultBackgroundColorOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDefaultBackgroundColorOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setDefaultBackgroundColorOverride" {
                Ok ( < SetDefaultBackgroundColorOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets or clears an override of the default background color of the frame. This override is used\nif the content does not specify one.\n\n# Command `Emulation.setDefaultBackgroundColorOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDefaultBackgroundColorOverrideCommand`](struct.SetDefaultBackgroundColorOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDefaultBackgroundColorOverrideResponse`](struct.SetDefaultBackgroundColorOverrideResponse.html)"]
    pub struct SetDefaultBackgroundColorOverrideResponse;
    impl ::serde::Serialize for SetDefaultBackgroundColorOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDefaultBackgroundColorOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDefaultBackgroundColorOverrideResponse)
        }
    }
    impl ::CdpCommand for SetDefaultBackgroundColorOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.setDefaultBackgroundColorOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDefaultBackgroundColorOverrideCommand {
        type Response = SetDefaultBackgroundColorOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDefaultBackgroundColorOverrideResponse {
        type Command = SetDefaultBackgroundColorOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results\\).\n\n# Command `Emulation.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideCommand {
        #[serde(rename = "width")]
        #[doc = "Overriding width value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Overriding height value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub height: i32,
        #[serde(rename = "deviceScaleFactor")]
        #[doc = "Overriding device scale factor value. 0 disables the override."]
        pub device_scale_factor: f64,
        #[serde(rename = "mobile")]
        #[doc = "Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text\nautosizing and more."]
        pub mobile: bool,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Scale to apply to resulting view image."]
        pub scale: Option<f64>,
        #[serde(rename = "screenWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding screen width value in pixels \\(minimum 0, maximum 10000000\\)."]
        pub screen_width: Option<i32>,
        #[serde(rename = "screenHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding screen height value in pixels \\(minimum 0, maximum 10000000\\)."]
        pub screen_height: Option<i32>,
        #[serde(rename = "positionX", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding view X position on screen in pixels \\(minimum 0, maximum 10000000\\)."]
        pub position_x: Option<i32>,
        #[serde(rename = "positionY", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overriding view Y position on screen in pixels \\(minimum 0, maximum 10000000\\)."]
        pub position_y: Option<i32>,
        #[serde(rename = "dontSetVisibleSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Do not set visible view size, rely upon explicit setVisibleSize call."]
        pub dont_set_visible_size: Option<bool>,
        #[serde(rename = "screenOrientation", skip_serializing_if = "Option::is_none")]
        #[doc = "Screen orientation override."]
        pub screen_orientation: Option<::emulation::ScreenOrientation>,
        #[serde(rename = "viewport", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> If set, the visible area of the page will be overridden to this viewport. This viewport\nchange is not observed by the page, e.g. viewport-relative elements do not change positions."]
        pub viewport: Option<::page::Viewport>,
    }
    impl ::CdpCommand for SetDeviceMetricsOverrideCommand {
        const COMMAND_NAME: &'static str = "Emulation.setDeviceMetricsOverride";
    }
    impl ::SerializeCdpCommand for SetDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setDeviceMetricsOverride" {
                Ok ( < SetDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results\\).\n\n# Command `Emulation.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    pub struct SetDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for SetDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceMetricsOverrideResponse)
        }
    }
    impl ::CdpCommand for SetDeviceMetricsOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.setDeviceMetricsOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDeviceMetricsOverrideCommand {
        type Response = SetDeviceMetricsOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDeviceMetricsOverrideResponse {
        type Command = SetDeviceMetricsOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setScrollbarsHidden`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetScrollbarsHiddenCommand`](struct.SetScrollbarsHiddenCommand.html)  \n*Response Struct:* [`cdp::emulation::SetScrollbarsHiddenResponse`](struct.SetScrollbarsHiddenResponse.html)"]
    pub struct SetScrollbarsHiddenCommand {
        #[serde(rename = "hidden")]
        #[doc = "Whether scrollbars should be always hidden."]
        pub hidden: bool,
    }
    impl ::CdpCommand for SetScrollbarsHiddenCommand {
        const COMMAND_NAME: &'static str = "Emulation.setScrollbarsHidden";
    }
    impl ::SerializeCdpCommand for SetScrollbarsHiddenCommand {
        fn command_name(&self) -> &str {
            "Emulation.setScrollbarsHidden"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetScrollbarsHiddenCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setScrollbarsHidden" {
                Ok ( < SetScrollbarsHiddenCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setScrollbarsHidden`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetScrollbarsHiddenCommand`](struct.SetScrollbarsHiddenCommand.html)  \n*Response Struct:* [`cdp::emulation::SetScrollbarsHiddenResponse`](struct.SetScrollbarsHiddenResponse.html)"]
    pub struct SetScrollbarsHiddenResponse;
    impl ::serde::Serialize for SetScrollbarsHiddenResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetScrollbarsHiddenResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetScrollbarsHiddenResponse)
        }
    }
    impl ::CdpCommand for SetScrollbarsHiddenResponse {
        const COMMAND_NAME: &'static str = "Emulation.setScrollbarsHidden";
    }
    impl<'b> ::HasCdpResponse<'b> for SetScrollbarsHiddenCommand {
        type Response = SetScrollbarsHiddenResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetScrollbarsHiddenResponse {
        type Command = SetScrollbarsHiddenCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setDocumentCookieDisabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDocumentCookieDisabledCommand`](struct.SetDocumentCookieDisabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDocumentCookieDisabledResponse`](struct.SetDocumentCookieDisabledResponse.html)"]
    pub struct SetDocumentCookieDisabledCommand {
        #[serde(rename = "disabled")]
        #[doc = "Whether document.coookie API should be disabled."]
        pub disabled: bool,
    }
    impl ::CdpCommand for SetDocumentCookieDisabledCommand {
        const COMMAND_NAME: &'static str = "Emulation.setDocumentCookieDisabled";
    }
    impl ::SerializeCdpCommand for SetDocumentCookieDisabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setDocumentCookieDisabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDocumentCookieDisabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setDocumentCookieDisabled" {
                Ok ( < SetDocumentCookieDisabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setDocumentCookieDisabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetDocumentCookieDisabledCommand`](struct.SetDocumentCookieDisabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetDocumentCookieDisabledResponse`](struct.SetDocumentCookieDisabledResponse.html)"]
    pub struct SetDocumentCookieDisabledResponse;
    impl ::serde::Serialize for SetDocumentCookieDisabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDocumentCookieDisabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDocumentCookieDisabledResponse)
        }
    }
    impl ::CdpCommand for SetDocumentCookieDisabledResponse {
        const COMMAND_NAME: &'static str = "Emulation.setDocumentCookieDisabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDocumentCookieDisabledCommand {
        type Response = SetDocumentCookieDisabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDocumentCookieDisabledResponse {
        type Command = SetDocumentCookieDisabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::emulation::SetEmitTouchEventsForMouseCommand::configuration`](struct.SetEmitTouchEventsForMouseCommand.html#structfield.configuration)."]
    pub enum SetEmitTouchEventsForMouseCommandConfiguration {
        #[serde(rename = "mobile")]
        #[doc = "Represented as `\"mobile\"`."]
        Mobile,
        #[serde(rename = "desktop")]
        #[doc = "Represented as `\"desktop\"`."]
        Desktop,
    }
    impl SetEmitTouchEventsForMouseCommandConfiguration {
        pub const ENUM_VALUES: &'static [SetEmitTouchEventsForMouseCommandConfiguration] =
            &[
                SetEmitTouchEventsForMouseCommandConfiguration::Mobile,
                SetEmitTouchEventsForMouseCommandConfiguration::Desktop,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["mobile", "desktop"];
    }
    impl ::std::str::FromStr for SetEmitTouchEventsForMouseCommandConfiguration {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mobile" => Ok(SetEmitTouchEventsForMouseCommandConfiguration::Mobile),
                "desktop" => Ok(SetEmitTouchEventsForMouseCommandConfiguration::Desktop),
                _ => Err(::ParseEnumError {
                    expected: SetEmitTouchEventsForMouseCommandConfiguration::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetEmitTouchEventsForMouseCommandConfiguration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetEmitTouchEventsForMouseCommandConfiguration::Mobile => "mobile",
                    SetEmitTouchEventsForMouseCommandConfiguration::Desktop => "desktop",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setEmitTouchEventsForMouse`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetEmitTouchEventsForMouseCommand`](struct.SetEmitTouchEventsForMouseCommand.html)  \n*Response Struct:* [`cdp::emulation::SetEmitTouchEventsForMouseResponse`](struct.SetEmitTouchEventsForMouseResponse.html)"]
    pub struct SetEmitTouchEventsForMouseCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether touch emulation based on mouse input should be enabled."]
        pub enabled: bool,
        #[serde(rename = "configuration", skip_serializing_if = "Option::is_none")]
        #[doc = "Touch/gesture events configuration. Default: current platform."]
        pub configuration:
            Option<::emulation::SetEmitTouchEventsForMouseCommandConfiguration>,
    }
    impl ::CdpCommand for SetEmitTouchEventsForMouseCommand {
        const COMMAND_NAME: &'static str = "Emulation.setEmitTouchEventsForMouse";
    }
    impl ::SerializeCdpCommand for SetEmitTouchEventsForMouseCommand {
        fn command_name(&self) -> &str {
            "Emulation.setEmitTouchEventsForMouse"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetEmitTouchEventsForMouseCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setEmitTouchEventsForMouse" {
                Ok ( < SetEmitTouchEventsForMouseCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Emulation.setEmitTouchEventsForMouse`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetEmitTouchEventsForMouseCommand`](struct.SetEmitTouchEventsForMouseCommand.html)  \n*Response Struct:* [`cdp::emulation::SetEmitTouchEventsForMouseResponse`](struct.SetEmitTouchEventsForMouseResponse.html)"]
    pub struct SetEmitTouchEventsForMouseResponse;
    impl ::serde::Serialize for SetEmitTouchEventsForMouseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEmitTouchEventsForMouseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEmitTouchEventsForMouseResponse)
        }
    }
    impl ::CdpCommand for SetEmitTouchEventsForMouseResponse {
        const COMMAND_NAME: &'static str = "Emulation.setEmitTouchEventsForMouse";
    }
    impl<'b> ::HasCdpResponse<'b> for SetEmitTouchEventsForMouseCommand {
        type Response = SetEmitTouchEventsForMouseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetEmitTouchEventsForMouseResponse {
        type Command = SetEmitTouchEventsForMouseCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Emulates the given media for CSS media queries.\n\n# Command `Emulation.setEmulatedMedia`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetEmulatedMediaCommand`](struct.SetEmulatedMediaCommand.html)  \n*Response Struct:* [`cdp::emulation::SetEmulatedMediaResponse`](struct.SetEmulatedMediaResponse.html)"]
    pub struct SetEmulatedMediaCommand<'a> {
        #[serde(rename = "media")]
        #[doc = "Media type to emulate. Empty string disables the override."]
        pub media: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetEmulatedMediaCommand<'a> {
        const COMMAND_NAME: &'static str = "Emulation.setEmulatedMedia";
    }
    impl<'a> ::SerializeCdpCommand for SetEmulatedMediaCommand<'a> {
        fn command_name(&self) -> &str {
            "Emulation.setEmulatedMedia"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetEmulatedMediaCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setEmulatedMedia" {
                Ok ( < SetEmulatedMediaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Emulates the given media for CSS media queries.\n\n# Command `Emulation.setEmulatedMedia`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetEmulatedMediaCommand`](struct.SetEmulatedMediaCommand.html)  \n*Response Struct:* [`cdp::emulation::SetEmulatedMediaResponse`](struct.SetEmulatedMediaResponse.html)"]
    pub struct SetEmulatedMediaResponse;
    impl ::serde::Serialize for SetEmulatedMediaResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetEmulatedMediaResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetEmulatedMediaResponse)
        }
    }
    impl ::CdpCommand for SetEmulatedMediaResponse {
        const COMMAND_NAME: &'static str = "Emulation.setEmulatedMedia";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetEmulatedMediaCommand<'a> {
        type Response = SetEmulatedMediaResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetEmulatedMediaResponse {
        type Command = SetEmulatedMediaCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n\n# Command `Emulation.setGeolocationOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideCommand {
        #[serde(rename = "latitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock latitude"]
        pub latitude: Option<f64>,
        #[serde(rename = "longitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock longitude"]
        pub longitude: Option<f64>,
        #[serde(rename = "accuracy", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock accuracy"]
        pub accuracy: Option<f64>,
    }
    impl ::CdpCommand for SetGeolocationOverrideCommand {
        const COMMAND_NAME: &'static str = "Emulation.setGeolocationOverride";
    }
    impl ::SerializeCdpCommand for SetGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Emulation.setGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setGeolocationOverride" {
                Ok ( < SetGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n\n# Command `Emulation.setGeolocationOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    pub struct SetGeolocationOverrideResponse;
    impl ::serde::Serialize for SetGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetGeolocationOverrideResponse)
        }
    }
    impl ::CdpCommand for SetGeolocationOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.setGeolocationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetGeolocationOverrideCommand {
        type Response = SetGeolocationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetGeolocationOverrideResponse {
        type Command = SetGeolocationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides value returned by the javascript navigator object.\n\n# Command `Emulation.setNavigatorOverrides`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetNavigatorOverridesCommand`](struct.SetNavigatorOverridesCommand.html)  \n*Response Struct:* [`cdp::emulation::SetNavigatorOverridesResponse`](struct.SetNavigatorOverridesResponse.html)"]
    #[deprecated]
    pub struct SetNavigatorOverridesCommand<'a> {
        #[serde(rename = "platform")]
        #[doc = "The platform navigator.platform should return."]
        pub platform: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetNavigatorOverridesCommand<'a> {
        const COMMAND_NAME: &'static str = "Emulation.setNavigatorOverrides";
    }
    impl<'a> ::SerializeCdpCommand for SetNavigatorOverridesCommand<'a> {
        fn command_name(&self) -> &str {
            "Emulation.setNavigatorOverrides"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetNavigatorOverridesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setNavigatorOverrides" {
                Ok ( < SetNavigatorOverridesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides value returned by the javascript navigator object.\n\n# Command `Emulation.setNavigatorOverrides`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetNavigatorOverridesCommand`](struct.SetNavigatorOverridesCommand.html)  \n*Response Struct:* [`cdp::emulation::SetNavigatorOverridesResponse`](struct.SetNavigatorOverridesResponse.html)"]
    #[deprecated]
    pub struct SetNavigatorOverridesResponse;
    impl ::serde::Serialize for SetNavigatorOverridesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetNavigatorOverridesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetNavigatorOverridesResponse)
        }
    }
    impl ::CdpCommand for SetNavigatorOverridesResponse {
        const COMMAND_NAME: &'static str = "Emulation.setNavigatorOverrides";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetNavigatorOverridesCommand<'a> {
        type Response = SetNavigatorOverridesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetNavigatorOverridesResponse {
        type Command = SetNavigatorOverridesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a specified page scale factor.\n\n# Command `Emulation.setPageScaleFactor`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetPageScaleFactorCommand`](struct.SetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::emulation::SetPageScaleFactorResponse`](struct.SetPageScaleFactorResponse.html)"]
    pub struct SetPageScaleFactorCommand {
        #[serde(rename = "pageScaleFactor")]
        #[doc = "Page scale factor."]
        pub page_scale_factor: f64,
    }
    impl ::CdpCommand for SetPageScaleFactorCommand {
        const COMMAND_NAME: &'static str = "Emulation.setPageScaleFactor";
    }
    impl ::SerializeCdpCommand for SetPageScaleFactorCommand {
        fn command_name(&self) -> &str {
            "Emulation.setPageScaleFactor"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetPageScaleFactorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setPageScaleFactor" {
                Ok ( < SetPageScaleFactorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets a specified page scale factor.\n\n# Command `Emulation.setPageScaleFactor`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetPageScaleFactorCommand`](struct.SetPageScaleFactorCommand.html)  \n*Response Struct:* [`cdp::emulation::SetPageScaleFactorResponse`](struct.SetPageScaleFactorResponse.html)"]
    pub struct SetPageScaleFactorResponse;
    impl ::serde::Serialize for SetPageScaleFactorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPageScaleFactorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPageScaleFactorResponse)
        }
    }
    impl ::CdpCommand for SetPageScaleFactorResponse {
        const COMMAND_NAME: &'static str = "Emulation.setPageScaleFactor";
    }
    impl<'b> ::HasCdpResponse<'b> for SetPageScaleFactorCommand {
        type Response = SetPageScaleFactorResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPageScaleFactorResponse {
        type Command = SetPageScaleFactorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Switches script execution in the page.\n\n# Command `Emulation.setScriptExecutionDisabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetScriptExecutionDisabledCommand`](struct.SetScriptExecutionDisabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetScriptExecutionDisabledResponse`](struct.SetScriptExecutionDisabledResponse.html)"]
    pub struct SetScriptExecutionDisabledCommand {
        #[serde(rename = "value")]
        #[doc = "Whether script execution should be disabled in the page."]
        pub value: bool,
    }
    impl ::CdpCommand for SetScriptExecutionDisabledCommand {
        const COMMAND_NAME: &'static str = "Emulation.setScriptExecutionDisabled";
    }
    impl ::SerializeCdpCommand for SetScriptExecutionDisabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setScriptExecutionDisabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetScriptExecutionDisabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setScriptExecutionDisabled" {
                Ok ( < SetScriptExecutionDisabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Switches script execution in the page.\n\n# Command `Emulation.setScriptExecutionDisabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetScriptExecutionDisabledCommand`](struct.SetScriptExecutionDisabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetScriptExecutionDisabledResponse`](struct.SetScriptExecutionDisabledResponse.html)"]
    pub struct SetScriptExecutionDisabledResponse;
    impl ::serde::Serialize for SetScriptExecutionDisabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetScriptExecutionDisabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetScriptExecutionDisabledResponse)
        }
    }
    impl ::CdpCommand for SetScriptExecutionDisabledResponse {
        const COMMAND_NAME: &'static str = "Emulation.setScriptExecutionDisabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetScriptExecutionDisabledCommand {
        type Response = SetScriptExecutionDisabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetScriptExecutionDisabledResponse {
        type Command = SetScriptExecutionDisabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables touch on platforms which do not support them.\n\n# Command `Emulation.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether the touch event emulation should be enabled."]
        pub enabled: bool,
        #[serde(rename = "maxTouchPoints", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum touch points supported. Defaults to one."]
        pub max_touch_points: Option<i32>,
    }
    impl ::CdpCommand for SetTouchEmulationEnabledCommand {
        const COMMAND_NAME: &'static str = "Emulation.setTouchEmulationEnabled";
    }
    impl ::SerializeCdpCommand for SetTouchEmulationEnabledCommand {
        fn command_name(&self) -> &str {
            "Emulation.setTouchEmulationEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetTouchEmulationEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setTouchEmulationEnabled" {
                Ok ( < SetTouchEmulationEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables touch on platforms which do not support them.\n\n# Command `Emulation.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::emulation::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    pub struct SetTouchEmulationEnabledResponse;
    impl ::serde::Serialize for SetTouchEmulationEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTouchEmulationEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTouchEmulationEnabledResponse)
        }
    }
    impl ::CdpCommand for SetTouchEmulationEnabledResponse {
        const COMMAND_NAME: &'static str = "Emulation.setTouchEmulationEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetTouchEmulationEnabledCommand {
        type Response = SetTouchEmulationEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetTouchEmulationEnabledResponse {
        type Command = SetTouchEmulationEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets\nthe current virtual time policy.  Note this supersedes any previous time budget.\n\n# Command `Emulation.setVirtualTimePolicy`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetVirtualTimePolicyCommand`](struct.SetVirtualTimePolicyCommand.html)  \n*Response Struct:* [`cdp::emulation::SetVirtualTimePolicyResponse`](struct.SetVirtualTimePolicyResponse.html)"]
    pub struct SetVirtualTimePolicyCommand {
        #[serde(rename = "policy")]
        pub policy: ::emulation::VirtualTimePolicy,
        #[serde(rename = "budget", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, after this many virtual milliseconds have elapsed virtual time will be paused and a\nvirtualTimeBudgetExpired event is sent."]
        pub budget: Option<f64>,
        #[serde(rename = "maxVirtualTimeTaskStarvationCount",
                skip_serializing_if = "Option::is_none")]
        #[doc = "If set this specifies the maximum number of tasks that can be run before virtual is forced\nforwards to prevent deadlock."]
        pub max_virtual_time_task_starvation_count: Option<i32>,
        #[serde(rename = "waitForNavigation", skip_serializing_if = "Option::is_none")]
        #[doc = "If set the virtual time policy change should be deferred until any frame starts navigating.\nNote any previous deferred policy change is superseded."]
        pub wait_for_navigation: Option<bool>,
        #[serde(rename = "initialVirtualTime", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, base::Time::Now will be overriden to initially return this value."]
        pub initial_virtual_time: Option<::network::TimeSinceEpoch>,
    }
    impl ::CdpCommand for SetVirtualTimePolicyCommand {
        const COMMAND_NAME: &'static str = "Emulation.setVirtualTimePolicy";
    }
    impl ::SerializeCdpCommand for SetVirtualTimePolicyCommand {
        fn command_name(&self) -> &str {
            "Emulation.setVirtualTimePolicy"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetVirtualTimePolicyCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setVirtualTimePolicy" {
                Ok ( < SetVirtualTimePolicyCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Turns on virtual time for all frames \\(replacing real-time with a synthetic time source\\) and sets\nthe current virtual time policy.  Note this supersedes any previous time budget.\n\n# Command `Emulation.setVirtualTimePolicy`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetVirtualTimePolicyCommand`](struct.SetVirtualTimePolicyCommand.html)  \n*Response Struct:* [`cdp::emulation::SetVirtualTimePolicyResponse`](struct.SetVirtualTimePolicyResponse.html)"]
    pub struct SetVirtualTimePolicyResponse {
        #[serde(rename = "virtualTimeTicksBase")]
        #[doc = "Absolute timestamp at which virtual time was first enabled \\(up time in milliseconds\\)."]
        pub virtual_time_ticks_base: f64,
    }
    impl ::CdpCommand for SetVirtualTimePolicyResponse {
        const COMMAND_NAME: &'static str = "Emulation.setVirtualTimePolicy";
    }
    impl<'b> ::HasCdpResponse<'b> for SetVirtualTimePolicyCommand {
        type Response = SetVirtualTimePolicyResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetVirtualTimePolicyResponse {
        type Command = SetVirtualTimePolicyCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Resizes the frame/viewport of the page. Note that this does not affect the frame's container\n\\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported\non Android.\n\n# Command `Emulation.setVisibleSize`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetVisibleSizeCommand`](struct.SetVisibleSizeCommand.html)  \n*Response Struct:* [`cdp::emulation::SetVisibleSizeResponse`](struct.SetVisibleSizeResponse.html)"]
    #[deprecated]
    pub struct SetVisibleSizeCommand {
        #[serde(rename = "width")]
        #[doc = "Frame width \\(DIP\\)."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Frame height \\(DIP\\)."]
        pub height: i32,
    }
    impl ::CdpCommand for SetVisibleSizeCommand {
        const COMMAND_NAME: &'static str = "Emulation.setVisibleSize";
    }
    impl ::SerializeCdpCommand for SetVisibleSizeCommand {
        fn command_name(&self) -> &str {
            "Emulation.setVisibleSize"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetVisibleSizeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setVisibleSize" {
                Ok(
                    <SetVisibleSizeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Resizes the frame/viewport of the page. Note that this does not affect the frame's container\n\\(e.g. browser window\\). Can be used to produce screenshots of the specified size. Not supported\non Android.\n\n# Command `Emulation.setVisibleSize`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetVisibleSizeCommand`](struct.SetVisibleSizeCommand.html)  \n*Response Struct:* [`cdp::emulation::SetVisibleSizeResponse`](struct.SetVisibleSizeResponse.html)"]
    #[deprecated]
    pub struct SetVisibleSizeResponse;
    impl ::serde::Serialize for SetVisibleSizeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetVisibleSizeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetVisibleSizeResponse)
        }
    }
    impl ::CdpCommand for SetVisibleSizeResponse {
        const COMMAND_NAME: &'static str = "Emulation.setVisibleSize";
    }
    impl<'b> ::HasCdpResponse<'b> for SetVisibleSizeCommand {
        type Response = SetVisibleSizeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetVisibleSizeResponse {
        type Command = SetVisibleSizeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Emulation.setUserAgentOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideCommand<'a> {
        #[serde(rename = "userAgent")]
        #[doc = "User agent to use."]
        pub user_agent: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "acceptLanguage", skip_serializing_if = "Option::is_none")]
        #[doc = "Browser langugage to emulate."]
        pub accept_language: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "platform", skip_serializing_if = "Option::is_none")]
        #[doc = "The platform navigator.platform should return."]
        pub platform: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetUserAgentOverrideCommand<'a> {
        const COMMAND_NAME: &'static str = "Emulation.setUserAgentOverride";
    }
    impl<'a> ::SerializeCdpCommand for SetUserAgentOverrideCommand<'a> {
        fn command_name(&self) -> &str {
            "Emulation.setUserAgentOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetUserAgentOverrideCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.setUserAgentOverride" {
                Ok ( < SetUserAgentOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Emulation.setUserAgentOverride`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Command Struct:* [`cdp::emulation::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::emulation::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideResponse;
    impl ::serde::Serialize for SetUserAgentOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetUserAgentOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetUserAgentOverrideResponse)
        }
    }
    impl ::CdpCommand for SetUserAgentOverrideResponse {
        const COMMAND_NAME: &'static str = "Emulation.setUserAgentOverride";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetUserAgentOverrideCommand<'a> {
        type Response = SetUserAgentOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetUserAgentOverrideResponse {
        type Command = SetUserAgentOverrideCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notification sent after the virtual time has advanced.\n\n# Event `Emulation.virtualTimeAdvanced`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Event Struct:* [`cdp::emulation::VirtualTimeAdvancedEvent`](struct.VirtualTimeAdvancedEvent.html)"]
    pub struct VirtualTimeAdvancedEvent {
        #[serde(rename = "virtualTimeElapsed")]
        #[doc = "The amount of virtual time that has elapsed in milliseconds since virtual time was first\nenabled."]
        pub virtual_time_elapsed: f64,
    }
    impl ::CdpEvent for VirtualTimeAdvancedEvent {
        const EVENT_NAME: &'static str = "Emulation.virtualTimeAdvanced";
    }
    impl ::SerializeCdpEvent for VirtualTimeAdvancedEvent {
        fn event_name(&self) -> &str {
            "Emulation.virtualTimeAdvanced"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for VirtualTimeAdvancedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.virtualTimeAdvanced" {
                Ok ( < VirtualTimeAdvancedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.\n\n# Event `Emulation.virtualTimeBudgetExpired`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Event Struct:* [`cdp::emulation::VirtualTimeBudgetExpiredEvent`](struct.VirtualTimeBudgetExpiredEvent.html)"]
    pub struct VirtualTimeBudgetExpiredEvent;
    impl ::serde::Serialize for VirtualTimeBudgetExpiredEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for VirtualTimeBudgetExpiredEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| VirtualTimeBudgetExpiredEvent)
        }
    }
    impl ::CdpEvent for VirtualTimeBudgetExpiredEvent {
        const EVENT_NAME: &'static str = "Emulation.virtualTimeBudgetExpired";
    }
    impl ::SerializeCdpEvent for VirtualTimeBudgetExpiredEvent {
        fn event_name(&self) -> &str {
            "Emulation.virtualTimeBudgetExpired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for VirtualTimeBudgetExpiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.virtualTimeBudgetExpired" {
                Ok ( < VirtualTimeBudgetExpiredEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notification sent after the virtual time has paused.\n\n# Event `Emulation.virtualTimePaused`\n\n*Domain Module:* [`cdp::emulation`](index.html)  \n*Event Struct:* [`cdp::emulation::VirtualTimePausedEvent`](struct.VirtualTimePausedEvent.html)"]
    pub struct VirtualTimePausedEvent {
        #[serde(rename = "virtualTimeElapsed")]
        #[doc = "The amount of virtual time that has elapsed in milliseconds since virtual time was first\nenabled."]
        pub virtual_time_elapsed: f64,
    }
    impl ::CdpEvent for VirtualTimePausedEvent {
        const EVENT_NAME: &'static str = "Emulation.virtualTimePaused";
    }
    impl ::SerializeCdpEvent for VirtualTimePausedEvent {
        fn event_name(&self) -> &str {
            "Emulation.virtualTimePaused"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for VirtualTimePausedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Emulation.virtualTimePaused" {
                Ok(
                    <VirtualTimePausedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::emulation::ScreenOrientation::ty`](struct.ScreenOrientation.html#structfield.ty)."]
    pub enum ScreenOrientationType {
        #[serde(rename = "portraitPrimary")]
        #[doc = "Represented as `\"portraitPrimary\"`."]
        PortraitPrimary,
        #[serde(rename = "portraitSecondary")]
        #[doc = "Represented as `\"portraitSecondary\"`."]
        PortraitSecondary,
        #[serde(rename = "landscapePrimary")]
        #[doc = "Represented as `\"landscapePrimary\"`."]
        LandscapePrimary,
        #[serde(rename = "landscapeSecondary")]
        #[doc = "Represented as `\"landscapeSecondary\"`."]
        LandscapeSecondary,
    }
    impl ScreenOrientationType {
        pub const ENUM_VALUES: &'static [ScreenOrientationType] =
            &[
                ScreenOrientationType::PortraitPrimary,
                ScreenOrientationType::PortraitSecondary,
                ScreenOrientationType::LandscapePrimary,
                ScreenOrientationType::LandscapeSecondary,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "portraitPrimary",
            "portraitSecondary",
            "landscapePrimary",
            "landscapeSecondary",
        ];
    }
    impl ::std::str::FromStr for ScreenOrientationType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "portraitPrimary" => Ok(ScreenOrientationType::PortraitPrimary),
                "portraitSecondary" => Ok(ScreenOrientationType::PortraitSecondary),
                "landscapePrimary" => Ok(ScreenOrientationType::LandscapePrimary),
                "landscapeSecondary" => Ok(ScreenOrientationType::LandscapeSecondary),
                _ => Err(::ParseEnumError {
                    expected: ScreenOrientationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScreenOrientationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScreenOrientationType::PortraitPrimary => "portraitPrimary",
                    ScreenOrientationType::PortraitSecondary => "portraitSecondary",
                    ScreenOrientationType::LandscapePrimary => "landscapePrimary",
                    ScreenOrientationType::LandscapeSecondary => "landscapeSecondary",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Screen orientation."]
    pub struct ScreenOrientation {
        #[serde(rename = "type")]
        #[doc = "Orientation type."]
        pub ty: ::emulation::ScreenOrientationType,
        #[serde(rename = "angle")]
        #[doc = "Orientation angle."]
        pub angle: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to\nallow the next delayed task \\(if any\\) to run; pause: The virtual time base may not advance;\npauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending\nresource fetches."]
    pub enum VirtualTimePolicy {
        #[serde(rename = "advance")]
        #[doc = "Represented as `\"advance\"`."]
        Advance,
        #[serde(rename = "pause")]
        #[doc = "Represented as `\"pause\"`."]
        Pause,
        #[serde(rename = "pauseIfNetworkFetchesPending")]
        #[doc = "Represented as `\"pauseIfNetworkFetchesPending\"`."]
        PauseIfNetworkFetchesPending,
    }
    impl VirtualTimePolicy {
        pub const ENUM_VALUES: &'static [VirtualTimePolicy] =
            &[
                VirtualTimePolicy::Advance,
                VirtualTimePolicy::Pause,
                VirtualTimePolicy::PauseIfNetworkFetchesPending,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["advance", "pause", "pauseIfNetworkFetchesPending"];
    }
    impl ::std::str::FromStr for VirtualTimePolicy {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "advance" => Ok(VirtualTimePolicy::Advance),
                "pause" => Ok(VirtualTimePolicy::Pause),
                "pauseIfNetworkFetchesPending" => {
                    Ok(VirtualTimePolicy::PauseIfNetworkFetchesPending)
                }
                _ => Err(::ParseEnumError {
                    expected: VirtualTimePolicy::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for VirtualTimePolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    VirtualTimePolicy::Advance => "advance",
                    VirtualTimePolicy::Pause => "pause",
                    VirtualTimePolicy::PauseIfNetworkFetchesPending => {
                        "pauseIfNetworkFetchesPending"
                    }
                }
            )
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain provides experimental commands only supported in headless mode.\n\n# HeadlessExperimental\n\n## Commands\n\n- [`HeadlessExperimental.beginFrame`](struct.BeginFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a\n  screenshot from the resulting frame. Requires that the target was created with enabled\n  BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also\n  https://goo.gl/3zHXhB for more background.\n- [`HeadlessExperimental.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables headless events for the target.\n- [`HeadlessExperimental.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables headless events for the target.\n\n## Events\n\n- [`HeadlessExperimental.needsBeginFramesChanged`](struct.NeedsBeginFramesChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when the target starts or stops needing BeginFrames.\n\n##Types\n\n- [`ScreenshotParams`](struct.ScreenshotParams.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Encoding options for a screenshot.\n"]
pub mod headless_experimental {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a\nscreenshot from the resulting frame. Requires that the target was created with enabled\nBeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also\nhttps://goo.gl/3zHXhB for more background.\n\n# Command `HeadlessExperimental.beginFrame`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::BeginFrameCommand`](struct.BeginFrameCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::BeginFrameResponse`](struct.BeginFrameResponse.html)"]
    pub struct BeginFrameCommand {
        #[serde(rename = "frameTimeTicks", skip_serializing_if = "Option::is_none")]
        #[doc = "Timestamp of this BeginFrame in Renderer TimeTicks \\(milliseconds of uptime\\). If not set,\nthe current time will be used."]
        pub frame_time_ticks: Option<f64>,
        #[serde(rename = "interval", skip_serializing_if = "Option::is_none")]
        #[doc = "The interval between BeginFrames that is reported to the compositor, in milliseconds.\nDefaults to a 60 frames/second interval, i.e. about 16.666 milliseconds."]
        pub interval: Option<f64>,
        #[serde(rename = "noDisplayUpdates", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether updates should not be committed and drawn onto the display. False by default. If\ntrue, only side effects of the BeginFrame will be run, such as layout and animations, but\nany visual updates may not be visible on the display or in screenshots."]
        pub no_display_updates: Option<bool>,
        #[serde(rename = "screenshot", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, a screenshot of the frame will be captured and returned in the response. Otherwise,\nno screenshot will be captured. Note that capturing a screenshot can fail, for example,\nduring renderer initialization. In such a case, no screenshot data will be returned."]
        pub screenshot: Option<::headless_experimental::ScreenshotParams>,
    }
    impl ::CdpCommand for BeginFrameCommand {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.beginFrame";
    }
    impl ::SerializeCdpCommand for BeginFrameCommand {
        fn command_name(&self) -> &str {
            "HeadlessExperimental.beginFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for BeginFrameCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeadlessExperimental.beginFrame" {
                Ok(
                    <BeginFrameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a\nscreenshot from the resulting frame. Requires that the target was created with enabled\nBeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also\nhttps://goo.gl/3zHXhB for more background.\n\n# Command `HeadlessExperimental.beginFrame`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::BeginFrameCommand`](struct.BeginFrameCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::BeginFrameResponse`](struct.BeginFrameResponse.html)"]
    pub struct BeginFrameResponse<'a> {
        #[serde(rename = "hasDamage")]
        #[doc = "Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the\ndisplay. Reported for diagnostic uses, may be removed in the future."]
        pub has_damage: bool,
        #[serde(rename = "screenshotData", skip_serializing_if = "Option::is_none")]
        #[doc = "Base64-encoded image data of the screenshot, if one was requested and successfully taken."]
        pub screenshot_data: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for BeginFrameResponse<'a> {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.beginFrame";
    }
    impl<'b> ::HasCdpResponse<'b> for BeginFrameCommand {
        type Response = BeginFrameResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for BeginFrameResponse<'b> {
        type Command = BeginFrameCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables headless events for the target.\n\n# Command `HeadlessExperimental.disable`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "HeadlessExperimental.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeadlessExperimental.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables headless events for the target.\n\n# Command `HeadlessExperimental.disable`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables headless events for the target.\n\n# Command `HeadlessExperimental.enable`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "HeadlessExperimental.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeadlessExperimental.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables headless events for the target.\n\n# Command `HeadlessExperimental.enable`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Command Struct:* [`cdp::headless_experimental::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::headless_experimental::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "HeadlessExperimental.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when the target starts or stops needing BeginFrames.\n\n# Event `HeadlessExperimental.needsBeginFramesChanged`\n\n*Domain Module:* [`cdp::headless_experimental`](index.html)  \n*Event Struct:* [`cdp::headless_experimental::NeedsBeginFramesChangedEvent`](struct.NeedsBeginFramesChangedEvent.html)"]
    pub struct NeedsBeginFramesChangedEvent {
        #[serde(rename = "needsBeginFrames")]
        #[doc = "True if BeginFrames are needed, false otherwise."]
        pub needs_begin_frames: bool,
    }
    impl ::CdpEvent for NeedsBeginFramesChangedEvent {
        const EVENT_NAME: &'static str = "HeadlessExperimental.needsBeginFramesChanged";
    }
    impl ::SerializeCdpEvent for NeedsBeginFramesChangedEvent {
        fn event_name(&self) -> &str {
            "HeadlessExperimental.needsBeginFramesChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for NeedsBeginFramesChangedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeadlessExperimental.needsBeginFramesChanged" {
                Ok ( < NeedsBeginFramesChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::headless_experimental::ScreenshotParams::format`](struct.ScreenshotParams.html#structfield.format)."]
    pub enum ScreenshotParamsFormat {
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl ScreenshotParamsFormat {
        pub const ENUM_VALUES: &'static [ScreenshotParamsFormat] =
            &[ScreenshotParamsFormat::Jpeg, ScreenshotParamsFormat::Png];
        pub const STR_VALUES: &'static [&'static str] = &["jpeg", "png"];
    }
    impl ::std::str::FromStr for ScreenshotParamsFormat {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "jpeg" => Ok(ScreenshotParamsFormat::Jpeg),
                "png" => Ok(ScreenshotParamsFormat::Png),
                _ => Err(::ParseEnumError {
                    expected: ScreenshotParamsFormat::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScreenshotParamsFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScreenshotParamsFormat::Jpeg => "jpeg",
                    ScreenshotParamsFormat::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Encoding options for a screenshot."]
    pub struct ScreenshotParams {
        #[serde(rename = "format", skip_serializing_if = "Option::is_none")]
        #[doc = "Image compression format \\(defaults to png\\)."]
        pub format: Option<::headless_experimental::ScreenshotParamsFormat>,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression quality from range \\[0..100\\] \\(jpeg only\\)."]
        pub quality: Option<i32>,
    }
}
#[doc = "Input/Output operations for streams produced by DevTools.\n\n# IO\n\n## Commands\n\n- [`IO.close`](struct.CloseCommand.html)\n\n  Close the stream, discard any temporary backing storage.\n- [`IO.read`](struct.ReadCommand.html)\n\n  Read a chunk of the stream\n- [`IO.resolveBlob`](struct.ResolveBlobCommand.html)\n\n  Return UUID of Blob object specified by a remote object id.\n\n##Types\n\n- [`StreamHandle`](type.StreamHandle.html)\n\n  This is either obtained from another method or specifed as `blob:&lt;uuid&gt;` where\n  `&lt;uuid&gt` is an UUID of a Blob.\n"]
pub mod io {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Close the stream, discard any temporary backing storage.\n\n# Command `IO.close`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::io::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseCommand<'a> {
        #[serde(rename = "handle")]
        #[doc = "Handle of the stream to close."]
        pub handle: ::io::StreamHandle<'a>,
    }
    impl<'a> ::CdpCommand for CloseCommand<'a> {
        const COMMAND_NAME: &'static str = "IO.close";
    }
    impl<'a> ::SerializeCdpCommand for CloseCommand<'a> {
        fn command_name(&self) -> &str {
            "IO.close"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CloseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IO.close" {
                Ok(
                    <CloseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Close the stream, discard any temporary backing storage.\n\n# Command `IO.close`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::io::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseResponse;
    impl ::serde::Serialize for CloseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CloseResponse)
        }
    }
    impl ::CdpCommand for CloseResponse {
        const COMMAND_NAME: &'static str = "IO.close";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CloseCommand<'a> {
        type Response = CloseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CloseResponse {
        type Command = CloseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Read a chunk of the stream\n\n# Command `IO.read`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::ReadCommand`](struct.ReadCommand.html)  \n*Response Struct:* [`cdp::io::ReadResponse`](struct.ReadResponse.html)"]
    pub struct ReadCommand<'a> {
        #[serde(rename = "handle")]
        #[doc = "Handle of the stream to read."]
        pub handle: ::io::StreamHandle<'a>,
        #[serde(rename = "offset", skip_serializing_if = "Option::is_none")]
        #[doc = "Seek to the specified offset before reading \\(if not specificed, proceed with offset\nfollowing the last read\\). Some types of streams may only support sequential reads."]
        pub offset: Option<i32>,
        #[serde(rename = "size", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum number of bytes to read \\(left upon the agent discretion if not specified\\)."]
        pub size: Option<i32>,
    }
    impl<'a> ::CdpCommand for ReadCommand<'a> {
        const COMMAND_NAME: &'static str = "IO.read";
    }
    impl<'a> ::SerializeCdpCommand for ReadCommand<'a> {
        fn command_name(&self) -> &str {
            "IO.read"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IO.read" {
                Ok(
                    <ReadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Read a chunk of the stream\n\n# Command `IO.read`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::ReadCommand`](struct.ReadCommand.html)  \n*Response Struct:* [`cdp::io::ReadResponse`](struct.ReadResponse.html)"]
    pub struct ReadResponse<'a> {
        #[serde(rename = "base64Encoded", skip_serializing_if = "Option::is_none")]
        #[doc = "Set if the data is base64-encoded"]
        pub base_64_encoded: Option<bool>,
        #[serde(rename = "data")]
        #[doc = "Data that were read."]
        pub data: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "eof")]
        #[doc = "Set if the end-of-file condition occured while reading."]
        pub eof: bool,
    }
    impl<'a> ::CdpCommand for ReadResponse<'a> {
        const COMMAND_NAME: &'static str = "IO.read";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReadCommand<'a> {
        type Response = ReadResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ReadResponse<'b> {
        type Command = ReadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Return UUID of Blob object specified by a remote object id.\n\n# Command `IO.resolveBlob`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::ResolveBlobCommand`](struct.ResolveBlobCommand.html)  \n*Response Struct:* [`cdp::io::ResolveBlobResponse`](struct.ResolveBlobResponse.html)"]
    pub struct ResolveBlobCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Object id of a Blob object wrapper."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::CdpCommand for ResolveBlobCommand<'a> {
        const COMMAND_NAME: &'static str = "IO.resolveBlob";
    }
    impl<'a> ::SerializeCdpCommand for ResolveBlobCommand<'a> {
        fn command_name(&self) -> &str {
            "IO.resolveBlob"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ResolveBlobCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IO.resolveBlob" {
                Ok(
                    <ResolveBlobCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Return UUID of Blob object specified by a remote object id.\n\n# Command `IO.resolveBlob`\n\n*Domain Module:* [`cdp::io`](index.html)  \n*Command Struct:* [`cdp::io::ResolveBlobCommand`](struct.ResolveBlobCommand.html)  \n*Response Struct:* [`cdp::io::ResolveBlobResponse`](struct.ResolveBlobResponse.html)"]
    pub struct ResolveBlobResponse<'a> {
        #[serde(rename = "uuid")]
        #[doc = "UUID of the specified Blob."]
        pub uuid: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ResolveBlobResponse<'a> {
        const COMMAND_NAME: &'static str = "IO.resolveBlob";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ResolveBlobCommand<'a> {
        type Response = ResolveBlobResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ResolveBlobResponse<'b> {
        type Command = ResolveBlobCommand<'a>;
    }
    #[doc = "This is either obtained from another method or specifed as `blob:&lt;uuid&gt;` where\n`&lt;uuid&gt` is an UUID of a Blob."]
    pub type StreamHandle<'a> = ::std::borrow::Cow<'a, str>;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# IndexedDB\n\n## Commands\n\n- [`IndexedDB.clearObjectStore`](struct.ClearObjectStoreCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears all entries from an object store.\n- [`IndexedDB.deleteDatabase`](struct.DeleteDatabaseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a database.\n- [`IndexedDB.deleteObjectStoreEntries`](struct.DeleteObjectStoreEntriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Delete a range of entries from an object store\n- [`IndexedDB.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables events from backend.\n- [`IndexedDB.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables events from backend.\n- [`IndexedDB.requestData`](struct.RequestDataCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests data from object store or index.\n- [`IndexedDB.requestDatabase`](struct.RequestDatabaseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests database with given name in given frame.\n- [`IndexedDB.requestDatabaseNames`](struct.RequestDatabaseNamesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests database names for given security origin.\n\n##Types\n\n- [`DatabaseWithObjectStores`](struct.DatabaseWithObjectStores.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Database with an array of object stores.\n- [`ObjectStore`](struct.ObjectStore.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object store.\n- [`ObjectStoreIndex`](struct.ObjectStoreIndex.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object store index.\n- [`Key`](struct.Key.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key.\n- [`KeyRange`](struct.KeyRange.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key range.\n- [`DataEntry`](struct.DataEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Data entry.\n- [`KeyPath`](struct.KeyPath.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Key path.\n"]
pub mod indexed_db {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears all entries from an object store.\n\n# Command `IndexedDB.clearObjectStore`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::ClearObjectStoreCommand`](struct.ClearObjectStoreCommand.html)  \n*Response Struct:* [`cdp::indexed_db::ClearObjectStoreResponse`](struct.ClearObjectStoreResponse.html)"]
    pub struct ClearObjectStoreCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        #[doc = "Object store name."]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ClearObjectStoreCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.clearObjectStore";
    }
    impl<'a> ::SerializeCdpCommand for ClearObjectStoreCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.clearObjectStore"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ClearObjectStoreCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.clearObjectStore" {
                Ok ( < ClearObjectStoreCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears all entries from an object store.\n\n# Command `IndexedDB.clearObjectStore`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::ClearObjectStoreCommand`](struct.ClearObjectStoreCommand.html)  \n*Response Struct:* [`cdp::indexed_db::ClearObjectStoreResponse`](struct.ClearObjectStoreResponse.html)"]
    pub struct ClearObjectStoreResponse;
    impl ::serde::Serialize for ClearObjectStoreResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearObjectStoreResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearObjectStoreResponse)
        }
    }
    impl ::CdpCommand for ClearObjectStoreResponse {
        const COMMAND_NAME: &'static str = "IndexedDB.clearObjectStore";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ClearObjectStoreCommand<'a> {
        type Response = ClearObjectStoreResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearObjectStoreResponse {
        type Command = ClearObjectStoreCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a database.\n\n# Command `IndexedDB.deleteDatabase`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DeleteDatabaseCommand`](struct.DeleteDatabaseCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DeleteDatabaseResponse`](struct.DeleteDatabaseResponse.html)"]
    pub struct DeleteDatabaseCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for DeleteDatabaseCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.deleteDatabase";
    }
    impl<'a> ::SerializeCdpCommand for DeleteDatabaseCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.deleteDatabase"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteDatabaseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.deleteDatabase" {
                Ok(
                    <DeleteDatabaseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a database.\n\n# Command `IndexedDB.deleteDatabase`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DeleteDatabaseCommand`](struct.DeleteDatabaseCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DeleteDatabaseResponse`](struct.DeleteDatabaseResponse.html)"]
    pub struct DeleteDatabaseResponse;
    impl ::serde::Serialize for DeleteDatabaseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteDatabaseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteDatabaseResponse)
        }
    }
    impl ::CdpCommand for DeleteDatabaseResponse {
        const COMMAND_NAME: &'static str = "IndexedDB.deleteDatabase";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteDatabaseCommand<'a> {
        type Response = DeleteDatabaseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteDatabaseResponse {
        type Command = DeleteDatabaseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Delete a range of entries from an object store\n\n# Command `IndexedDB.deleteObjectStoreEntries`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DeleteObjectStoreEntriesCommand`](struct.DeleteObjectStoreEntriesCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DeleteObjectStoreEntriesResponse`](struct.DeleteObjectStoreEntriesResponse.html)"]
    pub struct DeleteObjectStoreEntriesCommand<'a> {
        #[serde(rename = "securityOrigin")]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyRange")]
        #[doc = "Range of entry keys to delete"]
        pub key_range: ::indexed_db::KeyRange<'a>,
    }
    impl<'a> ::CdpCommand for DeleteObjectStoreEntriesCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.deleteObjectStoreEntries";
    }
    impl<'a> ::SerializeCdpCommand for DeleteObjectStoreEntriesCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.deleteObjectStoreEntries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteObjectStoreEntriesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.deleteObjectStoreEntries" {
                Ok ( < DeleteObjectStoreEntriesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Delete a range of entries from an object store\n\n# Command `IndexedDB.deleteObjectStoreEntries`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DeleteObjectStoreEntriesCommand`](struct.DeleteObjectStoreEntriesCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DeleteObjectStoreEntriesResponse`](struct.DeleteObjectStoreEntriesResponse.html)"]
    pub struct DeleteObjectStoreEntriesResponse;
    impl ::serde::Serialize for DeleteObjectStoreEntriesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteObjectStoreEntriesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteObjectStoreEntriesResponse)
        }
    }
    impl ::CdpCommand for DeleteObjectStoreEntriesResponse {
        const COMMAND_NAME: &'static str = "IndexedDB.deleteObjectStoreEntries";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteObjectStoreEntriesCommand<'a> {
        type Response = DeleteObjectStoreEntriesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteObjectStoreEntriesResponse {
        type Command = DeleteObjectStoreEntriesCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables events from backend.\n\n# Command `IndexedDB.disable`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "IndexedDB.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "IndexedDB.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables events from backend.\n\n# Command `IndexedDB.disable`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::indexed_db::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "IndexedDB.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables events from backend.\n\n# Command `IndexedDB.enable`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::indexed_db::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "IndexedDB.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "IndexedDB.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables events from backend.\n\n# Command `IndexedDB.enable`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::indexed_db::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "IndexedDB.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from object store or index.\n\n# Command `IndexedDB.requestData`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDataCommand`](struct.RequestDataCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDataResponse`](struct.RequestDataResponse.html)"]
    pub struct RequestDataCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        #[doc = "Object store name."]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "indexName")]
        #[doc = "Index name, empty string for object store data requests."]
        pub index_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "skipCount")]
        #[doc = "Number of records to skip."]
        pub skip_count: i32,
        #[serde(rename = "pageSize")]
        #[doc = "Number of records to fetch."]
        pub page_size: i32,
        #[serde(rename = "keyRange", skip_serializing_if = "Option::is_none")]
        #[doc = "Key range."]
        pub key_range: Option<::indexed_db::KeyRange<'a>>,
    }
    impl<'a> ::CdpCommand for RequestDataCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestData";
    }
    impl<'a> ::SerializeCdpCommand for RequestDataCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestData"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestDataCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestData" {
                Ok(
                    <RequestDataCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests data from object store or index.\n\n# Command `IndexedDB.requestData`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDataCommand`](struct.RequestDataCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDataResponse`](struct.RequestDataResponse.html)"]
    pub struct RequestDataResponse<'a> {
        #[serde(rename = "objectStoreDataEntries")]
        #[doc = "Array of object store data entries."]
        pub object_store_data_entries: Vec<::indexed_db::DataEntry<'a>>,
        #[serde(rename = "hasMore")]
        #[doc = "If true, there are more entries to fetch in the given range."]
        pub has_more: bool,
    }
    impl<'a> ::CdpCommand for RequestDataResponse<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestData";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestDataCommand<'a> {
        type Response = RequestDataResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestDataResponse<'b> {
        type Command = RequestDataCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database with given name in given frame.\n\n# Command `IndexedDB.requestDatabase`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDatabaseCommand`](struct.RequestDatabaseCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDatabaseResponse`](struct.RequestDatabaseResponse.html)"]
    pub struct RequestDatabaseCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database name."]
        pub database_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RequestDatabaseCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestDatabase";
    }
    impl<'a> ::SerializeCdpCommand for RequestDatabaseCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestDatabase"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestDatabaseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestDatabase" {
                Ok(
                    <RequestDatabaseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database with given name in given frame.\n\n# Command `IndexedDB.requestDatabase`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDatabaseCommand`](struct.RequestDatabaseCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDatabaseResponse`](struct.RequestDatabaseResponse.html)"]
    pub struct RequestDatabaseResponse<'a> {
        #[serde(rename = "databaseWithObjectStores")]
        #[doc = "Database with an array of object stores."]
        pub database_with_object_stores: ::indexed_db::DatabaseWithObjectStores<'a>,
    }
    impl<'a> ::CdpCommand for RequestDatabaseResponse<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestDatabase";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestDatabaseCommand<'a> {
        type Response = RequestDatabaseResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestDatabaseResponse<'b> {
        type Command = RequestDatabaseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database names for given security origin.\n\n# Command `IndexedDB.requestDatabaseNames`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDatabaseNamesCommand`](struct.RequestDatabaseNamesCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDatabaseNamesResponse`](struct.RequestDatabaseNamesResponse.html)"]
    pub struct RequestDatabaseNamesCommand<'a> {
        #[serde(rename = "securityOrigin")]
        #[doc = "Security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RequestDatabaseNamesCommand<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestDatabaseNames";
    }
    impl<'a> ::SerializeCdpCommand for RequestDatabaseNamesCommand<'a> {
        fn command_name(&self) -> &str {
            "IndexedDB.requestDatabaseNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RequestDatabaseNamesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "IndexedDB.requestDatabaseNames" {
                Ok ( < RequestDatabaseNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests database names for given security origin.\n\n# Command `IndexedDB.requestDatabaseNames`\n\n*Domain Module:* [`cdp::indexed_db`](index.html)  \n*Command Struct:* [`cdp::indexed_db::RequestDatabaseNamesCommand`](struct.RequestDatabaseNamesCommand.html)  \n*Response Struct:* [`cdp::indexed_db::RequestDatabaseNamesResponse`](struct.RequestDatabaseNamesResponse.html)"]
    pub struct RequestDatabaseNamesResponse<'a> {
        #[serde(rename = "databaseNames")]
        #[doc = "Database names for origin."]
        pub database_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for RequestDatabaseNamesResponse<'a> {
        const COMMAND_NAME: &'static str = "IndexedDB.requestDatabaseNames";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RequestDatabaseNamesCommand<'a> {
        type Response = RequestDatabaseNamesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestDatabaseNamesResponse<'b> {
        type Command = RequestDatabaseNamesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Database with an array of object stores."]
    pub struct DatabaseWithObjectStores<'a> {
        #[serde(rename = "name")]
        #[doc = "Database name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Database version."]
        pub version: i32,
        #[serde(rename = "objectStores")]
        #[doc = "Object stores in this database."]
        pub object_stores: Vec<::indexed_db::ObjectStore<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object store."]
    pub struct ObjectStore<'a> {
        #[serde(rename = "name")]
        #[doc = "Object store name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyPath")]
        #[doc = "Object store key path."]
        pub key_path: ::indexed_db::KeyPath<'a>,
        #[serde(rename = "autoIncrement")]
        #[doc = "If true, object store has auto increment flag set."]
        pub auto_increment: bool,
        #[serde(rename = "indexes")]
        #[doc = "Indexes in this object store."]
        pub indexes: Vec<::indexed_db::ObjectStoreIndex<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object store index."]
    pub struct ObjectStoreIndex<'a> {
        #[serde(rename = "name")]
        #[doc = "Index name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyPath")]
        #[doc = "Index key path."]
        pub key_path: ::indexed_db::KeyPath<'a>,
        #[serde(rename = "unique")]
        #[doc = "If true, index is unique."]
        pub unique: bool,
        #[serde(rename = "multiEntry")]
        #[doc = "If true, index allows multiple entries for a key."]
        pub multi_entry: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::indexed_db::Key::ty`](struct.Key.html#structfield.ty)."]
    pub enum KeyType {
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
    }
    impl KeyType {
        pub const ENUM_VALUES: &'static [KeyType] = &[
            KeyType::Number,
            KeyType::String,
            KeyType::Date,
            KeyType::Array,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["number", "string", "date", "array"];
    }
    impl ::std::str::FromStr for KeyType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "number" => Ok(KeyType::Number),
                "string" => Ok(KeyType::String),
                "date" => Ok(KeyType::Date),
                "array" => Ok(KeyType::Array),
                _ => Err(::ParseEnumError {
                    expected: KeyType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for KeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    KeyType::Number => "number",
                    KeyType::String => "string",
                    KeyType::Date => "date",
                    KeyType::Array => "array",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key."]
    pub struct Key<'a> {
        #[serde(rename = "type")]
        #[doc = "Key type."]
        pub ty: ::indexed_db::KeyType,
        #[serde(rename = "number", skip_serializing_if = "Option::is_none")]
        #[doc = "Number value."]
        pub number: Option<f64>,
        #[serde(rename = "string", skip_serializing_if = "Option::is_none")]
        #[doc = "String value."]
        pub string: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "date", skip_serializing_if = "Option::is_none")]
        #[doc = "Date value."]
        pub date: Option<f64>,
        #[serde(rename = "array", skip_serializing_if = "Option::is_none")]
        #[doc = "Array value."]
        pub array: Option<Vec<Box<::indexed_db::Key<'a>>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key range."]
    pub struct KeyRange<'a> {
        #[serde(rename = "lower", skip_serializing_if = "Option::is_none")]
        #[doc = "Lower bound."]
        pub lower: Option<::indexed_db::Key<'a>>,
        #[serde(rename = "upper", skip_serializing_if = "Option::is_none")]
        #[doc = "Upper bound."]
        pub upper: Option<::indexed_db::Key<'a>>,
        #[serde(rename = "lowerOpen")]
        #[doc = "If true lower bound is open."]
        pub lower_open: bool,
        #[serde(rename = "upperOpen")]
        #[doc = "If true upper bound is open."]
        pub upper_open: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Data entry."]
    pub struct DataEntry<'a> {
        #[serde(rename = "key")]
        #[doc = "Key object."]
        pub key: ::runtime::RemoteObject<'a>,
        #[serde(rename = "primaryKey")]
        #[doc = "Primary key object."]
        pub primary_key: ::runtime::RemoteObject<'a>,
        #[serde(rename = "value")]
        #[doc = "Value object."]
        pub value: ::runtime::RemoteObject<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::indexed_db::KeyPath::ty`](struct.KeyPath.html#structfield.ty)."]
    pub enum KeyPathType {
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
    }
    impl KeyPathType {
        pub const ENUM_VALUES: &'static [KeyPathType] =
            &[KeyPathType::Null, KeyPathType::String, KeyPathType::Array];
        pub const STR_VALUES: &'static [&'static str] = &["null", "string", "array"];
    }
    impl ::std::str::FromStr for KeyPathType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "null" => Ok(KeyPathType::Null),
                "string" => Ok(KeyPathType::String),
                "array" => Ok(KeyPathType::Array),
                _ => Err(::ParseEnumError {
                    expected: KeyPathType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for KeyPathType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    KeyPathType::Null => "null",
                    KeyPathType::String => "string",
                    KeyPathType::Array => "array",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Key path."]
    pub struct KeyPath<'a> {
        #[serde(rename = "type")]
        #[doc = "Key path type."]
        pub ty: ::indexed_db::KeyPathType,
        #[serde(rename = "string", skip_serializing_if = "Option::is_none")]
        #[doc = "String value."]
        pub string: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "array", skip_serializing_if = "Option::is_none")]
        #[doc = "Array value."]
        pub array: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
}
#[doc = "# Input\n\n## Commands\n\n- [`Input.dispatchKeyEvent`](struct.DispatchKeyEventCommand.html)\n\n  Dispatches a key event to the page.\n- [`Input.insertText`](struct.InsertTextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  This method emulates inserting text that doesn't come from a key press,\n  for example an emoji keyboard or an IME.\n- [`Input.dispatchMouseEvent`](struct.DispatchMouseEventCommand.html)\n\n  Dispatches a mouse event to the page.\n- [`Input.dispatchTouchEvent`](struct.DispatchTouchEventCommand.html)\n\n  Dispatches a touch event to the page.\n- [`Input.emulateTouchFromMouseEvent`](struct.EmulateTouchFromMouseEventCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Emulates touch event from the mouse event parameters.\n- [`Input.setIgnoreInputEvents`](struct.SetIgnoreInputEventsCommand.html)\n\n  Ignores input events \\(useful while auditing page\\).\n- [`Input.synthesizePinchGesture`](struct.SynthesizePinchGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n- [`Input.synthesizeScrollGesture`](struct.SynthesizeScrollGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n- [`Input.synthesizeTapGesture`](struct.SynthesizeTapGestureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n##Types\n\n- [`TouchPoint`](struct.TouchPoint.html)\n- [`GestureSourceType`](enum.GestureSourceType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`TimeSinceEpoch`](type.TimeSinceEpoch.html)\n\n  UTC time in seconds, counted from January 1, 1970.\n"]
pub mod input {
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::input::DispatchKeyEventCommand::ty`](struct.DispatchKeyEventCommand.html#structfield.ty)."]
    pub enum DispatchKeyEventCommandType {
        #[serde(rename = "keyDown")]
        #[doc = "Represented as `\"keyDown\"`."]
        KeyDown,
        #[serde(rename = "keyUp")]
        #[doc = "Represented as `\"keyUp\"`."]
        KeyUp,
        #[serde(rename = "rawKeyDown")]
        #[doc = "Represented as `\"rawKeyDown\"`."]
        RawKeyDown,
        #[serde(rename = "char")]
        #[doc = "Represented as `\"char\"`."]
        Char,
    }
    impl DispatchKeyEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchKeyEventCommandType] =
            &[
                DispatchKeyEventCommandType::KeyDown,
                DispatchKeyEventCommandType::KeyUp,
                DispatchKeyEventCommandType::RawKeyDown,
                DispatchKeyEventCommandType::Char,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["keyDown", "keyUp", "rawKeyDown", "char"];
    }
    impl ::std::str::FromStr for DispatchKeyEventCommandType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "keyDown" => Ok(DispatchKeyEventCommandType::KeyDown),
                "keyUp" => Ok(DispatchKeyEventCommandType::KeyUp),
                "rawKeyDown" => Ok(DispatchKeyEventCommandType::RawKeyDown),
                "char" => Ok(DispatchKeyEventCommandType::Char),
                _ => Err(::ParseEnumError {
                    expected: DispatchKeyEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchKeyEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchKeyEventCommandType::KeyDown => "keyDown",
                    DispatchKeyEventCommandType::KeyUp => "keyUp",
                    DispatchKeyEventCommandType::RawKeyDown => "rawKeyDown",
                    DispatchKeyEventCommandType::Char => "char",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Dispatches a key event to the page.\n\n# Command `Input.dispatchKeyEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchKeyEventCommand`](struct.DispatchKeyEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchKeyEventResponse`](struct.DispatchKeyEventResponse.html)"]
    pub struct DispatchKeyEventCommand<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of the key event."]
        pub ty: ::input::DispatchKeyEventCommandType,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n\\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::input::TimeSinceEpoch>,
        #[serde(rename = "text", skip_serializing_if = "Option::is_none")]
        #[doc = "Text as generated by processing a virtual key code with a keyboard layout. Not needed for\nfor `keyUp` and `rawKeyDown` events \\(default: \"\"\\)"]
        pub text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "unmodifiedText", skip_serializing_if = "Option::is_none")]
        #[doc = "Text that would have been generated by the keyboard if no modifiers were pressed \\(except for\nshift\\). Useful for shortcut \\(accelerator\\) key handling \\(default: \"\"\\)."]
        pub unmodified_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "keyIdentifier", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique key identifier \\(e.g., 'U+0041'\\) \\(default: \"\"\\)."]
        pub key_identifier: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "code", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique DOM defined string value for each physical key \\(e.g., 'KeyA'\\) \\(default: \"\"\\)."]
        pub code: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "key", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique DOM defined string value describing the meaning of the key in the context of active\nmodifiers, keyboard layout, etc \\(e.g., 'AltGr'\\) \\(default: \"\"\\)."]
        pub key: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "windowsVirtualKeyCode", skip_serializing_if = "Option::is_none")]
        #[doc = "Windows virtual key code \\(default: 0\\)."]
        pub windows_virtual_key_code: Option<i32>,
        #[serde(rename = "nativeVirtualKeyCode", skip_serializing_if = "Option::is_none")]
        #[doc = "Native virtual key code \\(default: 0\\)."]
        pub native_virtual_key_code: Option<i32>,
        #[serde(rename = "autoRepeat", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was generated from auto repeat \\(default: false\\)."]
        pub auto_repeat: Option<bool>,
        #[serde(rename = "isKeypad", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was generated from the keypad \\(default: false\\)."]
        pub is_keypad: Option<bool>,
        #[serde(rename = "isSystemKey", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was a system key event \\(default: false\\)."]
        pub is_system_key: Option<bool>,
        #[serde(rename = "location", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right \\(default:\n0\\)."]
        pub location: Option<i32>,
    }
    impl<'a> ::CdpCommand for DispatchKeyEventCommand<'a> {
        const COMMAND_NAME: &'static str = "Input.dispatchKeyEvent";
    }
    impl<'a> ::SerializeCdpCommand for DispatchKeyEventCommand<'a> {
        fn command_name(&self) -> &str {
            "Input.dispatchKeyEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DispatchKeyEventCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchKeyEvent" {
                Ok ( < DispatchKeyEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Dispatches a key event to the page.\n\n# Command `Input.dispatchKeyEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchKeyEventCommand`](struct.DispatchKeyEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchKeyEventResponse`](struct.DispatchKeyEventResponse.html)"]
    pub struct DispatchKeyEventResponse;
    impl ::serde::Serialize for DispatchKeyEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchKeyEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchKeyEventResponse)
        }
    }
    impl ::CdpCommand for DispatchKeyEventResponse {
        const COMMAND_NAME: &'static str = "Input.dispatchKeyEvent";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DispatchKeyEventCommand<'a> {
        type Response = DispatchKeyEventResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DispatchKeyEventResponse {
        type Command = DispatchKeyEventCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method emulates inserting text that doesn't come from a key press,\nfor example an emoji keyboard or an IME.\n\n# Command `Input.insertText`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::InsertTextCommand`](struct.InsertTextCommand.html)  \n*Response Struct:* [`cdp::input::InsertTextResponse`](struct.InsertTextResponse.html)"]
    pub struct InsertTextCommand<'a> {
        #[serde(rename = "text")]
        #[doc = "The text to insert."]
        pub text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for InsertTextCommand<'a> {
        const COMMAND_NAME: &'static str = "Input.insertText";
    }
    impl<'a> ::SerializeCdpCommand for InsertTextCommand<'a> {
        fn command_name(&self) -> &str {
            "Input.insertText"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for InsertTextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.insertText" {
                Ok(
                    <InsertTextCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method emulates inserting text that doesn't come from a key press,\nfor example an emoji keyboard or an IME.\n\n# Command `Input.insertText`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::InsertTextCommand`](struct.InsertTextCommand.html)  \n*Response Struct:* [`cdp::input::InsertTextResponse`](struct.InsertTextResponse.html)"]
    pub struct InsertTextResponse;
    impl ::serde::Serialize for InsertTextResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InsertTextResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InsertTextResponse)
        }
    }
    impl ::CdpCommand for InsertTextResponse {
        const COMMAND_NAME: &'static str = "Input.insertText";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for InsertTextCommand<'a> {
        type Response = InsertTextResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for InsertTextResponse {
        type Command = InsertTextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::input::DispatchMouseEventCommand::ty`](struct.DispatchMouseEventCommand.html#structfield.ty)."]
    pub enum DispatchMouseEventCommandType {
        #[serde(rename = "mousePressed")]
        #[doc = "Represented as `\"mousePressed\"`."]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        #[doc = "Represented as `\"mouseReleased\"`."]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        #[doc = "Represented as `\"mouseMoved\"`."]
        MouseMoved,
        #[serde(rename = "mouseWheel")]
        #[doc = "Represented as `\"mouseWheel\"`."]
        MouseWheel,
    }
    impl DispatchMouseEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchMouseEventCommandType] =
            &[
                DispatchMouseEventCommandType::MousePressed,
                DispatchMouseEventCommandType::MouseReleased,
                DispatchMouseEventCommandType::MouseMoved,
                DispatchMouseEventCommandType::MouseWheel,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mousePressed", "mouseReleased", "mouseMoved", "mouseWheel"];
    }
    impl ::std::str::FromStr for DispatchMouseEventCommandType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mousePressed" => Ok(DispatchMouseEventCommandType::MousePressed),
                "mouseReleased" => Ok(DispatchMouseEventCommandType::MouseReleased),
                "mouseMoved" => Ok(DispatchMouseEventCommandType::MouseMoved),
                "mouseWheel" => Ok(DispatchMouseEventCommandType::MouseWheel),
                _ => Err(::ParseEnumError {
                    expected: DispatchMouseEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchMouseEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchMouseEventCommandType::MousePressed => "mousePressed",
                    DispatchMouseEventCommandType::MouseReleased => "mouseReleased",
                    DispatchMouseEventCommandType::MouseMoved => "mouseMoved",
                    DispatchMouseEventCommandType::MouseWheel => "mouseWheel",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::input::DispatchMouseEventCommand::button`](struct.DispatchMouseEventCommand.html#structfield.button)."]
    pub enum DispatchMouseEventCommandButton {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "left")]
        #[doc = "Represented as `\"left\"`."]
        Left,
        #[serde(rename = "middle")]
        #[doc = "Represented as `\"middle\"`."]
        Middle,
        #[serde(rename = "right")]
        #[doc = "Represented as `\"right\"`."]
        Right,
    }
    impl DispatchMouseEventCommandButton {
        pub const ENUM_VALUES: &'static [DispatchMouseEventCommandButton] =
            &[
                DispatchMouseEventCommandButton::None,
                DispatchMouseEventCommandButton::Left,
                DispatchMouseEventCommandButton::Middle,
                DispatchMouseEventCommandButton::Right,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "left", "middle", "right"];
    }
    impl ::std::str::FromStr for DispatchMouseEventCommandButton {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(DispatchMouseEventCommandButton::None),
                "left" => Ok(DispatchMouseEventCommandButton::Left),
                "middle" => Ok(DispatchMouseEventCommandButton::Middle),
                "right" => Ok(DispatchMouseEventCommandButton::Right),
                _ => Err(::ParseEnumError {
                    expected: DispatchMouseEventCommandButton::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchMouseEventCommandButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchMouseEventCommandButton::None => "none",
                    DispatchMouseEventCommandButton::Left => "left",
                    DispatchMouseEventCommandButton::Middle => "middle",
                    DispatchMouseEventCommandButton::Right => "right",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Dispatches a mouse event to the page.\n\n# Command `Input.dispatchMouseEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchMouseEventCommand`](struct.DispatchMouseEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchMouseEventResponse`](struct.DispatchMouseEventResponse.html)"]
    pub struct DispatchMouseEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the mouse event."]
        pub ty: ::input::DispatchMouseEventCommandType,
        #[serde(rename = "x")]
        #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to\nthe top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
        pub y: f64,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n\\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::input::TimeSinceEpoch>,
        #[serde(rename = "button", skip_serializing_if = "Option::is_none")]
        #[doc = "Mouse button \\(default: \"none\"\\)."]
        pub button: Option<::input::DispatchMouseEventCommandButton>,
        #[serde(rename = "clickCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times the mouse button was clicked \\(default: 0\\)."]
        pub click_count: Option<i32>,
        #[serde(rename = "deltaX", skip_serializing_if = "Option::is_none")]
        #[doc = "X delta in CSS pixels for mouse wheel event \\(default: 0\\)."]
        pub delta_x: Option<f64>,
        #[serde(rename = "deltaY", skip_serializing_if = "Option::is_none")]
        #[doc = "Y delta in CSS pixels for mouse wheel event \\(default: 0\\)."]
        pub delta_y: Option<f64>,
    }
    impl ::CdpCommand for DispatchMouseEventCommand {
        const COMMAND_NAME: &'static str = "Input.dispatchMouseEvent";
    }
    impl ::SerializeCdpCommand for DispatchMouseEventCommand {
        fn command_name(&self) -> &str {
            "Input.dispatchMouseEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DispatchMouseEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchMouseEvent" {
                Ok ( < DispatchMouseEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Dispatches a mouse event to the page.\n\n# Command `Input.dispatchMouseEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchMouseEventCommand`](struct.DispatchMouseEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchMouseEventResponse`](struct.DispatchMouseEventResponse.html)"]
    pub struct DispatchMouseEventResponse;
    impl ::serde::Serialize for DispatchMouseEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchMouseEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchMouseEventResponse)
        }
    }
    impl ::CdpCommand for DispatchMouseEventResponse {
        const COMMAND_NAME: &'static str = "Input.dispatchMouseEvent";
    }
    impl<'b> ::HasCdpResponse<'b> for DispatchMouseEventCommand {
        type Response = DispatchMouseEventResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DispatchMouseEventResponse {
        type Command = DispatchMouseEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::input::DispatchTouchEventCommand::ty`](struct.DispatchTouchEventCommand.html#structfield.ty)."]
    pub enum DispatchTouchEventCommandType {
        #[serde(rename = "touchStart")]
        #[doc = "Represented as `\"touchStart\"`."]
        TouchStart,
        #[serde(rename = "touchEnd")]
        #[doc = "Represented as `\"touchEnd\"`."]
        TouchEnd,
        #[serde(rename = "touchMove")]
        #[doc = "Represented as `\"touchMove\"`."]
        TouchMove,
        #[serde(rename = "touchCancel")]
        #[doc = "Represented as `\"touchCancel\"`."]
        TouchCancel,
    }
    impl DispatchTouchEventCommandType {
        pub const ENUM_VALUES: &'static [DispatchTouchEventCommandType] =
            &[
                DispatchTouchEventCommandType::TouchStart,
                DispatchTouchEventCommandType::TouchEnd,
                DispatchTouchEventCommandType::TouchMove,
                DispatchTouchEventCommandType::TouchCancel,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["touchStart", "touchEnd", "touchMove", "touchCancel"];
    }
    impl ::std::str::FromStr for DispatchTouchEventCommandType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "touchStart" => Ok(DispatchTouchEventCommandType::TouchStart),
                "touchEnd" => Ok(DispatchTouchEventCommandType::TouchEnd),
                "touchMove" => Ok(DispatchTouchEventCommandType::TouchMove),
                "touchCancel" => Ok(DispatchTouchEventCommandType::TouchCancel),
                _ => Err(::ParseEnumError {
                    expected: DispatchTouchEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DispatchTouchEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DispatchTouchEventCommandType::TouchStart => "touchStart",
                    DispatchTouchEventCommandType::TouchEnd => "touchEnd",
                    DispatchTouchEventCommandType::TouchMove => "touchMove",
                    DispatchTouchEventCommandType::TouchCancel => "touchCancel",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Dispatches a touch event to the page.\n\n# Command `Input.dispatchTouchEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchTouchEventCommand`](struct.DispatchTouchEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchTouchEventResponse`](struct.DispatchTouchEventResponse.html)"]
    pub struct DispatchTouchEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while\nTouchStart and TouchMove must contains at least one."]
        pub ty: ::input::DispatchTouchEventCommandType,
        #[serde(rename = "touchPoints")]
        #[doc = "Active touch points on the touch device. One event per any changed point \\(compared to\nprevious touch event in a sequence\\) is generated, emulating pressing/moving/releasing points\none by one."]
        pub touch_points: Vec<::input::TouchPoint>,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n\\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred."]
        pub timestamp: Option<::input::TimeSinceEpoch>,
    }
    impl ::CdpCommand for DispatchTouchEventCommand {
        const COMMAND_NAME: &'static str = "Input.dispatchTouchEvent";
    }
    impl ::SerializeCdpCommand for DispatchTouchEventCommand {
        fn command_name(&self) -> &str {
            "Input.dispatchTouchEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DispatchTouchEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.dispatchTouchEvent" {
                Ok ( < DispatchTouchEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Dispatches a touch event to the page.\n\n# Command `Input.dispatchTouchEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::DispatchTouchEventCommand`](struct.DispatchTouchEventCommand.html)  \n*Response Struct:* [`cdp::input::DispatchTouchEventResponse`](struct.DispatchTouchEventResponse.html)"]
    pub struct DispatchTouchEventResponse;
    impl ::serde::Serialize for DispatchTouchEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchTouchEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchTouchEventResponse)
        }
    }
    impl ::CdpCommand for DispatchTouchEventResponse {
        const COMMAND_NAME: &'static str = "Input.dispatchTouchEvent";
    }
    impl<'b> ::HasCdpResponse<'b> for DispatchTouchEventCommand {
        type Response = DispatchTouchEventResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DispatchTouchEventResponse {
        type Command = DispatchTouchEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::input::EmulateTouchFromMouseEventCommand::ty`](struct.EmulateTouchFromMouseEventCommand.html#structfield.ty)."]
    pub enum EmulateTouchFromMouseEventCommandType {
        #[serde(rename = "mousePressed")]
        #[doc = "Represented as `\"mousePressed\"`."]
        MousePressed,
        #[serde(rename = "mouseReleased")]
        #[doc = "Represented as `\"mouseReleased\"`."]
        MouseReleased,
        #[serde(rename = "mouseMoved")]
        #[doc = "Represented as `\"mouseMoved\"`."]
        MouseMoved,
        #[serde(rename = "mouseWheel")]
        #[doc = "Represented as `\"mouseWheel\"`."]
        MouseWheel,
    }
    impl EmulateTouchFromMouseEventCommandType {
        pub const ENUM_VALUES: &'static [EmulateTouchFromMouseEventCommandType] =
            &[
                EmulateTouchFromMouseEventCommandType::MousePressed,
                EmulateTouchFromMouseEventCommandType::MouseReleased,
                EmulateTouchFromMouseEventCommandType::MouseMoved,
                EmulateTouchFromMouseEventCommandType::MouseWheel,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["mousePressed", "mouseReleased", "mouseMoved", "mouseWheel"];
    }
    impl ::std::str::FromStr for EmulateTouchFromMouseEventCommandType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mousePressed" => Ok(EmulateTouchFromMouseEventCommandType::MousePressed),
                "mouseReleased" => Ok(EmulateTouchFromMouseEventCommandType::MouseReleased),
                "mouseMoved" => Ok(EmulateTouchFromMouseEventCommandType::MouseMoved),
                "mouseWheel" => Ok(EmulateTouchFromMouseEventCommandType::MouseWheel),
                _ => Err(::ParseEnumError {
                    expected: EmulateTouchFromMouseEventCommandType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for EmulateTouchFromMouseEventCommandType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    EmulateTouchFromMouseEventCommandType::MousePressed => "mousePressed",
                    EmulateTouchFromMouseEventCommandType::MouseReleased => "mouseReleased",
                    EmulateTouchFromMouseEventCommandType::MouseMoved => "mouseMoved",
                    EmulateTouchFromMouseEventCommandType::MouseWheel => "mouseWheel",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::input::EmulateTouchFromMouseEventCommand::button`](struct.EmulateTouchFromMouseEventCommand.html#structfield.button)."]
    pub enum EmulateTouchFromMouseEventCommandButton {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "left")]
        #[doc = "Represented as `\"left\"`."]
        Left,
        #[serde(rename = "middle")]
        #[doc = "Represented as `\"middle\"`."]
        Middle,
        #[serde(rename = "right")]
        #[doc = "Represented as `\"right\"`."]
        Right,
    }
    impl EmulateTouchFromMouseEventCommandButton {
        pub const ENUM_VALUES: &'static [EmulateTouchFromMouseEventCommandButton] =
            &[
                EmulateTouchFromMouseEventCommandButton::None,
                EmulateTouchFromMouseEventCommandButton::Left,
                EmulateTouchFromMouseEventCommandButton::Middle,
                EmulateTouchFromMouseEventCommandButton::Right,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "left", "middle", "right"];
    }
    impl ::std::str::FromStr for EmulateTouchFromMouseEventCommandButton {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(EmulateTouchFromMouseEventCommandButton::None),
                "left" => Ok(EmulateTouchFromMouseEventCommandButton::Left),
                "middle" => Ok(EmulateTouchFromMouseEventCommandButton::Middle),
                "right" => Ok(EmulateTouchFromMouseEventCommandButton::Right),
                _ => Err(::ParseEnumError {
                    expected: EmulateTouchFromMouseEventCommandButton::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for EmulateTouchFromMouseEventCommandButton {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    EmulateTouchFromMouseEventCommandButton::None => "none",
                    EmulateTouchFromMouseEventCommandButton::Left => "left",
                    EmulateTouchFromMouseEventCommandButton::Middle => "middle",
                    EmulateTouchFromMouseEventCommandButton::Right => "right",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Emulates touch event from the mouse event parameters.\n\n# Command `Input.emulateTouchFromMouseEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::EmulateTouchFromMouseEventCommand`](struct.EmulateTouchFromMouseEventCommand.html)  \n*Response Struct:* [`cdp::input::EmulateTouchFromMouseEventResponse`](struct.EmulateTouchFromMouseEventResponse.html)"]
    pub struct EmulateTouchFromMouseEventCommand {
        #[serde(rename = "type")]
        #[doc = "Type of the mouse event."]
        pub ty: ::input::EmulateTouchFromMouseEventCommandType,
        #[serde(rename = "x")]
        #[doc = "X coordinate of the mouse pointer in DIP."]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the mouse pointer in DIP."]
        pub y: i32,
        #[serde(rename = "button")]
        #[doc = "Mouse button."]
        pub button: ::input::EmulateTouchFromMouseEventCommandButton,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Time at which the event occurred \\(default: current time\\)."]
        pub timestamp: Option<::input::TimeSinceEpoch>,
        #[serde(rename = "deltaX", skip_serializing_if = "Option::is_none")]
        #[doc = "X delta in DIP for mouse wheel event \\(default: 0\\)."]
        pub delta_x: Option<f64>,
        #[serde(rename = "deltaY", skip_serializing_if = "Option::is_none")]
        #[doc = "Y delta in DIP for mouse wheel event \\(default: 0\\)."]
        pub delta_y: Option<f64>,
        #[serde(rename = "modifiers", skip_serializing_if = "Option::is_none")]
        #[doc = "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8\n\\(default: 0\\)."]
        pub modifiers: Option<i32>,
        #[serde(rename = "clickCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times the mouse button was clicked \\(default: 0\\)."]
        pub click_count: Option<i32>,
    }
    impl ::CdpCommand for EmulateTouchFromMouseEventCommand {
        const COMMAND_NAME: &'static str = "Input.emulateTouchFromMouseEvent";
    }
    impl ::SerializeCdpCommand for EmulateTouchFromMouseEventCommand {
        fn command_name(&self) -> &str {
            "Input.emulateTouchFromMouseEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EmulateTouchFromMouseEventCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.emulateTouchFromMouseEvent" {
                Ok ( < EmulateTouchFromMouseEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Emulates touch event from the mouse event parameters.\n\n# Command `Input.emulateTouchFromMouseEvent`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::EmulateTouchFromMouseEventCommand`](struct.EmulateTouchFromMouseEventCommand.html)  \n*Response Struct:* [`cdp::input::EmulateTouchFromMouseEventResponse`](struct.EmulateTouchFromMouseEventResponse.html)"]
    pub struct EmulateTouchFromMouseEventResponse;
    impl ::serde::Serialize for EmulateTouchFromMouseEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EmulateTouchFromMouseEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EmulateTouchFromMouseEventResponse)
        }
    }
    impl ::CdpCommand for EmulateTouchFromMouseEventResponse {
        const COMMAND_NAME: &'static str = "Input.emulateTouchFromMouseEvent";
    }
    impl<'b> ::HasCdpResponse<'b> for EmulateTouchFromMouseEventCommand {
        type Response = EmulateTouchFromMouseEventResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EmulateTouchFromMouseEventResponse {
        type Command = EmulateTouchFromMouseEventCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Ignores input events \\(useful while auditing page\\).\n\n# Command `Input.setIgnoreInputEvents`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SetIgnoreInputEventsCommand`](struct.SetIgnoreInputEventsCommand.html)  \n*Response Struct:* [`cdp::input::SetIgnoreInputEventsResponse`](struct.SetIgnoreInputEventsResponse.html)"]
    pub struct SetIgnoreInputEventsCommand {
        #[serde(rename = "ignore")]
        #[doc = "Ignores input events processing when set to true."]
        pub ignore: bool,
    }
    impl ::CdpCommand for SetIgnoreInputEventsCommand {
        const COMMAND_NAME: &'static str = "Input.setIgnoreInputEvents";
    }
    impl ::SerializeCdpCommand for SetIgnoreInputEventsCommand {
        fn command_name(&self) -> &str {
            "Input.setIgnoreInputEvents"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetIgnoreInputEventsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.setIgnoreInputEvents" {
                Ok ( < SetIgnoreInputEventsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Ignores input events \\(useful while auditing page\\).\n\n# Command `Input.setIgnoreInputEvents`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SetIgnoreInputEventsCommand`](struct.SetIgnoreInputEventsCommand.html)  \n*Response Struct:* [`cdp::input::SetIgnoreInputEventsResponse`](struct.SetIgnoreInputEventsResponse.html)"]
    pub struct SetIgnoreInputEventsResponse;
    impl ::serde::Serialize for SetIgnoreInputEventsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetIgnoreInputEventsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetIgnoreInputEventsResponse)
        }
    }
    impl ::CdpCommand for SetIgnoreInputEventsResponse {
        const COMMAND_NAME: &'static str = "Input.setIgnoreInputEvents";
    }
    impl<'b> ::HasCdpResponse<'b> for SetIgnoreInputEventsCommand {
        type Response = SetIgnoreInputEventsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetIgnoreInputEventsResponse {
        type Command = SetIgnoreInputEventsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizePinchGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizePinchGestureCommand`](struct.SynthesizePinchGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizePinchGestureResponse`](struct.SynthesizePinchGestureResponse.html)"]
    pub struct SynthesizePinchGestureCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "scaleFactor")]
        #[doc = "Relative scale factor after zooming \\(>1.0 zooms in, <1.0 zooms out\\)."]
        pub scale_factor: f64,
        #[serde(rename = "relativeSpeed", skip_serializing_if = "Option::is_none")]
        #[doc = "Relative pointer speed in pixels per second \\(default: 800\\)."]
        pub relative_speed: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform\nfor the preferred input type\\)."]
        pub gesture_source_type: Option<::input::GestureSourceType>,
    }
    impl ::CdpCommand for SynthesizePinchGestureCommand {
        const COMMAND_NAME: &'static str = "Input.synthesizePinchGesture";
    }
    impl ::SerializeCdpCommand for SynthesizePinchGestureCommand {
        fn command_name(&self) -> &str {
            "Input.synthesizePinchGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SynthesizePinchGestureCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizePinchGesture" {
                Ok ( < SynthesizePinchGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a pinch gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizePinchGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizePinchGestureCommand`](struct.SynthesizePinchGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizePinchGestureResponse`](struct.SynthesizePinchGestureResponse.html)"]
    pub struct SynthesizePinchGestureResponse;
    impl ::serde::Serialize for SynthesizePinchGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizePinchGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizePinchGestureResponse)
        }
    }
    impl ::CdpCommand for SynthesizePinchGestureResponse {
        const COMMAND_NAME: &'static str = "Input.synthesizePinchGesture";
    }
    impl<'b> ::HasCdpResponse<'b> for SynthesizePinchGestureCommand {
        type Response = SynthesizePinchGestureResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SynthesizePinchGestureResponse {
        type Command = SynthesizePinchGestureCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeScrollGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizeScrollGestureCommand`](struct.SynthesizeScrollGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizeScrollGestureResponse`](struct.SynthesizeScrollGestureResponse.html)"]
    pub struct SynthesizeScrollGestureCommand<'a> {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "xDistance", skip_serializing_if = "Option::is_none")]
        #[doc = "The distance to scroll along the X axis \\(positive to scroll left\\)."]
        pub x_distance: Option<f64>,
        #[serde(rename = "yDistance", skip_serializing_if = "Option::is_none")]
        #[doc = "The distance to scroll along the Y axis \\(positive to scroll up\\)."]
        pub y_distance: Option<f64>,
        #[serde(rename = "xOverscroll", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of additional pixels to scroll back along the X axis, in addition to the given\ndistance."]
        pub x_overscroll: Option<f64>,
        #[serde(rename = "yOverscroll", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of additional pixels to scroll back along the Y axis, in addition to the given\ndistance."]
        pub y_overscroll: Option<f64>,
        #[serde(rename = "preventFling", skip_serializing_if = "Option::is_none")]
        #[doc = "Prevent fling \\(default: true\\)."]
        pub prevent_fling: Option<bool>,
        #[serde(rename = "speed", skip_serializing_if = "Option::is_none")]
        #[doc = "Swipe speed in pixels per second \\(default: 800\\)."]
        pub speed: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform\nfor the preferred input type\\)."]
        pub gesture_source_type: Option<::input::GestureSourceType>,
        #[serde(rename = "repeatCount", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of times to repeat the gesture \\(default: 0\\)."]
        pub repeat_count: Option<i32>,
        #[serde(rename = "repeatDelayMs", skip_serializing_if = "Option::is_none")]
        #[doc = "The number of milliseconds delay between each repeat. \\(default: 250\\)."]
        pub repeat_delay_ms: Option<i32>,
        #[serde(rename = "interactionMarkerName", skip_serializing_if = "Option::is_none")]
        #[doc = "The name of the interaction markers to generate, if not empty \\(default: \"\"\\)."]
        pub interaction_marker_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SynthesizeScrollGestureCommand<'a> {
        const COMMAND_NAME: &'static str = "Input.synthesizeScrollGesture";
    }
    impl<'a> ::SerializeCdpCommand for SynthesizeScrollGestureCommand<'a> {
        fn command_name(&self) -> &str {
            "Input.synthesizeScrollGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SynthesizeScrollGestureCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizeScrollGesture" {
                Ok ( < SynthesizeScrollGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a scroll gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeScrollGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizeScrollGestureCommand`](struct.SynthesizeScrollGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizeScrollGestureResponse`](struct.SynthesizeScrollGestureResponse.html)"]
    pub struct SynthesizeScrollGestureResponse;
    impl ::serde::Serialize for SynthesizeScrollGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizeScrollGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizeScrollGestureResponse)
        }
    }
    impl ::CdpCommand for SynthesizeScrollGestureResponse {
        const COMMAND_NAME: &'static str = "Input.synthesizeScrollGesture";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SynthesizeScrollGestureCommand<'a> {
        type Response = SynthesizeScrollGestureResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SynthesizeScrollGestureResponse {
        type Command = SynthesizeScrollGestureCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeTapGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizeTapGestureCommand`](struct.SynthesizeTapGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizeTapGestureResponse`](struct.SynthesizeTapGestureResponse.html)"]
    pub struct SynthesizeTapGestureCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the start of the gesture in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the start of the gesture in CSS pixels."]
        pub y: f64,
        #[serde(rename = "duration", skip_serializing_if = "Option::is_none")]
        #[doc = "Duration between touchdown and touchup events in ms \\(default: 50\\)."]
        pub duration: Option<i32>,
        #[serde(rename = "tapCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of times to perform the tap \\(e.g. 2 for double tap, default: 1\\)."]
        pub tap_count: Option<i32>,
        #[serde(rename = "gestureSourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "Which type of input events to be generated \\(default: 'default', which queries the platform\nfor the preferred input type\\)."]
        pub gesture_source_type: Option<::input::GestureSourceType>,
    }
    impl ::CdpCommand for SynthesizeTapGestureCommand {
        const COMMAND_NAME: &'static str = "Input.synthesizeTapGesture";
    }
    impl ::SerializeCdpCommand for SynthesizeTapGestureCommand {
        fn command_name(&self) -> &str {
            "Input.synthesizeTapGesture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SynthesizeTapGestureCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Input.synthesizeTapGesture" {
                Ok ( < SynthesizeTapGestureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Synthesizes a tap gesture over a time period by issuing appropriate touch events.\n\n# Command `Input.synthesizeTapGesture`\n\n*Domain Module:* [`cdp::input`](index.html)  \n*Command Struct:* [`cdp::input::SynthesizeTapGestureCommand`](struct.SynthesizeTapGestureCommand.html)  \n*Response Struct:* [`cdp::input::SynthesizeTapGestureResponse`](struct.SynthesizeTapGestureResponse.html)"]
    pub struct SynthesizeTapGestureResponse;
    impl ::serde::Serialize for SynthesizeTapGestureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SynthesizeTapGestureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SynthesizeTapGestureResponse)
        }
    }
    impl ::CdpCommand for SynthesizeTapGestureResponse {
        const COMMAND_NAME: &'static str = "Input.synthesizeTapGesture";
    }
    impl<'b> ::HasCdpResponse<'b> for SynthesizeTapGestureCommand {
        type Response = SynthesizeTapGestureResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SynthesizeTapGestureResponse {
        type Command = SynthesizeTapGestureCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    pub struct TouchPoint {
        #[serde(rename = "x")]
        #[doc = "X coordinate of the event relative to the main frame's viewport in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to\nthe top of the viewport and Y increases as it proceeds towards the bottom of the viewport."]
        pub y: f64,
        #[serde(rename = "radiusX", skip_serializing_if = "Option::is_none")]
        #[doc = "X radius of the touch area \\(default: 1.0\\)."]
        pub radius_x: Option<f64>,
        #[serde(rename = "radiusY", skip_serializing_if = "Option::is_none")]
        #[doc = "Y radius of the touch area \\(default: 1.0\\)."]
        pub radius_y: Option<f64>,
        #[serde(rename = "rotationAngle", skip_serializing_if = "Option::is_none")]
        #[doc = "Rotation angle \\(default: 0.0\\)."]
        pub rotation_angle: Option<f64>,
        #[serde(rename = "force", skip_serializing_if = "Option::is_none")]
        #[doc = "Force \\(default: 1.0\\)."]
        pub force: Option<f64>,
        #[serde(rename = "id", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier used to track touch sources between events, must be unique within an event."]
        pub id: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum GestureSourceType {
        #[serde(rename = "default")]
        #[doc = "Represented as `\"default\"`."]
        Default,
        #[serde(rename = "touch")]
        #[doc = "Represented as `\"touch\"`."]
        Touch,
        #[serde(rename = "mouse")]
        #[doc = "Represented as `\"mouse\"`."]
        Mouse,
    }
    impl GestureSourceType {
        pub const ENUM_VALUES: &'static [GestureSourceType] = &[
            GestureSourceType::Default,
            GestureSourceType::Touch,
            GestureSourceType::Mouse,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["default", "touch", "mouse"];
    }
    impl ::std::str::FromStr for GestureSourceType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "default" => Ok(GestureSourceType::Default),
                "touch" => Ok(GestureSourceType::Touch),
                "mouse" => Ok(GestureSourceType::Mouse),
                _ => Err(::ParseEnumError {
                    expected: GestureSourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for GestureSourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    GestureSourceType::Default => "default",
                    GestureSourceType::Touch => "touch",
                    GestureSourceType::Mouse => "mouse",
                }
            )
        }
    }
    #[doc = "UTC time in seconds, counted from January 1, 1970."]
    pub type TimeSinceEpoch = f64;
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Inspector\n\n## Commands\n\n- [`Inspector.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables inspector domain notifications.\n- [`Inspector.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables inspector domain notifications.\n\n## Events\n\n- [`Inspector.detached`](struct.DetachedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when remote debugging connection is about to be terminated. Contains detach reason.\n- [`Inspector.targetCrashed`](struct.TargetCrashedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when debugging target has crashed\n- [`Inspector.targetReloadedAfterCrash`](struct.TargetReloadedAfterCrashEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when debugging target has reloaded after crash\n"]
pub mod inspector {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables inspector domain notifications.\n\n# Command `Inspector.disable`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Command Struct:* [`cdp::inspector::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::inspector::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Inspector.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Inspector.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables inspector domain notifications.\n\n# Command `Inspector.disable`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Command Struct:* [`cdp::inspector::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::inspector::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Inspector.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables inspector domain notifications.\n\n# Command `Inspector.enable`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Command Struct:* [`cdp::inspector::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::inspector::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Inspector.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Inspector.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables inspector domain notifications.\n\n# Command `Inspector.enable`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Command Struct:* [`cdp::inspector::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::inspector::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Inspector.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when remote debugging connection is about to be terminated. Contains detach reason.\n\n# Event `Inspector.detached`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Event Struct:* [`cdp::inspector::DetachedEvent`](struct.DetachedEvent.html)"]
    pub struct DetachedEvent<'a> {
        #[serde(rename = "reason")]
        #[doc = "The reason why connection has been terminated."]
        pub reason: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for DetachedEvent<'a> {
        const EVENT_NAME: &'static str = "Inspector.detached";
    }
    impl<'a> ::SerializeCdpEvent for DetachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Inspector.detached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DetachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.detached" {
                Ok(
                    <DetachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when debugging target has crashed\n\n# Event `Inspector.targetCrashed`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Event Struct:* [`cdp::inspector::TargetCrashedEvent`](struct.TargetCrashedEvent.html)"]
    pub struct TargetCrashedEvent;
    impl ::serde::Serialize for TargetCrashedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TargetCrashedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TargetCrashedEvent)
        }
    }
    impl ::CdpEvent for TargetCrashedEvent {
        const EVENT_NAME: &'static str = "Inspector.targetCrashed";
    }
    impl ::SerializeCdpEvent for TargetCrashedEvent {
        fn event_name(&self) -> &str {
            "Inspector.targetCrashed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for TargetCrashedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.targetCrashed" {
                Ok(
                    <TargetCrashedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when debugging target has reloaded after crash\n\n# Event `Inspector.targetReloadedAfterCrash`\n\n*Domain Module:* [`cdp::inspector`](index.html)  \n*Event Struct:* [`cdp::inspector::TargetReloadedAfterCrashEvent`](struct.TargetReloadedAfterCrashEvent.html)"]
    pub struct TargetReloadedAfterCrashEvent;
    impl ::serde::Serialize for TargetReloadedAfterCrashEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TargetReloadedAfterCrashEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TargetReloadedAfterCrashEvent)
        }
    }
    impl ::CdpEvent for TargetReloadedAfterCrashEvent {
        const EVENT_NAME: &'static str = "Inspector.targetReloadedAfterCrash";
    }
    impl ::SerializeCdpEvent for TargetReloadedAfterCrashEvent {
        fn event_name(&self) -> &str {
            "Inspector.targetReloadedAfterCrash"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for TargetReloadedAfterCrashEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Inspector.targetReloadedAfterCrash" {
                Ok ( < TargetReloadedAfterCrashEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# LayerTree\n\n## Commands\n\n- [`LayerTree.compositingReasons`](struct.CompositingReasonsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Provides the reasons why the given layer was composited.\n- [`LayerTree.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables compositing tree inspection.\n- [`LayerTree.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables compositing tree inspection.\n- [`LayerTree.loadSnapshot`](struct.LoadSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the snapshot identifier.\n- [`LayerTree.makeSnapshot`](struct.MakeSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the layer snapshot identifier.\n- [`LayerTree.profileSnapshot`](struct.ProfileSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`LayerTree.releaseSnapshot`](struct.ReleaseSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Releases layer snapshot captured by the back-end.\n- [`LayerTree.replaySnapshot`](struct.ReplaySnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replays the layer snapshot and returns the resulting bitmap.\n- [`LayerTree.snapshotCommandLog`](struct.SnapshotCommandLogCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replays the layer snapshot and returns canvas log.\n\n## Events\n\n- [`LayerTree.layerPainted`](struct.LayerPaintedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`LayerTree.layerTreeDidChange`](struct.LayerTreeDidChangeEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`LayerId`](type.LayerId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique Layer identifier.\n- [`SnapshotId`](type.SnapshotId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique snapshot identifier.\n- [`ScrollRect`](struct.ScrollRect.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Rectangle where scrolling happens on the main thread.\n- [`StickyPositionConstraint`](struct.StickyPositionConstraint.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sticky position constraints.\n- [`PictureTile`](struct.PictureTile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Serialized fragment of layer picture along with its offset within the layer.\n- [`Layer`](struct.Layer.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a compositing layer.\n- [`PaintProfile`](type.PaintProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Array of timings, one per paint step.\n"]
pub mod layer_tree {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides the reasons why the given layer was composited.\n\n# Command `LayerTree.compositingReasons`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::CompositingReasonsCommand`](struct.CompositingReasonsCommand.html)  \n*Response Struct:* [`cdp::layer_tree::CompositingReasonsResponse`](struct.CompositingReasonsResponse.html)"]
    pub struct CompositingReasonsCommand<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the layer for which we want to get the reasons it was composited."]
        pub layer_id: ::layer_tree::LayerId<'a>,
    }
    impl<'a> ::CdpCommand for CompositingReasonsCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.compositingReasons";
    }
    impl<'a> ::SerializeCdpCommand for CompositingReasonsCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.compositingReasons"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CompositingReasonsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.compositingReasons" {
                Ok ( < CompositingReasonsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides the reasons why the given layer was composited.\n\n# Command `LayerTree.compositingReasons`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::CompositingReasonsCommand`](struct.CompositingReasonsCommand.html)  \n*Response Struct:* [`cdp::layer_tree::CompositingReasonsResponse`](struct.CompositingReasonsResponse.html)"]
    pub struct CompositingReasonsResponse<'a> {
        #[serde(rename = "compositingReasons")]
        #[doc = "A list of strings specifying reasons for the given layer to become composited."]
        pub compositing_reasons: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CompositingReasonsResponse<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.compositingReasons";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CompositingReasonsCommand<'a> {
        type Response = CompositingReasonsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CompositingReasonsResponse<'b> {
        type Command = CompositingReasonsCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables compositing tree inspection.\n\n# Command `LayerTree.disable`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::layer_tree::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "LayerTree.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "LayerTree.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables compositing tree inspection.\n\n# Command `LayerTree.disable`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::layer_tree::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "LayerTree.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables compositing tree inspection.\n\n# Command `LayerTree.enable`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::layer_tree::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "LayerTree.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "LayerTree.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables compositing tree inspection.\n\n# Command `LayerTree.enable`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::layer_tree::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "LayerTree.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the snapshot identifier.\n\n# Command `LayerTree.loadSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::LoadSnapshotCommand`](struct.LoadSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::LoadSnapshotResponse`](struct.LoadSnapshotResponse.html)"]
    pub struct LoadSnapshotCommand<'a> {
        #[serde(rename = "tiles")]
        #[doc = "An array of tiles composing the snapshot."]
        pub tiles: Vec<::layer_tree::PictureTile<'a>>,
    }
    impl<'a> ::CdpCommand for LoadSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.loadSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for LoadSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.loadSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for LoadSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.loadSnapshot" {
                Ok(
                    <LoadSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the snapshot identifier.\n\n# Command `LayerTree.loadSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::LoadSnapshotCommand`](struct.LoadSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::LoadSnapshotResponse`](struct.LoadSnapshotResponse.html)"]
    pub struct LoadSnapshotResponse<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::CdpCommand for LoadSnapshotResponse<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.loadSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for LoadSnapshotCommand<'a> {
        type Response = LoadSnapshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for LoadSnapshotResponse<'b> {
        type Command = LoadSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the layer snapshot identifier.\n\n# Command `LayerTree.makeSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::MakeSnapshotCommand`](struct.MakeSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::MakeSnapshotResponse`](struct.MakeSnapshotResponse.html)"]
    pub struct MakeSnapshotCommand<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the layer."]
        pub layer_id: ::layer_tree::LayerId<'a>,
    }
    impl<'a> ::CdpCommand for MakeSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.makeSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for MakeSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.makeSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for MakeSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.makeSnapshot" {
                Ok(
                    <MakeSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the layer snapshot identifier.\n\n# Command `LayerTree.makeSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::MakeSnapshotCommand`](struct.MakeSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::MakeSnapshotResponse`](struct.MakeSnapshotResponse.html)"]
    pub struct MakeSnapshotResponse<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::CdpCommand for MakeSnapshotResponse<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.makeSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for MakeSnapshotCommand<'a> {
        type Response = MakeSnapshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for MakeSnapshotResponse<'b> {
        type Command = MakeSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `LayerTree.profileSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ProfileSnapshotCommand`](struct.ProfileSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ProfileSnapshotResponse`](struct.ProfileSnapshotResponse.html)"]
    pub struct ProfileSnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
        #[serde(rename = "minRepeatCount", skip_serializing_if = "Option::is_none")]
        #[doc = "The maximum number of times to replay the snapshot \\(1, if not specified\\)."]
        pub min_repeat_count: Option<i32>,
        #[serde(rename = "minDuration", skip_serializing_if = "Option::is_none")]
        #[doc = "The minimum duration \\(in seconds\\) to replay the snapshot."]
        pub min_duration: Option<f64>,
        #[serde(rename = "clipRect", skip_serializing_if = "Option::is_none")]
        #[doc = "The clip rectangle to apply when replaying the snapshot."]
        pub clip_rect: Option<::dom::Rect>,
    }
    impl<'a> ::CdpCommand for ProfileSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.profileSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for ProfileSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.profileSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ProfileSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.profileSnapshot" {
                Ok(
                    <ProfileSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `LayerTree.profileSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ProfileSnapshotCommand`](struct.ProfileSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ProfileSnapshotResponse`](struct.ProfileSnapshotResponse.html)"]
    pub struct ProfileSnapshotResponse {
        #[serde(rename = "timings")]
        #[doc = "The array of paint profiles, one per run."]
        pub timings: Vec<::layer_tree::PaintProfile>,
    }
    impl ::CdpCommand for ProfileSnapshotResponse {
        const COMMAND_NAME: &'static str = "LayerTree.profileSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ProfileSnapshotCommand<'a> {
        type Response = ProfileSnapshotResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ProfileSnapshotResponse {
        type Command = ProfileSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases layer snapshot captured by the back-end.\n\n# Command `LayerTree.releaseSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ReleaseSnapshotCommand`](struct.ReleaseSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ReleaseSnapshotResponse`](struct.ReleaseSnapshotResponse.html)"]
    pub struct ReleaseSnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::CdpCommand for ReleaseSnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.releaseSnapshot";
    }
    impl<'a> ::SerializeCdpCommand for ReleaseSnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.releaseSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReleaseSnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.releaseSnapshot" {
                Ok(
                    <ReleaseSnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Releases layer snapshot captured by the back-end.\n\n# Command `LayerTree.releaseSnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ReleaseSnapshotCommand`](struct.ReleaseSnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ReleaseSnapshotResponse`](struct.ReleaseSnapshotResponse.html)"]
    pub struct ReleaseSnapshotResponse;
    impl ::serde::Serialize for ReleaseSnapshotResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseSnapshotResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseSnapshotResponse)
        }
    }
    impl ::CdpCommand for ReleaseSnapshotResponse {
        const COMMAND_NAME: &'static str = "LayerTree.releaseSnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReleaseSnapshotCommand<'a> {
        type Response = ReleaseSnapshotResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReleaseSnapshotResponse {
        type Command = ReleaseSnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns the resulting bitmap.\n\n# Command `LayerTree.replaySnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ReplaySnapshotCommand`](struct.ReplaySnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ReplaySnapshotResponse`](struct.ReplaySnapshotResponse.html)"]
    pub struct ReplaySnapshotCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
        #[serde(rename = "fromStep", skip_serializing_if = "Option::is_none")]
        #[doc = "The first step to replay from \\(replay from the very start if not specified\\)."]
        pub from_step: Option<i32>,
        #[serde(rename = "toStep", skip_serializing_if = "Option::is_none")]
        #[doc = "The last step to replay to \\(replay till the end if not specified\\)."]
        pub to_step: Option<i32>,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "The scale to apply while replaying \\(defaults to 1\\)."]
        pub scale: Option<f64>,
    }
    impl<'a> ::CdpCommand for ReplaySnapshotCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.replaySnapshot";
    }
    impl<'a> ::SerializeCdpCommand for ReplaySnapshotCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.replaySnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReplaySnapshotCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.replaySnapshot" {
                Ok(
                    <ReplaySnapshotCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns the resulting bitmap.\n\n# Command `LayerTree.replaySnapshot`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::ReplaySnapshotCommand`](struct.ReplaySnapshotCommand.html)  \n*Response Struct:* [`cdp::layer_tree::ReplaySnapshotResponse`](struct.ReplaySnapshotResponse.html)"]
    pub struct ReplaySnapshotResponse<'a> {
        #[serde(rename = "dataURL")]
        #[doc = "A data: URL for resulting image."]
        pub data_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ReplaySnapshotResponse<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.replaySnapshot";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReplaySnapshotCommand<'a> {
        type Response = ReplaySnapshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for ReplaySnapshotResponse<'b> {
        type Command = ReplaySnapshotCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns canvas log.\n\n# Command `LayerTree.snapshotCommandLog`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::SnapshotCommandLogCommand`](struct.SnapshotCommandLogCommand.html)  \n*Response Struct:* [`cdp::layer_tree::SnapshotCommandLogResponse`](struct.SnapshotCommandLogResponse.html)"]
    pub struct SnapshotCommandLogCommand<'a> {
        #[serde(rename = "snapshotId")]
        #[doc = "The id of the layer snapshot."]
        pub snapshot_id: ::layer_tree::SnapshotId<'a>,
    }
    impl<'a> ::CdpCommand for SnapshotCommandLogCommand<'a> {
        const COMMAND_NAME: &'static str = "LayerTree.snapshotCommandLog";
    }
    impl<'a> ::SerializeCdpCommand for SnapshotCommandLogCommand<'a> {
        fn command_name(&self) -> &str {
            "LayerTree.snapshotCommandLog"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SnapshotCommandLogCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.snapshotCommandLog" {
                Ok ( < SnapshotCommandLogCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replays the layer snapshot and returns canvas log.\n\n# Command `LayerTree.snapshotCommandLog`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Command Struct:* [`cdp::layer_tree::SnapshotCommandLogCommand`](struct.SnapshotCommandLogCommand.html)  \n*Response Struct:* [`cdp::layer_tree::SnapshotCommandLogResponse`](struct.SnapshotCommandLogResponse.html)"]
    pub struct SnapshotCommandLogResponse {
        #[serde(rename = "commandLog")]
        #[doc = "The array of canvas function calls."]
        pub command_log: Vec<::Empty>,
    }
    impl ::CdpCommand for SnapshotCommandLogResponse {
        const COMMAND_NAME: &'static str = "LayerTree.snapshotCommandLog";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SnapshotCommandLogCommand<'a> {
        type Response = SnapshotCommandLogResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SnapshotCommandLogResponse {
        type Command = SnapshotCommandLogCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `LayerTree.layerPainted`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Event Struct:* [`cdp::layer_tree::LayerPaintedEvent`](struct.LayerPaintedEvent.html)"]
    pub struct LayerPaintedEvent<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The id of the painted layer."]
        pub layer_id: ::layer_tree::LayerId<'a>,
        #[serde(rename = "clip")]
        #[doc = "Clip rectangle."]
        pub clip: ::dom::Rect,
    }
    impl<'a> ::CdpEvent for LayerPaintedEvent<'a> {
        const EVENT_NAME: &'static str = "LayerTree.layerPainted";
    }
    impl<'a> ::SerializeCdpEvent for LayerPaintedEvent<'a> {
        fn event_name(&self) -> &str {
            "LayerTree.layerPainted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for LayerPaintedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.layerPainted" {
                Ok(
                    <LayerPaintedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `LayerTree.layerTreeDidChange`\n\n*Domain Module:* [`cdp::layer_tree`](index.html)  \n*Event Struct:* [`cdp::layer_tree::LayerTreeDidChangeEvent`](struct.LayerTreeDidChangeEvent.html)"]
    pub struct LayerTreeDidChangeEvent<'a> {
        #[serde(rename = "layers", skip_serializing_if = "Option::is_none")]
        #[doc = "Layer tree, absent if not in the comspositing mode."]
        pub layers: Option<Vec<::layer_tree::Layer<'a>>>,
    }
    impl<'a> ::CdpEvent for LayerTreeDidChangeEvent<'a> {
        const EVENT_NAME: &'static str = "LayerTree.layerTreeDidChange";
    }
    impl<'a> ::SerializeCdpEvent for LayerTreeDidChangeEvent<'a> {
        fn event_name(&self) -> &str {
            "LayerTree.layerTreeDidChange"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for LayerTreeDidChangeEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "LayerTree.layerTreeDidChange" {
                Ok ( < LayerTreeDidChangeEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique Layer identifier."]
    pub type LayerId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique snapshot identifier."]
    pub type SnapshotId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::layer_tree::ScrollRect::ty`](struct.ScrollRect.html#structfield.ty)."]
    pub enum ScrollRectType {
        #[serde(rename = "RepaintsOnScroll")]
        #[doc = "Represented as `\"RepaintsOnScroll\"`."]
        RepaintsOnScroll,
        #[serde(rename = "TouchEventHandler")]
        #[doc = "Represented as `\"TouchEventHandler\"`."]
        TouchEventHandler,
        #[serde(rename = "WheelEventHandler")]
        #[doc = "Represented as `\"WheelEventHandler\"`."]
        WheelEventHandler,
    }
    impl ScrollRectType {
        pub const ENUM_VALUES: &'static [ScrollRectType] = &[
            ScrollRectType::RepaintsOnScroll,
            ScrollRectType::TouchEventHandler,
            ScrollRectType::WheelEventHandler,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["RepaintsOnScroll", "TouchEventHandler", "WheelEventHandler"];
    }
    impl ::std::str::FromStr for ScrollRectType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "RepaintsOnScroll" => Ok(ScrollRectType::RepaintsOnScroll),
                "TouchEventHandler" => Ok(ScrollRectType::TouchEventHandler),
                "WheelEventHandler" => Ok(ScrollRectType::WheelEventHandler),
                _ => Err(::ParseEnumError {
                    expected: ScrollRectType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScrollRectType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScrollRectType::RepaintsOnScroll => "RepaintsOnScroll",
                    ScrollRectType::TouchEventHandler => "TouchEventHandler",
                    ScrollRectType::WheelEventHandler => "WheelEventHandler",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Rectangle where scrolling happens on the main thread."]
    pub struct ScrollRect {
        #[serde(rename = "rect")]
        #[doc = "Rectangle itself."]
        pub rect: ::dom::Rect,
        #[serde(rename = "type")]
        #[doc = "Reason for rectangle to force scrolling on the main thread"]
        pub ty: ::layer_tree::ScrollRectType,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sticky position constraints."]
    pub struct StickyPositionConstraint<'a> {
        #[serde(rename = "stickyBoxRect")]
        #[doc = "Layout rectangle of the sticky element before being shifted"]
        pub sticky_box_rect: ::dom::Rect,
        #[serde(rename = "containingBlockRect")]
        #[doc = "Layout rectangle of the containing block of the sticky element"]
        pub containing_block_rect: ::dom::Rect,
        #[serde(rename = "nearestLayerShiftingStickyBox", skip_serializing_if = "Option::is_none")]
        #[doc = "The nearest sticky layer that shifts the sticky box"]
        pub nearest_layer_shifting_sticky_box: Option<::layer_tree::LayerId<'a>>,
        #[serde(rename = "nearestLayerShiftingContainingBlock",
                skip_serializing_if = "Option::is_none")]
        #[doc = "The nearest sticky layer that shifts the containing block"]
        pub nearest_layer_shifting_containing_block: Option<::layer_tree::LayerId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Serialized fragment of layer picture along with its offset within the layer."]
    pub struct PictureTile<'a> {
        #[serde(rename = "x")]
        #[doc = "Offset from owning layer left boundary"]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Offset from owning layer top boundary"]
        pub y: f64,
        #[serde(rename = "picture")]
        #[doc = "Base64-encoded snapshot data."]
        pub picture: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a compositing layer."]
    pub struct Layer<'a> {
        #[serde(rename = "layerId")]
        #[doc = "The unique id for this layer."]
        pub layer_id: ::layer_tree::LayerId<'a>,
        #[serde(rename = "parentLayerId", skip_serializing_if = "Option::is_none")]
        #[doc = "The id of parent \\(not present for root\\)."]
        pub parent_layer_id: Option<::layer_tree::LayerId<'a>>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "The backend id for the node associated with this layer."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "offsetX")]
        #[doc = "Offset from parent layer, X coordinate."]
        pub offset_x: f64,
        #[serde(rename = "offsetY")]
        #[doc = "Offset from parent layer, Y coordinate."]
        pub offset_y: f64,
        #[serde(rename = "width")]
        #[doc = "Layer width."]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Layer height."]
        pub height: f64,
        #[serde(rename = "transform", skip_serializing_if = "Option::is_none")]
        #[doc = "Transformation matrix for layer, default is identity matrix"]
        pub transform: Option<Vec<f64>>,
        #[serde(rename = "anchorX", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point X, absent if no transform specified"]
        pub anchor_x: Option<f64>,
        #[serde(rename = "anchorY", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point Y, absent if no transform specified"]
        pub anchor_y: Option<f64>,
        #[serde(rename = "anchorZ", skip_serializing_if = "Option::is_none")]
        #[doc = "Transform anchor point Z, absent if no transform specified"]
        pub anchor_z: Option<f64>,
        #[serde(rename = "paintCount")]
        #[doc = "Indicates how many time this layer has painted."]
        pub paint_count: i32,
        #[serde(rename = "drawsContent")]
        #[doc = "Indicates whether this layer hosts any content, rather than being used for\ntransform/scrolling purposes only."]
        pub draws_content: bool,
        #[serde(rename = "invisible", skip_serializing_if = "Option::is_none")]
        #[doc = "Set if layer is not visible."]
        pub invisible: Option<bool>,
        #[serde(rename = "scrollRects", skip_serializing_if = "Option::is_none")]
        #[doc = "Rectangles scrolling on main thread only."]
        pub scroll_rects: Option<Vec<::layer_tree::ScrollRect>>,
        #[serde(rename = "stickyPositionConstraint", skip_serializing_if = "Option::is_none")]
        #[doc = "Sticky position constraint information"]
        pub sticky_position_constraint: Option<::layer_tree::StickyPositionConstraint<'a>>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Array of timings, one per paint step."]
    pub type PaintProfile = Vec<f64>;
}
#[doc = "Provides access to log entries.\n\n# Log\n\n## Commands\n\n- [`Log.clear`](struct.ClearCommand.html)\n\n  Clears the log.\n- [`Log.disable`](struct.DisableCommand.html)\n\n  Disables log domain, prevents further log entries from being reported to the client.\n- [`Log.enable`](struct.EnableCommand.html)\n\n  Enables log domain, sends the entries collected so far to the client by means of the\n  `entryAdded` notification.\n- [`Log.startViolationsReport`](struct.StartViolationsReportCommand.html)\n\n  start violation reporting.\n- [`Log.stopViolationsReport`](struct.StopViolationsReportCommand.html)\n\n  Stop violation reporting.\n\n## Events\n\n- [`Log.entryAdded`](struct.EntryAddedEvent.html)\n\n  Issued when new message was logged.\n\n##Types\n\n- [`LogEntry`](struct.LogEntry.html)\n\n  Log entry.\n- [`ViolationSetting`](struct.ViolationSetting.html)\n\n  Violation configuration setting.\n"]
pub mod log {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the log.\n\n# Command `Log.clear`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::log::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearCommand;
    impl ::serde::Serialize for ClearCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| ClearCommand)
        }
    }
    impl ::CdpCommand for ClearCommand {
        const COMMAND_NAME: &'static str = "Log.clear";
    }
    impl ::SerializeCdpCommand for ClearCommand {
        fn command_name(&self) -> &str {
            "Log.clear"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.clear" {
                Ok(
                    <ClearCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the log.\n\n# Command `Log.clear`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::ClearCommand`](struct.ClearCommand.html)  \n*Response Struct:* [`cdp::log::ClearResponse`](struct.ClearResponse.html)"]
    pub struct ClearResponse;
    impl ::serde::Serialize for ClearResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| ClearResponse)
        }
    }
    impl ::CdpCommand for ClearResponse {
        const COMMAND_NAME: &'static str = "Log.clear";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearCommand {
        type Response = ClearResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearResponse {
        type Command = ClearCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables log domain, prevents further log entries from being reported to the client.\n\n# Command `Log.disable`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::log::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Log.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Log.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables log domain, prevents further log entries from being reported to the client.\n\n# Command `Log.disable`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::log::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Log.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables log domain, sends the entries collected so far to the client by means of the\n`entryAdded` notification.\n\n# Command `Log.enable`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::log::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Log.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Log.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables log domain, sends the entries collected so far to the client by means of the\n`entryAdded` notification.\n\n# Command `Log.enable`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::log::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Log.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "start violation reporting.\n\n# Command `Log.startViolationsReport`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::StartViolationsReportCommand`](struct.StartViolationsReportCommand.html)  \n*Response Struct:* [`cdp::log::StartViolationsReportResponse`](struct.StartViolationsReportResponse.html)"]
    pub struct StartViolationsReportCommand {
        #[serde(rename = "config")]
        #[doc = "Configuration for violations."]
        pub config: Vec<::log::ViolationSetting>,
    }
    impl ::CdpCommand for StartViolationsReportCommand {
        const COMMAND_NAME: &'static str = "Log.startViolationsReport";
    }
    impl ::SerializeCdpCommand for StartViolationsReportCommand {
        fn command_name(&self) -> &str {
            "Log.startViolationsReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartViolationsReportCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.startViolationsReport" {
                Ok ( < StartViolationsReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "start violation reporting.\n\n# Command `Log.startViolationsReport`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::StartViolationsReportCommand`](struct.StartViolationsReportCommand.html)  \n*Response Struct:* [`cdp::log::StartViolationsReportResponse`](struct.StartViolationsReportResponse.html)"]
    pub struct StartViolationsReportResponse;
    impl ::serde::Serialize for StartViolationsReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartViolationsReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartViolationsReportResponse)
        }
    }
    impl ::CdpCommand for StartViolationsReportResponse {
        const COMMAND_NAME: &'static str = "Log.startViolationsReport";
    }
    impl<'b> ::HasCdpResponse<'b> for StartViolationsReportCommand {
        type Response = StartViolationsReportResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartViolationsReportResponse {
        type Command = StartViolationsReportCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stop violation reporting.\n\n# Command `Log.stopViolationsReport`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::StopViolationsReportCommand`](struct.StopViolationsReportCommand.html)  \n*Response Struct:* [`cdp::log::StopViolationsReportResponse`](struct.StopViolationsReportResponse.html)"]
    pub struct StopViolationsReportCommand;
    impl ::serde::Serialize for StopViolationsReportCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopViolationsReportCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopViolationsReportCommand)
        }
    }
    impl ::CdpCommand for StopViolationsReportCommand {
        const COMMAND_NAME: &'static str = "Log.stopViolationsReport";
    }
    impl ::SerializeCdpCommand for StopViolationsReportCommand {
        fn command_name(&self) -> &str {
            "Log.stopViolationsReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopViolationsReportCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.stopViolationsReport" {
                Ok ( < StopViolationsReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stop violation reporting.\n\n# Command `Log.stopViolationsReport`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Command Struct:* [`cdp::log::StopViolationsReportCommand`](struct.StopViolationsReportCommand.html)  \n*Response Struct:* [`cdp::log::StopViolationsReportResponse`](struct.StopViolationsReportResponse.html)"]
    pub struct StopViolationsReportResponse;
    impl ::serde::Serialize for StopViolationsReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopViolationsReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopViolationsReportResponse)
        }
    }
    impl ::CdpCommand for StopViolationsReportResponse {
        const COMMAND_NAME: &'static str = "Log.stopViolationsReport";
    }
    impl<'b> ::HasCdpResponse<'b> for StopViolationsReportCommand {
        type Response = StopViolationsReportResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopViolationsReportResponse {
        type Command = StopViolationsReportCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when new message was logged.\n\n# Event `Log.entryAdded`\n\n*Domain Module:* [`cdp::log`](index.html)  \n*Event Struct:* [`cdp::log::EntryAddedEvent`](struct.EntryAddedEvent.html)"]
    pub struct EntryAddedEvent<'a> {
        #[serde(rename = "entry")]
        #[doc = "The entry."]
        pub entry: ::log::LogEntry<'a>,
    }
    impl<'a> ::CdpEvent for EntryAddedEvent<'a> {
        const EVENT_NAME: &'static str = "Log.entryAdded";
    }
    impl<'a> ::SerializeCdpEvent for EntryAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "Log.entryAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for EntryAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Log.entryAdded" {
                Ok(
                    <EntryAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::log::LogEntry::source`](struct.LogEntry.html#structfield.source)."]
    pub enum LogEntrySource {
        #[serde(rename = "xml")]
        #[doc = "Represented as `\"xml\"`."]
        Xml,
        #[serde(rename = "javascript")]
        #[doc = "Represented as `\"javascript\"`."]
        Javascript,
        #[serde(rename = "network")]
        #[doc = "Represented as `\"network\"`."]
        Network,
        #[serde(rename = "storage")]
        #[doc = "Represented as `\"storage\"`."]
        Storage,
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "rendering")]
        #[doc = "Represented as `\"rendering\"`."]
        Rendering,
        #[serde(rename = "security")]
        #[doc = "Represented as `\"security\"`."]
        Security,
        #[serde(rename = "deprecation")]
        #[doc = "Represented as `\"deprecation\"`."]
        Deprecation,
        #[serde(rename = "worker")]
        #[doc = "Represented as `\"worker\"`."]
        Worker,
        #[serde(rename = "violation")]
        #[doc = "Represented as `\"violation\"`."]
        Violation,
        #[serde(rename = "intervention")]
        #[doc = "Represented as `\"intervention\"`."]
        Intervention,
        #[serde(rename = "recommendation")]
        #[doc = "Represented as `\"recommendation\"`."]
        Recommendation,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl LogEntrySource {
        pub const ENUM_VALUES: &'static [LogEntrySource] = &[
            LogEntrySource::Xml,
            LogEntrySource::Javascript,
            LogEntrySource::Network,
            LogEntrySource::Storage,
            LogEntrySource::Appcache,
            LogEntrySource::Rendering,
            LogEntrySource::Security,
            LogEntrySource::Deprecation,
            LogEntrySource::Worker,
            LogEntrySource::Violation,
            LogEntrySource::Intervention,
            LogEntrySource::Recommendation,
            LogEntrySource::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "xml",
            "javascript",
            "network",
            "storage",
            "appcache",
            "rendering",
            "security",
            "deprecation",
            "worker",
            "violation",
            "intervention",
            "recommendation",
            "other",
        ];
    }
    impl ::std::str::FromStr for LogEntrySource {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "xml" => Ok(LogEntrySource::Xml),
                "javascript" => Ok(LogEntrySource::Javascript),
                "network" => Ok(LogEntrySource::Network),
                "storage" => Ok(LogEntrySource::Storage),
                "appcache" => Ok(LogEntrySource::Appcache),
                "rendering" => Ok(LogEntrySource::Rendering),
                "security" => Ok(LogEntrySource::Security),
                "deprecation" => Ok(LogEntrySource::Deprecation),
                "worker" => Ok(LogEntrySource::Worker),
                "violation" => Ok(LogEntrySource::Violation),
                "intervention" => Ok(LogEntrySource::Intervention),
                "recommendation" => Ok(LogEntrySource::Recommendation),
                "other" => Ok(LogEntrySource::Other),
                _ => Err(::ParseEnumError {
                    expected: LogEntrySource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for LogEntrySource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    LogEntrySource::Xml => "xml",
                    LogEntrySource::Javascript => "javascript",
                    LogEntrySource::Network => "network",
                    LogEntrySource::Storage => "storage",
                    LogEntrySource::Appcache => "appcache",
                    LogEntrySource::Rendering => "rendering",
                    LogEntrySource::Security => "security",
                    LogEntrySource::Deprecation => "deprecation",
                    LogEntrySource::Worker => "worker",
                    LogEntrySource::Violation => "violation",
                    LogEntrySource::Intervention => "intervention",
                    LogEntrySource::Recommendation => "recommendation",
                    LogEntrySource::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::log::LogEntry::level`](struct.LogEntry.html#structfield.level)."]
    pub enum LogEntryLevel {
        #[serde(rename = "verbose")]
        #[doc = "Represented as `\"verbose\"`."]
        Verbose,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl LogEntryLevel {
        pub const ENUM_VALUES: &'static [LogEntryLevel] = &[
            LogEntryLevel::Verbose,
            LogEntryLevel::Info,
            LogEntryLevel::Warning,
            LogEntryLevel::Error,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["verbose", "info", "warning", "error"];
    }
    impl ::std::str::FromStr for LogEntryLevel {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "verbose" => Ok(LogEntryLevel::Verbose),
                "info" => Ok(LogEntryLevel::Info),
                "warning" => Ok(LogEntryLevel::Warning),
                "error" => Ok(LogEntryLevel::Error),
                _ => Err(::ParseEnumError {
                    expected: LogEntryLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for LogEntryLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    LogEntryLevel::Verbose => "verbose",
                    LogEntryLevel::Info => "info",
                    LogEntryLevel::Warning => "warning",
                    LogEntryLevel::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Log entry."]
    pub struct LogEntry<'a> {
        #[serde(rename = "source")]
        #[doc = "Log entry source."]
        pub source: ::log::LogEntrySource,
        #[serde(rename = "level")]
        #[doc = "Log entry severity."]
        pub level: ::log::LogEntryLevel,
        #[serde(rename = "text")]
        #[doc = "Logged text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp when this entry was added."]
        pub timestamp: ::runtime::Timestamp,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the resource if known."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "lineNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Line number in the resource."]
        pub line_number: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript stack trace."]
        pub stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "networkRequestId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the network request associated with this entry."]
        pub network_request_id: Option<::network::RequestId<'a>>,
        #[serde(rename = "workerId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the worker associated with this entry."]
        pub worker_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "args", skip_serializing_if = "Option::is_none")]
        #[doc = "Call arguments."]
        pub args: Option<Vec<::runtime::RemoteObject<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::log::ViolationSetting::name`](struct.ViolationSetting.html#structfield.name)."]
    pub enum ViolationSettingName {
        #[serde(rename = "longTask")]
        #[doc = "Represented as `\"longTask\"`."]
        LongTask,
        #[serde(rename = "longLayout")]
        #[doc = "Represented as `\"longLayout\"`."]
        LongLayout,
        #[serde(rename = "blockedEvent")]
        #[doc = "Represented as `\"blockedEvent\"`."]
        BlockedEvent,
        #[serde(rename = "blockedParser")]
        #[doc = "Represented as `\"blockedParser\"`."]
        BlockedParser,
        #[serde(rename = "discouragedAPIUse")]
        #[doc = "Represented as `\"discouragedAPIUse\"`."]
        DiscouragedApiUse,
        #[serde(rename = "handler")]
        #[doc = "Represented as `\"handler\"`."]
        Handler,
        #[serde(rename = "recurringHandler")]
        #[doc = "Represented as `\"recurringHandler\"`."]
        RecurringHandler,
    }
    impl ViolationSettingName {
        pub const ENUM_VALUES: &'static [ViolationSettingName] =
            &[
                ViolationSettingName::LongTask,
                ViolationSettingName::LongLayout,
                ViolationSettingName::BlockedEvent,
                ViolationSettingName::BlockedParser,
                ViolationSettingName::DiscouragedApiUse,
                ViolationSettingName::Handler,
                ViolationSettingName::RecurringHandler,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "longTask",
            "longLayout",
            "blockedEvent",
            "blockedParser",
            "discouragedAPIUse",
            "handler",
            "recurringHandler",
        ];
    }
    impl ::std::str::FromStr for ViolationSettingName {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "longTask" => Ok(ViolationSettingName::LongTask),
                "longLayout" => Ok(ViolationSettingName::LongLayout),
                "blockedEvent" => Ok(ViolationSettingName::BlockedEvent),
                "blockedParser" => Ok(ViolationSettingName::BlockedParser),
                "discouragedAPIUse" => Ok(ViolationSettingName::DiscouragedApiUse),
                "handler" => Ok(ViolationSettingName::Handler),
                "recurringHandler" => Ok(ViolationSettingName::RecurringHandler),
                _ => Err(::ParseEnumError {
                    expected: ViolationSettingName::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ViolationSettingName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ViolationSettingName::LongTask => "longTask",
                    ViolationSettingName::LongLayout => "longLayout",
                    ViolationSettingName::BlockedEvent => "blockedEvent",
                    ViolationSettingName::BlockedParser => "blockedParser",
                    ViolationSettingName::DiscouragedApiUse => "discouragedAPIUse",
                    ViolationSettingName::Handler => "handler",
                    ViolationSettingName::RecurringHandler => "recurringHandler",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Violation configuration setting."]
    pub struct ViolationSetting {
        #[serde(rename = "name")]
        #[doc = "Violation type."]
        pub name: ::log::ViolationSettingName,
        #[serde(rename = "threshold")]
        #[doc = "Time threshold to trigger upon."]
        pub threshold: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Memory\n\n## Commands\n\n- [`Memory.getDOMCounters`](struct.GetDomCountersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Memory.prepareForLeakDetection`](struct.PrepareForLeakDetectionCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Memory.setPressureNotificationsSuppressed`](struct.SetPressureNotificationsSuppressedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable/disable suppressing memory pressure notifications in all processes.\n- [`Memory.simulatePressureNotification`](struct.SimulatePressureNotificationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Simulate a memory pressure notification in all processes.\n- [`Memory.startSampling`](struct.StartSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Start collecting native memory profile.\n- [`Memory.stopSampling`](struct.StopSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stop collecting native memory profile.\n- [`Memory.getAllTimeSamplingProfile`](struct.GetAllTimeSamplingProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Retrieve native memory allocations profile\n  collected since renderer process startup.\n- [`Memory.getBrowserSamplingProfile`](struct.GetBrowserSamplingProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Retrieve native memory allocations profile\n  collected since browser process startup.\n- [`Memory.getSamplingProfile`](struct.GetSamplingProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Retrieve native memory allocations profile collected since last\n  `startSampling` call.\n\n##Types\n\n- [`PressureLevel`](enum.PressureLevel.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Memory pressure level.\n- [`SamplingProfileNode`](struct.SamplingProfileNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Heap profile sample.\n- [`SamplingProfile`](struct.SamplingProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Array of heap profile samples.\n- [`Module`](struct.Module.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Executable module information\n"]
pub mod memory {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.getDOMCounters`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetDomCountersCommand`](struct.GetDomCountersCommand.html)  \n*Response Struct:* [`cdp::memory::GetDomCountersResponse`](struct.GetDomCountersResponse.html)"]
    pub struct GetDomCountersCommand;
    impl ::serde::Serialize for GetDomCountersCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetDomCountersCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetDomCountersCommand)
        }
    }
    impl ::CdpCommand for GetDomCountersCommand {
        const COMMAND_NAME: &'static str = "Memory.getDOMCounters";
    }
    impl ::SerializeCdpCommand for GetDomCountersCommand {
        fn command_name(&self) -> &str {
            "Memory.getDOMCounters"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetDomCountersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.getDOMCounters" {
                Ok(
                    <GetDomCountersCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.getDOMCounters`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetDomCountersCommand`](struct.GetDomCountersCommand.html)  \n*Response Struct:* [`cdp::memory::GetDomCountersResponse`](struct.GetDomCountersResponse.html)"]
    pub struct GetDomCountersResponse {
        #[serde(rename = "documents")]
        pub documents: i32,
        #[serde(rename = "nodes")]
        pub nodes: i32,
        #[serde(rename = "jsEventListeners")]
        pub js_event_listeners: i32,
    }
    impl ::CdpCommand for GetDomCountersResponse {
        const COMMAND_NAME: &'static str = "Memory.getDOMCounters";
    }
    impl<'b> ::HasCdpResponse<'b> for GetDomCountersCommand {
        type Response = GetDomCountersResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetDomCountersResponse {
        type Command = GetDomCountersCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.prepareForLeakDetection`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::PrepareForLeakDetectionCommand`](struct.PrepareForLeakDetectionCommand.html)  \n*Response Struct:* [`cdp::memory::PrepareForLeakDetectionResponse`](struct.PrepareForLeakDetectionResponse.html)"]
    pub struct PrepareForLeakDetectionCommand;
    impl ::serde::Serialize for PrepareForLeakDetectionCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareForLeakDetectionCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| PrepareForLeakDetectionCommand)
        }
    }
    impl ::CdpCommand for PrepareForLeakDetectionCommand {
        const COMMAND_NAME: &'static str = "Memory.prepareForLeakDetection";
    }
    impl ::SerializeCdpCommand for PrepareForLeakDetectionCommand {
        fn command_name(&self) -> &str {
            "Memory.prepareForLeakDetection"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for PrepareForLeakDetectionCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.prepareForLeakDetection" {
                Ok ( < PrepareForLeakDetectionCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Memory.prepareForLeakDetection`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::PrepareForLeakDetectionCommand`](struct.PrepareForLeakDetectionCommand.html)  \n*Response Struct:* [`cdp::memory::PrepareForLeakDetectionResponse`](struct.PrepareForLeakDetectionResponse.html)"]
    pub struct PrepareForLeakDetectionResponse;
    impl ::serde::Serialize for PrepareForLeakDetectionResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PrepareForLeakDetectionResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| PrepareForLeakDetectionResponse)
        }
    }
    impl ::CdpCommand for PrepareForLeakDetectionResponse {
        const COMMAND_NAME: &'static str = "Memory.prepareForLeakDetection";
    }
    impl<'b> ::HasCdpResponse<'b> for PrepareForLeakDetectionCommand {
        type Response = PrepareForLeakDetectionResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for PrepareForLeakDetectionResponse {
        type Command = PrepareForLeakDetectionCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable suppressing memory pressure notifications in all processes.\n\n# Command `Memory.setPressureNotificationsSuppressed`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::SetPressureNotificationsSuppressedCommand`](struct.SetPressureNotificationsSuppressedCommand.html)  \n*Response Struct:* [`cdp::memory::SetPressureNotificationsSuppressedResponse`](struct.SetPressureNotificationsSuppressedResponse.html)"]
    pub struct SetPressureNotificationsSuppressedCommand {
        #[serde(rename = "suppressed")]
        #[doc = "If true, memory pressure notifications will be suppressed."]
        pub suppressed: bool,
    }
    impl ::CdpCommand for SetPressureNotificationsSuppressedCommand {
        const COMMAND_NAME: &'static str = "Memory.setPressureNotificationsSuppressed";
    }
    impl ::SerializeCdpCommand for SetPressureNotificationsSuppressedCommand {
        fn command_name(&self) -> &str {
            "Memory.setPressureNotificationsSuppressed"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetPressureNotificationsSuppressedCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.setPressureNotificationsSuppressed" {
                Ok ( < SetPressureNotificationsSuppressedCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable suppressing memory pressure notifications in all processes.\n\n# Command `Memory.setPressureNotificationsSuppressed`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::SetPressureNotificationsSuppressedCommand`](struct.SetPressureNotificationsSuppressedCommand.html)  \n*Response Struct:* [`cdp::memory::SetPressureNotificationsSuppressedResponse`](struct.SetPressureNotificationsSuppressedResponse.html)"]
    pub struct SetPressureNotificationsSuppressedResponse;
    impl ::serde::Serialize for SetPressureNotificationsSuppressedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPressureNotificationsSuppressedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPressureNotificationsSuppressedResponse)
        }
    }
    impl ::CdpCommand for SetPressureNotificationsSuppressedResponse {
        const COMMAND_NAME: &'static str = "Memory.setPressureNotificationsSuppressed";
    }
    impl<'b> ::HasCdpResponse<'b> for SetPressureNotificationsSuppressedCommand {
        type Response = SetPressureNotificationsSuppressedResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPressureNotificationsSuppressedResponse {
        type Command = SetPressureNotificationsSuppressedCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Simulate a memory pressure notification in all processes.\n\n# Command `Memory.simulatePressureNotification`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::SimulatePressureNotificationCommand`](struct.SimulatePressureNotificationCommand.html)  \n*Response Struct:* [`cdp::memory::SimulatePressureNotificationResponse`](struct.SimulatePressureNotificationResponse.html)"]
    pub struct SimulatePressureNotificationCommand {
        #[serde(rename = "level")]
        #[doc = "Memory pressure level of the notification."]
        pub level: ::memory::PressureLevel,
    }
    impl ::CdpCommand for SimulatePressureNotificationCommand {
        const COMMAND_NAME: &'static str = "Memory.simulatePressureNotification";
    }
    impl ::SerializeCdpCommand for SimulatePressureNotificationCommand {
        fn command_name(&self) -> &str {
            "Memory.simulatePressureNotification"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SimulatePressureNotificationCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.simulatePressureNotification" {
                Ok ( < SimulatePressureNotificationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Simulate a memory pressure notification in all processes.\n\n# Command `Memory.simulatePressureNotification`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::SimulatePressureNotificationCommand`](struct.SimulatePressureNotificationCommand.html)  \n*Response Struct:* [`cdp::memory::SimulatePressureNotificationResponse`](struct.SimulatePressureNotificationResponse.html)"]
    pub struct SimulatePressureNotificationResponse;
    impl ::serde::Serialize for SimulatePressureNotificationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SimulatePressureNotificationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SimulatePressureNotificationResponse)
        }
    }
    impl ::CdpCommand for SimulatePressureNotificationResponse {
        const COMMAND_NAME: &'static str = "Memory.simulatePressureNotification";
    }
    impl<'b> ::HasCdpResponse<'b> for SimulatePressureNotificationCommand {
        type Response = SimulatePressureNotificationResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SimulatePressureNotificationResponse {
        type Command = SimulatePressureNotificationCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start collecting native memory profile.\n\n# Command `Memory.startSampling`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::memory::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingCommand {
        #[serde(rename = "samplingInterval", skip_serializing_if = "Option::is_none")]
        #[doc = "Average number of bytes between samples."]
        pub sampling_interval: Option<i32>,
        #[serde(rename = "suppressRandomness", skip_serializing_if = "Option::is_none")]
        #[doc = "Do not randomize intervals between samples."]
        pub suppress_randomness: Option<bool>,
    }
    impl ::CdpCommand for StartSamplingCommand {
        const COMMAND_NAME: &'static str = "Memory.startSampling";
    }
    impl ::SerializeCdpCommand for StartSamplingCommand {
        fn command_name(&self) -> &str {
            "Memory.startSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.startSampling" {
                Ok(
                    <StartSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start collecting native memory profile.\n\n# Command `Memory.startSampling`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::memory::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingResponse;
    impl ::serde::Serialize for StartSamplingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartSamplingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartSamplingResponse)
        }
    }
    impl ::CdpCommand for StartSamplingResponse {
        const COMMAND_NAME: &'static str = "Memory.startSampling";
    }
    impl<'b> ::HasCdpResponse<'b> for StartSamplingCommand {
        type Response = StartSamplingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartSamplingResponse {
        type Command = StartSamplingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop collecting native memory profile.\n\n# Command `Memory.stopSampling`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::memory::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingCommand;
    impl ::serde::Serialize for StopSamplingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopSamplingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopSamplingCommand)
        }
    }
    impl ::CdpCommand for StopSamplingCommand {
        const COMMAND_NAME: &'static str = "Memory.stopSampling";
    }
    impl ::SerializeCdpCommand for StopSamplingCommand {
        fn command_name(&self) -> &str {
            "Memory.stopSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.stopSampling" {
                Ok(
                    <StopSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop collecting native memory profile.\n\n# Command `Memory.stopSampling`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::memory::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingResponse;
    impl ::serde::Serialize for StopSamplingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopSamplingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopSamplingResponse)
        }
    }
    impl ::CdpCommand for StopSamplingResponse {
        const COMMAND_NAME: &'static str = "Memory.stopSampling";
    }
    impl<'b> ::HasCdpResponse<'b> for StopSamplingCommand {
        type Response = StopSamplingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopSamplingResponse {
        type Command = StopSamplingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile\ncollected since renderer process startup.\n\n# Command `Memory.getAllTimeSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetAllTimeSamplingProfileCommand`](struct.GetAllTimeSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetAllTimeSamplingProfileResponse`](struct.GetAllTimeSamplingProfileResponse.html)"]
    pub struct GetAllTimeSamplingProfileCommand;
    impl ::serde::Serialize for GetAllTimeSamplingProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAllTimeSamplingProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetAllTimeSamplingProfileCommand)
        }
    }
    impl ::CdpCommand for GetAllTimeSamplingProfileCommand {
        const COMMAND_NAME: &'static str = "Memory.getAllTimeSamplingProfile";
    }
    impl ::SerializeCdpCommand for GetAllTimeSamplingProfileCommand {
        fn command_name(&self) -> &str {
            "Memory.getAllTimeSamplingProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetAllTimeSamplingProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.getAllTimeSamplingProfile" {
                Ok ( < GetAllTimeSamplingProfileCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile\ncollected since renderer process startup.\n\n# Command `Memory.getAllTimeSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetAllTimeSamplingProfileCommand`](struct.GetAllTimeSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetAllTimeSamplingProfileResponse`](struct.GetAllTimeSamplingProfileResponse.html)"]
    pub struct GetAllTimeSamplingProfileResponse<'a> {
        #[serde(rename = "profile")]
        pub profile: ::memory::SamplingProfile<'a>,
    }
    impl<'a> ::CdpCommand for GetAllTimeSamplingProfileResponse<'a> {
        const COMMAND_NAME: &'static str = "Memory.getAllTimeSamplingProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for GetAllTimeSamplingProfileCommand {
        type Response = GetAllTimeSamplingProfileResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetAllTimeSamplingProfileResponse<'b> {
        type Command = GetAllTimeSamplingProfileCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile\ncollected since browser process startup.\n\n# Command `Memory.getBrowserSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetBrowserSamplingProfileCommand`](struct.GetBrowserSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetBrowserSamplingProfileResponse`](struct.GetBrowserSamplingProfileResponse.html)"]
    pub struct GetBrowserSamplingProfileCommand;
    impl ::serde::Serialize for GetBrowserSamplingProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetBrowserSamplingProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetBrowserSamplingProfileCommand)
        }
    }
    impl ::CdpCommand for GetBrowserSamplingProfileCommand {
        const COMMAND_NAME: &'static str = "Memory.getBrowserSamplingProfile";
    }
    impl ::SerializeCdpCommand for GetBrowserSamplingProfileCommand {
        fn command_name(&self) -> &str {
            "Memory.getBrowserSamplingProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetBrowserSamplingProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.getBrowserSamplingProfile" {
                Ok ( < GetBrowserSamplingProfileCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile\ncollected since browser process startup.\n\n# Command `Memory.getBrowserSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetBrowserSamplingProfileCommand`](struct.GetBrowserSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetBrowserSamplingProfileResponse`](struct.GetBrowserSamplingProfileResponse.html)"]
    pub struct GetBrowserSamplingProfileResponse<'a> {
        #[serde(rename = "profile")]
        pub profile: ::memory::SamplingProfile<'a>,
    }
    impl<'a> ::CdpCommand for GetBrowserSamplingProfileResponse<'a> {
        const COMMAND_NAME: &'static str = "Memory.getBrowserSamplingProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for GetBrowserSamplingProfileCommand {
        type Response = GetBrowserSamplingProfileResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetBrowserSamplingProfileResponse<'b> {
        type Command = GetBrowserSamplingProfileCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile collected since last\n`startSampling` call.\n\n# Command `Memory.getSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetSamplingProfileCommand`](struct.GetSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetSamplingProfileResponse`](struct.GetSamplingProfileResponse.html)"]
    pub struct GetSamplingProfileCommand;
    impl ::serde::Serialize for GetSamplingProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSamplingProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetSamplingProfileCommand)
        }
    }
    impl ::CdpCommand for GetSamplingProfileCommand {
        const COMMAND_NAME: &'static str = "Memory.getSamplingProfile";
    }
    impl ::SerializeCdpCommand for GetSamplingProfileCommand {
        fn command_name(&self) -> &str {
            "Memory.getSamplingProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetSamplingProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Memory.getSamplingProfile" {
                Ok ( < GetSamplingProfileCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Retrieve native memory allocations profile collected since last\n`startSampling` call.\n\n# Command `Memory.getSamplingProfile`\n\n*Domain Module:* [`cdp::memory`](index.html)  \n*Command Struct:* [`cdp::memory::GetSamplingProfileCommand`](struct.GetSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::memory::GetSamplingProfileResponse`](struct.GetSamplingProfileResponse.html)"]
    pub struct GetSamplingProfileResponse<'a> {
        #[serde(rename = "profile")]
        pub profile: ::memory::SamplingProfile<'a>,
    }
    impl<'a> ::CdpCommand for GetSamplingProfileResponse<'a> {
        const COMMAND_NAME: &'static str = "Memory.getSamplingProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for GetSamplingProfileCommand {
        type Response = GetSamplingProfileResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetSamplingProfileResponse<'b> {
        type Command = GetSamplingProfileCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Memory pressure level."]
    pub enum PressureLevel {
        #[serde(rename = "moderate")]
        #[doc = "Represented as `\"moderate\"`."]
        Moderate,
        #[serde(rename = "critical")]
        #[doc = "Represented as `\"critical\"`."]
        Critical,
    }
    impl PressureLevel {
        pub const ENUM_VALUES: &'static [PressureLevel] =
            &[PressureLevel::Moderate, PressureLevel::Critical];
        pub const STR_VALUES: &'static [&'static str] = &["moderate", "critical"];
    }
    impl ::std::str::FromStr for PressureLevel {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "moderate" => Ok(PressureLevel::Moderate),
                "critical" => Ok(PressureLevel::Critical),
                _ => Err(::ParseEnumError {
                    expected: PressureLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PressureLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PressureLevel::Moderate => "moderate",
                    PressureLevel::Critical => "critical",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Heap profile sample."]
    pub struct SamplingProfileNode<'a> {
        #[serde(rename = "size")]
        #[doc = "Size of the sampled allocation."]
        pub size: f64,
        #[serde(rename = "total")]
        #[doc = "Total bytes attributed to this sample."]
        pub total: f64,
        #[serde(rename = "stack")]
        #[doc = "Execution stack at the point of allocation."]
        pub stack: Vec<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Array of heap profile samples."]
    pub struct SamplingProfile<'a> {
        #[serde(rename = "samples")]
        pub samples: Vec<::memory::SamplingProfileNode<'a>>,
        #[serde(rename = "modules")]
        pub modules: Vec<::memory::Module<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Executable module information"]
    pub struct Module<'a> {
        #[serde(rename = "name")]
        #[doc = "Name of the module."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "uuid")]
        #[doc = "UUID of the module."]
        pub uuid: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "baseAddress")]
        #[doc = "Base address where the module is loaded into memory. Encoded as a decimal\nor hexadecimal \\(0x prefixed\\) string."]
        pub base_address: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "size")]
        #[doc = "Size of the module in bytes."]
        pub size: f64,
    }
}
#[doc = "Network domain allows tracking network activities of the page. It exposes information about http,\nfile, data and other requests and responses, their headers, bodies, timing, etc.\n\n# Network\n\n## Commands\n\n- [`Network.canClearBrowserCache`](struct.CanClearBrowserCacheCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Tells whether clearing browser cache is supported.\n- [`Network.canClearBrowserCookies`](struct.CanClearBrowserCookiesCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Tells whether clearing browser cookies is supported.\n- [`Network.canEmulateNetworkConditions`](struct.CanEmulateNetworkConditionsCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Tells whether emulation of network conditions is supported.\n- [`Network.clearBrowserCache`](struct.ClearBrowserCacheCommand.html)\n\n  Clears browser cache.\n- [`Network.clearBrowserCookies`](struct.ClearBrowserCookiesCommand.html)\n\n  Clears browser cookies.\n- [`Network.continueInterceptedRequest`](struct.ContinueInterceptedRequestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Response to Network.requestIntercepted which either modifies the request to continue with any\n  modifications, or blocks it, or completes it with the provided response bytes. If a network\n  fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted\n  event will be sent with the same InterceptionId.\n- [`Network.deleteCookies`](struct.DeleteCookiesCommand.html)\n\n  Deletes browser cookies with matching name and url or domain/path pair.\n- [`Network.disable`](struct.DisableCommand.html)\n\n  Disables network tracking, prevents network events from being sent to the client.\n- [`Network.emulateNetworkConditions`](struct.EmulateNetworkConditionsCommand.html)\n\n  Activates emulation of network conditions.\n- [`Network.enable`](struct.EnableCommand.html)\n\n  Enables network tracking, network events will now be delivered to the client.\n- [`Network.getAllCookies`](struct.GetAllCookiesCommand.html)\n\n  Returns all browser cookies. Depending on the backend support, will return detailed cookie\n  information in the `cookies` field.\n- [`Network.getCertificate`](struct.GetCertificateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the DER-encoded certificate.\n- [`Network.getCookies`](struct.GetCookiesCommand.html)\n\n  Returns all browser cookies for the current URL. Depending on the backend support, will return\n  detailed cookie information in the `cookies` field.\n- [`Network.getResponseBody`](struct.GetResponseBodyCommand.html)\n\n  Returns content served for the given request.\n- [`Network.getRequestPostData`](struct.GetRequestPostDataCommand.html)\n\n  Returns post data sent with the request. Returns an error when no data was sent with the request.\n- [`Network.getResponseBodyForInterception`](struct.GetResponseBodyForInterceptionCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns content served for the given currently intercepted request.\n- [`Network.takeResponseBodyForInterceptionAsStream`](struct.TakeResponseBodyForInterceptionAsStreamCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns a handle to the stream representing the response body. Note that after this command,\n  the intercepted request can't be continued as is -- you either need to cancel it or to provide\n  the response body. The stream only supports sequential read, IO.read will fail if the position\n  is specified.\n- [`Network.replayXHR`](struct.ReplayXhrCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  This method sends a new XMLHttpRequest which is identical to the original one. The following\n  parameters should be identical: method, url, async, request body, extra headers, withCredentials\n  attribute, user, password.\n- [`Network.searchInResponseBody`](struct.SearchInResponseBodyCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for given string in response content.\n- [`Network.setBlockedURLs`](struct.SetBlockedUrLsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Blocks URLs from loading.\n- [`Network.setBypassServiceWorker`](struct.SetBypassServiceWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Toggles ignoring of service worker for each request.\n- [`Network.setCacheDisabled`](struct.SetCacheDisabledCommand.html)\n\n  Toggles ignoring cache for each request. If `true`, cache will not be used.\n- [`Network.setCookie`](struct.SetCookieCommand.html)\n\n  Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n- [`Network.setCookies`](struct.SetCookiesCommand.html)\n\n  Sets given cookies.\n- [`Network.setDataSizeLimitsForTest`](struct.SetDataSizeLimitsForTestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  For testing.\n- [`Network.setExtraHTTPHeaders`](struct.SetExtraHttpHeadersCommand.html)\n\n  Specifies whether to always send extra HTTP headers with the requests from this page.\n- [`Network.setRequestInterception`](struct.SetRequestInterceptionCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets the requests to intercept that match a the provided patterns and optionally resource types.\n- [`Network.setUserAgentOverride`](struct.SetUserAgentOverrideCommand.html)\n\n  Allows overriding user agent with the given string.\n\n## Events\n\n- [`Network.dataReceived`](struct.DataReceivedEvent.html)\n\n  Fired when data chunk was received over the network.\n- [`Network.eventSourceMessageReceived`](struct.EventSourceMessageReceivedEvent.html)\n\n  Fired when EventSource message is received.\n- [`Network.loadingFailed`](struct.LoadingFailedEvent.html)\n\n  Fired when HTTP request has failed to load.\n- [`Network.loadingFinished`](struct.LoadingFinishedEvent.html)\n\n  Fired when HTTP request has finished loading.\n- [`Network.requestIntercepted`](struct.RequestInterceptedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Details of an intercepted HTTP request, which must be either allowed, blocked, modified or\n  mocked.\n- [`Network.requestServedFromCache`](struct.RequestServedFromCacheEvent.html)\n\n  Fired if request ended up loading from cache.\n- [`Network.requestWillBeSent`](struct.RequestWillBeSentEvent.html)\n\n  Fired when page is about to send HTTP request.\n- [`Network.resourceChangedPriority`](struct.ResourceChangedPriorityEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when resource loading priority is changed\n- [`Network.signedExchangeReceived`](struct.SignedExchangeReceivedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when a signed exchange was received over the network\n- [`Network.responseReceived`](struct.ResponseReceivedEvent.html)\n\n  Fired when HTTP response is available.\n- [`Network.webSocketClosed`](struct.WebSocketClosedEvent.html)\n\n  Fired when WebSocket is closed.\n- [`Network.webSocketCreated`](struct.WebSocketCreatedEvent.html)\n\n  Fired upon WebSocket creation.\n- [`Network.webSocketFrameError`](struct.WebSocketFrameErrorEvent.html)\n\n  Fired when WebSocket frame error occurs.\n- [`Network.webSocketFrameReceived`](struct.WebSocketFrameReceivedEvent.html)\n\n  Fired when WebSocket frame is received.\n- [`Network.webSocketFrameSent`](struct.WebSocketFrameSentEvent.html)\n\n  Fired when WebSocket frame is sent.\n- [`Network.webSocketHandshakeResponseReceived`](struct.WebSocketHandshakeResponseReceivedEvent.html)\n\n  Fired when WebSocket handshake response becomes available.\n- [`Network.webSocketWillSendHandshakeRequest`](struct.WebSocketWillSendHandshakeRequestEvent.html)\n\n  Fired when WebSocket is about to initiate handshake.\n\n##Types\n\n- [`ResourceType`](enum.ResourceType.html)\n\n  Resource type as it was perceived by the rendering engine.\n- [`LoaderId`](type.LoaderId.html)\n\n  Unique loader identifier.\n- [`RequestId`](type.RequestId.html)\n\n  Unique request identifier.\n- [`InterceptionId`](type.InterceptionId.html)\n\n  Unique intercepted request identifier.\n- [`ErrorReason`](enum.ErrorReason.html)\n\n  Network level fetch failure reason.\n- [`TimeSinceEpoch`](type.TimeSinceEpoch.html)\n\n  UTC time in seconds, counted from January 1, 1970.\n- [`MonotonicTime`](type.MonotonicTime.html)\n\n  Monotonically increasing time in seconds since an arbitrary point in the past.\n- [`Headers`](struct.Headers.html)\n\n  Request / response headers as keys / values of JSON object.\n- [`ConnectionType`](enum.ConnectionType.html)\n\n  The underlying connection technology that the browser is supposedly using.\n- [`CookieSameSite`](enum.CookieSameSite.html)\n\n  Represents the cookie's 'SameSite' status:\n  https://tools.ietf.org/html/draft-west-first-party-cookies\n- [`ResourceTiming`](struct.ResourceTiming.html)\n\n  Timing information for the request.\n- [`ResourcePriority`](enum.ResourcePriority.html)\n\n  Loading priority of a resource request.\n- [`Request`](struct.Request.html)\n\n  HTTP request data.\n- [`SignedCertificateTimestamp`](struct.SignedCertificateTimestamp.html)\n\n  Details of a signed certificate timestamp \\(SCT\\).\n- [`SecurityDetails`](struct.SecurityDetails.html)\n\n  Security details about a request.\n- [`CertificateTransparencyCompliance`](enum.CertificateTransparencyCompliance.html)\n\n  Whether the request complied with Certificate Transparency policy.\n- [`BlockedReason`](enum.BlockedReason.html)\n\n  The reason why request was blocked.\n- [`Response`](struct.Response.html)\n\n  HTTP response data.\n- [`WebSocketRequest`](struct.WebSocketRequest.html)\n\n  WebSocket request data.\n- [`WebSocketResponse`](struct.WebSocketResponse.html)\n\n  WebSocket response data.\n- [`WebSocketFrame`](struct.WebSocketFrame.html)\n\n  WebSocket frame data.\n- [`CachedResource`](struct.CachedResource.html)\n\n  Information about the cached resource.\n- [`Initiator`](struct.Initiator.html)\n\n  Information about the request initiator.\n- [`Cookie`](struct.Cookie.html)\n\n  Cookie object\n- [`CookieParam`](struct.CookieParam.html)\n\n  Cookie parameter object\n- [`AuthChallenge`](struct.AuthChallenge.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Authorization challenge for HTTP status code 401 or 407.\n- [`AuthChallengeResponse`](struct.AuthChallengeResponse.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Response to an AuthChallenge.\n- [`InterceptionStage`](enum.InterceptionStage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stages of the interception to begin intercepting. Request will intercept before the request is\n  sent. Response will intercept after the response is received.\n- [`RequestPattern`](struct.RequestPattern.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request pattern for interception.\n- [`SignedExchangeSignature`](struct.SignedExchangeSignature.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a signed exchange signature.\n  https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1\n- [`SignedExchangeHeader`](struct.SignedExchangeHeader.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a signed exchange header.\n  https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation\n- [`SignedExchangeErrorField`](enum.SignedExchangeErrorField.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Field type for a signed exchange related error.\n- [`SignedExchangeError`](struct.SignedExchangeError.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a signed exchange response.\n- [`SignedExchangeInfo`](struct.SignedExchangeInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about a signed exchange response.\n"]
pub mod network {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cache is supported.\n\n# Command `Network.canClearBrowserCache`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanClearBrowserCacheCommand`](struct.CanClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::network::CanClearBrowserCacheResponse`](struct.CanClearBrowserCacheResponse.html)"]
    #[deprecated]
    pub struct CanClearBrowserCacheCommand;
    impl ::serde::Serialize for CanClearBrowserCacheCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanClearBrowserCacheCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanClearBrowserCacheCommand)
        }
    }
    impl ::CdpCommand for CanClearBrowserCacheCommand {
        const COMMAND_NAME: &'static str = "Network.canClearBrowserCache";
    }
    impl ::SerializeCdpCommand for CanClearBrowserCacheCommand {
        fn command_name(&self) -> &str {
            "Network.canClearBrowserCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CanClearBrowserCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canClearBrowserCache" {
                Ok ( < CanClearBrowserCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cache is supported.\n\n# Command `Network.canClearBrowserCache`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanClearBrowserCacheCommand`](struct.CanClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::network::CanClearBrowserCacheResponse`](struct.CanClearBrowserCacheResponse.html)"]
    #[deprecated]
    pub struct CanClearBrowserCacheResponse {
        #[serde(rename = "result")]
        #[doc = "True if browser cache can be cleared."]
        pub result: bool,
    }
    impl ::CdpCommand for CanClearBrowserCacheResponse {
        const COMMAND_NAME: &'static str = "Network.canClearBrowserCache";
    }
    impl<'b> ::HasCdpResponse<'b> for CanClearBrowserCacheCommand {
        type Response = CanClearBrowserCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CanClearBrowserCacheResponse {
        type Command = CanClearBrowserCacheCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cookies is supported.\n\n# Command `Network.canClearBrowserCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanClearBrowserCookiesCommand`](struct.CanClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::network::CanClearBrowserCookiesResponse`](struct.CanClearBrowserCookiesResponse.html)"]
    #[deprecated]
    pub struct CanClearBrowserCookiesCommand;
    impl ::serde::Serialize for CanClearBrowserCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanClearBrowserCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanClearBrowserCookiesCommand)
        }
    }
    impl ::CdpCommand for CanClearBrowserCookiesCommand {
        const COMMAND_NAME: &'static str = "Network.canClearBrowserCookies";
    }
    impl ::SerializeCdpCommand for CanClearBrowserCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.canClearBrowserCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CanClearBrowserCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canClearBrowserCookies" {
                Ok ( < CanClearBrowserCookiesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether clearing browser cookies is supported.\n\n# Command `Network.canClearBrowserCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanClearBrowserCookiesCommand`](struct.CanClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::network::CanClearBrowserCookiesResponse`](struct.CanClearBrowserCookiesResponse.html)"]
    #[deprecated]
    pub struct CanClearBrowserCookiesResponse {
        #[serde(rename = "result")]
        #[doc = "True if browser cookies can be cleared."]
        pub result: bool,
    }
    impl ::CdpCommand for CanClearBrowserCookiesResponse {
        const COMMAND_NAME: &'static str = "Network.canClearBrowserCookies";
    }
    impl<'b> ::HasCdpResponse<'b> for CanClearBrowserCookiesCommand {
        type Response = CanClearBrowserCookiesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CanClearBrowserCookiesResponse {
        type Command = CanClearBrowserCookiesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells whether emulation of network conditions is supported.\n\n# Command `Network.canEmulateNetworkConditions`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanEmulateNetworkConditionsCommand`](struct.CanEmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::network::CanEmulateNetworkConditionsResponse`](struct.CanEmulateNetworkConditionsResponse.html)"]
    #[deprecated]
    pub struct CanEmulateNetworkConditionsCommand;
    impl ::serde::Serialize for CanEmulateNetworkConditionsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CanEmulateNetworkConditionsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CanEmulateNetworkConditionsCommand)
        }
    }
    impl ::CdpCommand for CanEmulateNetworkConditionsCommand {
        const COMMAND_NAME: &'static str = "Network.canEmulateNetworkConditions";
    }
    impl ::SerializeCdpCommand for CanEmulateNetworkConditionsCommand {
        fn command_name(&self) -> &str {
            "Network.canEmulateNetworkConditions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CanEmulateNetworkConditionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.canEmulateNetworkConditions" {
                Ok ( < CanEmulateNetworkConditionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Tells whether emulation of network conditions is supported.\n\n# Command `Network.canEmulateNetworkConditions`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::CanEmulateNetworkConditionsCommand`](struct.CanEmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::network::CanEmulateNetworkConditionsResponse`](struct.CanEmulateNetworkConditionsResponse.html)"]
    #[deprecated]
    pub struct CanEmulateNetworkConditionsResponse {
        #[serde(rename = "result")]
        #[doc = "True if emulation of network conditions is supported."]
        pub result: bool,
    }
    impl ::CdpCommand for CanEmulateNetworkConditionsResponse {
        const COMMAND_NAME: &'static str = "Network.canEmulateNetworkConditions";
    }
    impl<'b> ::HasCdpResponse<'b> for CanEmulateNetworkConditionsCommand {
        type Response = CanEmulateNetworkConditionsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CanEmulateNetworkConditionsResponse {
        type Command = CanEmulateNetworkConditionsCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cache.\n\n# Command `Network.clearBrowserCache`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ClearBrowserCacheCommand`](struct.ClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::network::ClearBrowserCacheResponse`](struct.ClearBrowserCacheResponse.html)"]
    pub struct ClearBrowserCacheCommand;
    impl ::serde::Serialize for ClearBrowserCacheCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCacheCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCacheCommand)
        }
    }
    impl ::CdpCommand for ClearBrowserCacheCommand {
        const COMMAND_NAME: &'static str = "Network.clearBrowserCache";
    }
    impl ::SerializeCdpCommand for ClearBrowserCacheCommand {
        fn command_name(&self) -> &str {
            "Network.clearBrowserCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearBrowserCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.clearBrowserCache" {
                Ok ( < ClearBrowserCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cache.\n\n# Command `Network.clearBrowserCache`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ClearBrowserCacheCommand`](struct.ClearBrowserCacheCommand.html)  \n*Response Struct:* [`cdp::network::ClearBrowserCacheResponse`](struct.ClearBrowserCacheResponse.html)"]
    pub struct ClearBrowserCacheResponse;
    impl ::serde::Serialize for ClearBrowserCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCacheResponse)
        }
    }
    impl ::CdpCommand for ClearBrowserCacheResponse {
        const COMMAND_NAME: &'static str = "Network.clearBrowserCache";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearBrowserCacheCommand {
        type Response = ClearBrowserCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearBrowserCacheResponse {
        type Command = ClearBrowserCacheCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cookies.\n\n# Command `Network.clearBrowserCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ClearBrowserCookiesCommand`](struct.ClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::network::ClearBrowserCookiesResponse`](struct.ClearBrowserCookiesResponse.html)"]
    pub struct ClearBrowserCookiesCommand;
    impl ::serde::Serialize for ClearBrowserCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCookiesCommand)
        }
    }
    impl ::CdpCommand for ClearBrowserCookiesCommand {
        const COMMAND_NAME: &'static str = "Network.clearBrowserCookies";
    }
    impl ::SerializeCdpCommand for ClearBrowserCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.clearBrowserCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearBrowserCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.clearBrowserCookies" {
                Ok ( < ClearBrowserCookiesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears browser cookies.\n\n# Command `Network.clearBrowserCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ClearBrowserCookiesCommand`](struct.ClearBrowserCookiesCommand.html)  \n*Response Struct:* [`cdp::network::ClearBrowserCookiesResponse`](struct.ClearBrowserCookiesResponse.html)"]
    pub struct ClearBrowserCookiesResponse;
    impl ::serde::Serialize for ClearBrowserCookiesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearBrowserCookiesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearBrowserCookiesResponse)
        }
    }
    impl ::CdpCommand for ClearBrowserCookiesResponse {
        const COMMAND_NAME: &'static str = "Network.clearBrowserCookies";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearBrowserCookiesCommand {
        type Response = ClearBrowserCookiesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearBrowserCookiesResponse {
        type Command = ClearBrowserCookiesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to Network.requestIntercepted which either modifies the request to continue with any\nmodifications, or blocks it, or completes it with the provided response bytes. If a network\nfetch occurs as a result which encounters a redirect an additional Network.requestIntercepted\nevent will be sent with the same InterceptionId.\n\n# Command `Network.continueInterceptedRequest`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ContinueInterceptedRequestCommand`](struct.ContinueInterceptedRequestCommand.html)  \n*Response Struct:* [`cdp::network::ContinueInterceptedRequestResponse`](struct.ContinueInterceptedRequestResponse.html)"]
    pub struct ContinueInterceptedRequestCommand<'a> {
        #[serde(rename = "interceptionId")]
        pub interception_id: ::network::InterceptionId<'a>,
        #[serde(rename = "errorReason", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this causes the request to fail with the given reason. Passing `Aborted` for requests\nmarked with `isNavigationRequest` also cancels the navigation. Must not be set in response\nto an authChallenge."]
        pub error_reason: Option<::network::ErrorReason>,
        #[serde(rename = "rawResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "If set the requests completes using with the provided base64 encoded raw response, including\nHTTP status line and headers etc... Must not be set in response to an authChallenge."]
        pub raw_response: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "If set the request url will be modified in a way that's not observable by page. Must not be\nset in response to an authChallenge."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "method", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows the request method to be overridden. Must not be set in response to an\nauthChallenge."]
        pub method: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "postData", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows postData to be set. Must not be set in response to an authChallenge."]
        pub post_data: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "headers", skip_serializing_if = "Option::is_none")]
        #[doc = "If set this allows the request headers to be changed. Must not be set in response to an\nauthChallenge."]
        pub headers: Option<::network::Headers>,
        #[serde(rename = "authChallengeResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "Response to a requestIntercepted with an authChallenge. Must not be set otherwise."]
        pub auth_challenge_response: Option<::network::AuthChallengeResponse<'a>>,
    }
    impl<'a> ::CdpCommand for ContinueInterceptedRequestCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.continueInterceptedRequest";
    }
    impl<'a> ::SerializeCdpCommand for ContinueInterceptedRequestCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.continueInterceptedRequest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ContinueInterceptedRequestCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.continueInterceptedRequest" {
                Ok ( < ContinueInterceptedRequestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to Network.requestIntercepted which either modifies the request to continue with any\nmodifications, or blocks it, or completes it with the provided response bytes. If a network\nfetch occurs as a result which encounters a redirect an additional Network.requestIntercepted\nevent will be sent with the same InterceptionId.\n\n# Command `Network.continueInterceptedRequest`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ContinueInterceptedRequestCommand`](struct.ContinueInterceptedRequestCommand.html)  \n*Response Struct:* [`cdp::network::ContinueInterceptedRequestResponse`](struct.ContinueInterceptedRequestResponse.html)"]
    pub struct ContinueInterceptedRequestResponse;
    impl ::serde::Serialize for ContinueInterceptedRequestResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ContinueInterceptedRequestResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ContinueInterceptedRequestResponse)
        }
    }
    impl ::CdpCommand for ContinueInterceptedRequestResponse {
        const COMMAND_NAME: &'static str = "Network.continueInterceptedRequest";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ContinueInterceptedRequestCommand<'a> {
        type Response = ContinueInterceptedRequestResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ContinueInterceptedRequestResponse {
        type Command = ContinueInterceptedRequestCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Deletes browser cookies with matching name and url or domain/path pair.\n\n# Command `Network.deleteCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::DeleteCookiesCommand`](struct.DeleteCookiesCommand.html)  \n*Response Struct:* [`cdp::network::DeleteCookiesResponse`](struct.DeleteCookiesResponse.html)"]
    pub struct DeleteCookiesCommand<'a> {
        #[serde(rename = "name")]
        #[doc = "Name of the cookies to remove."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "If specified, deletes all the cookies with the given name where domain and path match\nprovided URL."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "domain", skip_serializing_if = "Option::is_none")]
        #[doc = "If specified, deletes only cookies with the exact domain."]
        pub domain: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
        #[doc = "If specified, deletes only cookies with the exact path."]
        pub path: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for DeleteCookiesCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.deleteCookies";
    }
    impl<'a> ::SerializeCdpCommand for DeleteCookiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.deleteCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteCookiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.deleteCookies" {
                Ok(
                    <DeleteCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Deletes browser cookies with matching name and url or domain/path pair.\n\n# Command `Network.deleteCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::DeleteCookiesCommand`](struct.DeleteCookiesCommand.html)  \n*Response Struct:* [`cdp::network::DeleteCookiesResponse`](struct.DeleteCookiesResponse.html)"]
    pub struct DeleteCookiesResponse;
    impl ::serde::Serialize for DeleteCookiesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCookiesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCookiesResponse)
        }
    }
    impl ::CdpCommand for DeleteCookiesResponse {
        const COMMAND_NAME: &'static str = "Network.deleteCookies";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteCookiesCommand<'a> {
        type Response = DeleteCookiesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteCookiesResponse {
        type Command = DeleteCookiesCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables network tracking, prevents network events from being sent to the client.\n\n# Command `Network.disable`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::network::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Network.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Network.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables network tracking, prevents network events from being sent to the client.\n\n# Command `Network.disable`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::network::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Network.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Activates emulation of network conditions.\n\n# Command `Network.emulateNetworkConditions`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::EmulateNetworkConditionsCommand`](struct.EmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::network::EmulateNetworkConditionsResponse`](struct.EmulateNetworkConditionsResponse.html)"]
    pub struct EmulateNetworkConditionsCommand {
        #[serde(rename = "offline")]
        #[doc = "True to emulate internet disconnection."]
        pub offline: bool,
        #[serde(rename = "latency")]
        #[doc = "Minimum latency from request sent to response headers received \\(ms\\)."]
        pub latency: f64,
        #[serde(rename = "downloadThroughput")]
        #[doc = "Maximal aggregated download throughput \\(bytes/sec\\). -1 disables download throttling."]
        pub download_throughput: f64,
        #[serde(rename = "uploadThroughput")]
        #[doc = "Maximal aggregated upload throughput \\(bytes/sec\\).  -1 disables upload throttling."]
        pub upload_throughput: f64,
        #[serde(rename = "connectionType", skip_serializing_if = "Option::is_none")]
        #[doc = "Connection type if known."]
        pub connection_type: Option<::network::ConnectionType>,
    }
    impl ::CdpCommand for EmulateNetworkConditionsCommand {
        const COMMAND_NAME: &'static str = "Network.emulateNetworkConditions";
    }
    impl ::SerializeCdpCommand for EmulateNetworkConditionsCommand {
        fn command_name(&self) -> &str {
            "Network.emulateNetworkConditions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EmulateNetworkConditionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.emulateNetworkConditions" {
                Ok ( < EmulateNetworkConditionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Activates emulation of network conditions.\n\n# Command `Network.emulateNetworkConditions`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::EmulateNetworkConditionsCommand`](struct.EmulateNetworkConditionsCommand.html)  \n*Response Struct:* [`cdp::network::EmulateNetworkConditionsResponse`](struct.EmulateNetworkConditionsResponse.html)"]
    pub struct EmulateNetworkConditionsResponse;
    impl ::serde::Serialize for EmulateNetworkConditionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EmulateNetworkConditionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EmulateNetworkConditionsResponse)
        }
    }
    impl ::CdpCommand for EmulateNetworkConditionsResponse {
        const COMMAND_NAME: &'static str = "Network.emulateNetworkConditions";
    }
    impl<'b> ::HasCdpResponse<'b> for EmulateNetworkConditionsCommand {
        type Response = EmulateNetworkConditionsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EmulateNetworkConditionsResponse {
        type Command = EmulateNetworkConditionsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables network tracking, network events will now be delivered to the client.\n\n# Command `Network.enable`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::network::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand {
        #[serde(rename = "maxTotalBufferSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Buffer size in bytes to use when preserving network payloads \\(XHRs, etc\\)."]
        pub max_total_buffer_size: Option<i32>,
        #[serde(rename = "maxResourceBufferSize", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Per-resource buffer size in bytes to use when preserving network payloads \\(XHRs, etc\\)."]
        pub max_resource_buffer_size: Option<i32>,
        #[serde(rename = "maxPostDataSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Longest post body size \\(in bytes\\) that would be included in requestWillBeSent notification"]
        pub max_post_data_size: Option<i32>,
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Network.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Network.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables network tracking, network events will now be delivered to the client.\n\n# Command `Network.enable`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::network::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Network.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n\n# Command `Network.getAllCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetAllCookiesCommand`](struct.GetAllCookiesCommand.html)  \n*Response Struct:* [`cdp::network::GetAllCookiesResponse`](struct.GetAllCookiesResponse.html)"]
    pub struct GetAllCookiesCommand;
    impl ::serde::Serialize for GetAllCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAllCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetAllCookiesCommand)
        }
    }
    impl ::CdpCommand for GetAllCookiesCommand {
        const COMMAND_NAME: &'static str = "Network.getAllCookies";
    }
    impl ::SerializeCdpCommand for GetAllCookiesCommand {
        fn command_name(&self) -> &str {
            "Network.getAllCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetAllCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getAllCookies" {
                Ok(
                    <GetAllCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n\n# Command `Network.getAllCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetAllCookiesCommand`](struct.GetAllCookiesCommand.html)  \n*Response Struct:* [`cdp::network::GetAllCookiesResponse`](struct.GetAllCookiesResponse.html)"]
    pub struct GetAllCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::network::Cookie<'a>>,
    }
    impl<'a> ::CdpCommand for GetAllCookiesResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getAllCookies";
    }
    impl<'b> ::HasCdpResponse<'b> for GetAllCookiesCommand {
        type Response = GetAllCookiesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetAllCookiesResponse<'b> {
        type Command = GetAllCookiesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the DER-encoded certificate.\n\n# Command `Network.getCertificate`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetCertificateCommand`](struct.GetCertificateCommand.html)  \n*Response Struct:* [`cdp::network::GetCertificateResponse`](struct.GetCertificateResponse.html)"]
    pub struct GetCertificateCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to get certificate for."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetCertificateCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.getCertificate";
    }
    impl<'a> ::SerializeCdpCommand for GetCertificateCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getCertificate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetCertificateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getCertificate" {
                Ok(
                    <GetCertificateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the DER-encoded certificate.\n\n# Command `Network.getCertificate`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetCertificateCommand`](struct.GetCertificateCommand.html)  \n*Response Struct:* [`cdp::network::GetCertificateResponse`](struct.GetCertificateResponse.html)"]
    pub struct GetCertificateResponse<'a> {
        #[serde(rename = "tableNames")]
        pub table_names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetCertificateResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getCertificate";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetCertificateCommand<'a> {
        type Response = GetCertificateResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetCertificateResponse<'b> {
        type Command = GetCertificateCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns all browser cookies for the current URL. Depending on the backend support, will return\ndetailed cookie information in the `cookies` field.\n\n# Command `Network.getCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::network::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesCommand<'a> {
        #[serde(rename = "urls", skip_serializing_if = "Option::is_none")]
        #[doc = "The list of URLs for which applicable cookies will be fetched"]
        pub urls: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
    impl<'a> ::CdpCommand for GetCookiesCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.getCookies";
    }
    impl<'a> ::SerializeCdpCommand for GetCookiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetCookiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getCookies" {
                Ok(
                    <GetCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns all browser cookies for the current URL. Depending on the backend support, will return\ndetailed cookie information in the `cookies` field.\n\n# Command `Network.getCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::network::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    pub struct GetCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::network::Cookie<'a>>,
    }
    impl<'a> ::CdpCommand for GetCookiesResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getCookies";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetCookiesCommand<'a> {
        type Response = GetCookiesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetCookiesResponse<'b> {
        type Command = GetCookiesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns content served for the given request.\n\n# Command `Network.getResponseBody`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetResponseBodyCommand`](struct.GetResponseBodyCommand.html)  \n*Response Struct:* [`cdp::network::GetResponseBodyResponse`](struct.GetResponseBodyResponse.html)"]
    pub struct GetResponseBodyCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of the network request to get content for."]
        pub request_id: ::network::RequestId<'a>,
    }
    impl<'a> ::CdpCommand for GetResponseBodyCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.getResponseBody";
    }
    impl<'a> ::SerializeCdpCommand for GetResponseBodyCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getResponseBody"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetResponseBodyCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getResponseBody" {
                Ok(
                    <GetResponseBodyCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns content served for the given request.\n\n# Command `Network.getResponseBody`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetResponseBodyCommand`](struct.GetResponseBodyCommand.html)  \n*Response Struct:* [`cdp::network::GetResponseBodyResponse`](struct.GetResponseBodyResponse.html)"]
    pub struct GetResponseBodyResponse<'a> {
        #[serde(rename = "body")]
        #[doc = "Response body."]
        pub body: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "base64Encoded")]
        #[doc = "True, if content was sent as base64."]
        pub base_64_encoded: bool,
    }
    impl<'a> ::CdpCommand for GetResponseBodyResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getResponseBody";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetResponseBodyCommand<'a> {
        type Response = GetResponseBodyResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetResponseBodyResponse<'b> {
        type Command = GetResponseBodyCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns post data sent with the request. Returns an error when no data was sent with the request.\n\n# Command `Network.getRequestPostData`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetRequestPostDataCommand`](struct.GetRequestPostDataCommand.html)  \n*Response Struct:* [`cdp::network::GetRequestPostDataResponse`](struct.GetRequestPostDataResponse.html)"]
    pub struct GetRequestPostDataCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of the network request to get content for."]
        pub request_id: ::network::RequestId<'a>,
    }
    impl<'a> ::CdpCommand for GetRequestPostDataCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.getRequestPostData";
    }
    impl<'a> ::SerializeCdpCommand for GetRequestPostDataCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getRequestPostData"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetRequestPostDataCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getRequestPostData" {
                Ok ( < GetRequestPostDataCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns post data sent with the request. Returns an error when no data was sent with the request.\n\n# Command `Network.getRequestPostData`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetRequestPostDataCommand`](struct.GetRequestPostDataCommand.html)  \n*Response Struct:* [`cdp::network::GetRequestPostDataResponse`](struct.GetRequestPostDataResponse.html)"]
    pub struct GetRequestPostDataResponse<'a> {
        #[serde(rename = "postData")]
        #[doc = "Base64-encoded request body."]
        pub post_data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetRequestPostDataResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getRequestPostData";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetRequestPostDataCommand<'a> {
        type Response = GetRequestPostDataResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetRequestPostDataResponse<'b> {
        type Command = GetRequestPostDataCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content served for the given currently intercepted request.\n\n# Command `Network.getResponseBodyForInterception`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetResponseBodyForInterceptionCommand`](struct.GetResponseBodyForInterceptionCommand.html)  \n*Response Struct:* [`cdp::network::GetResponseBodyForInterceptionResponse`](struct.GetResponseBodyForInterceptionResponse.html)"]
    pub struct GetResponseBodyForInterceptionCommand<'a> {
        #[serde(rename = "interceptionId")]
        #[doc = "Identifier for the intercepted request to get body for."]
        pub interception_id: ::network::InterceptionId<'a>,
    }
    impl<'a> ::CdpCommand for GetResponseBodyForInterceptionCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.getResponseBodyForInterception";
    }
    impl<'a> ::SerializeCdpCommand for GetResponseBodyForInterceptionCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.getResponseBodyForInterception"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetResponseBodyForInterceptionCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.getResponseBodyForInterception" {
                Ok ( < GetResponseBodyForInterceptionCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content served for the given currently intercepted request.\n\n# Command `Network.getResponseBodyForInterception`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::GetResponseBodyForInterceptionCommand`](struct.GetResponseBodyForInterceptionCommand.html)  \n*Response Struct:* [`cdp::network::GetResponseBodyForInterceptionResponse`](struct.GetResponseBodyForInterceptionResponse.html)"]
    pub struct GetResponseBodyForInterceptionResponse<'a> {
        #[serde(rename = "body")]
        #[doc = "Response body."]
        pub body: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "base64Encoded")]
        #[doc = "True, if content was sent as base64."]
        pub base_64_encoded: bool,
    }
    impl<'a> ::CdpCommand for GetResponseBodyForInterceptionResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.getResponseBodyForInterception";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetResponseBodyForInterceptionCommand<'a> {
        type Response = GetResponseBodyForInterceptionResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetResponseBodyForInterceptionResponse<'b> {
        type Command = GetResponseBodyForInterceptionCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a handle to the stream representing the response body. Note that after this command,\nthe intercepted request can't be continued as is -- you either need to cancel it or to provide\nthe response body. The stream only supports sequential read, IO.read will fail if the position\nis specified.\n\n# Command `Network.takeResponseBodyForInterceptionAsStream`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::TakeResponseBodyForInterceptionAsStreamCommand`](struct.TakeResponseBodyForInterceptionAsStreamCommand.html)  \n*Response Struct:* [`cdp::network::TakeResponseBodyForInterceptionAsStreamResponse`](struct.TakeResponseBodyForInterceptionAsStreamResponse.html)"]
    pub struct TakeResponseBodyForInterceptionAsStreamCommand<'a> {
        #[serde(rename = "interceptionId")]
        pub interception_id: ::network::InterceptionId<'a>,
    }
    impl<'a> ::CdpCommand for TakeResponseBodyForInterceptionAsStreamCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.takeResponseBodyForInterceptionAsStream";
    }
    impl<'a> ::SerializeCdpCommand for TakeResponseBodyForInterceptionAsStreamCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.takeResponseBodyForInterceptionAsStream"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for TakeResponseBodyForInterceptionAsStreamCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.takeResponseBodyForInterceptionAsStream" {
                Ok ( < TakeResponseBodyForInterceptionAsStreamCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns a handle to the stream representing the response body. Note that after this command,\nthe intercepted request can't be continued as is -- you either need to cancel it or to provide\nthe response body. The stream only supports sequential read, IO.read will fail if the position\nis specified.\n\n# Command `Network.takeResponseBodyForInterceptionAsStream`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::TakeResponseBodyForInterceptionAsStreamCommand`](struct.TakeResponseBodyForInterceptionAsStreamCommand.html)  \n*Response Struct:* [`cdp::network::TakeResponseBodyForInterceptionAsStreamResponse`](struct.TakeResponseBodyForInterceptionAsStreamResponse.html)"]
    pub struct TakeResponseBodyForInterceptionAsStreamResponse<'a> {
        #[serde(rename = "stream")]
        pub stream: ::io::StreamHandle<'a>,
    }
    impl<'a> ::CdpCommand for TakeResponseBodyForInterceptionAsStreamResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.takeResponseBodyForInterceptionAsStream";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for TakeResponseBodyForInterceptionAsStreamCommand<'a> {
        type Response = TakeResponseBodyForInterceptionAsStreamResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for TakeResponseBodyForInterceptionAsStreamResponse<'b> {
        type Command = TakeResponseBodyForInterceptionAsStreamCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method sends a new XMLHttpRequest which is identical to the original one. The following\nparameters should be identical: method, url, async, request body, extra headers, withCredentials\nattribute, user, password.\n\n# Command `Network.replayXHR`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ReplayXhrCommand`](struct.ReplayXhrCommand.html)  \n*Response Struct:* [`cdp::network::ReplayXhrResponse`](struct.ReplayXhrResponse.html)"]
    pub struct ReplayXhrCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of XHR to replay."]
        pub request_id: ::network::RequestId<'a>,
    }
    impl<'a> ::CdpCommand for ReplayXhrCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.replayXHR";
    }
    impl<'a> ::SerializeCdpCommand for ReplayXhrCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.replayXHR"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReplayXhrCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.replayXHR" {
                Ok(
                    <ReplayXhrCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method sends a new XMLHttpRequest which is identical to the original one. The following\nparameters should be identical: method, url, async, request body, extra headers, withCredentials\nattribute, user, password.\n\n# Command `Network.replayXHR`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::ReplayXhrCommand`](struct.ReplayXhrCommand.html)  \n*Response Struct:* [`cdp::network::ReplayXhrResponse`](struct.ReplayXhrResponse.html)"]
    pub struct ReplayXhrResponse;
    impl ::serde::Serialize for ReplayXhrResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReplayXhrResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReplayXhrResponse)
        }
    }
    impl ::CdpCommand for ReplayXhrResponse {
        const COMMAND_NAME: &'static str = "Network.replayXHR";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReplayXhrCommand<'a> {
        type Response = ReplayXhrResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReplayXhrResponse {
        type Command = ReplayXhrCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in response content.\n\n# Command `Network.searchInResponseBody`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SearchInResponseBodyCommand`](struct.SearchInResponseBodyCommand.html)  \n*Response Struct:* [`cdp::network::SearchInResponseBodyResponse`](struct.SearchInResponseBodyResponse.html)"]
    pub struct SearchInResponseBodyCommand<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Identifier of the network response to search."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "query")]
        #[doc = "String to search for."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "caseSensitive", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, search is case sensitive."]
        pub case_sensitive: Option<bool>,
        #[serde(rename = "isRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, treats string parameter as regex."]
        pub is_regex: Option<bool>,
    }
    impl<'a> ::CdpCommand for SearchInResponseBodyCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.searchInResponseBody";
    }
    impl<'a> ::SerializeCdpCommand for SearchInResponseBodyCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.searchInResponseBody"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SearchInResponseBodyCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.searchInResponseBody" {
                Ok ( < SearchInResponseBodyCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in response content.\n\n# Command `Network.searchInResponseBody`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SearchInResponseBodyCommand`](struct.SearchInResponseBodyCommand.html)  \n*Response Struct:* [`cdp::network::SearchInResponseBodyResponse`](struct.SearchInResponseBodyResponse.html)"]
    pub struct SearchInResponseBodyResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "List of search matches."]
        pub result: Vec<::debugger::SearchMatch<'a>>,
    }
    impl<'a> ::CdpCommand for SearchInResponseBodyResponse<'a> {
        const COMMAND_NAME: &'static str = "Network.searchInResponseBody";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SearchInResponseBodyCommand<'a> {
        type Response = SearchInResponseBodyResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SearchInResponseBodyResponse<'b> {
        type Command = SearchInResponseBodyCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Blocks URLs from loading.\n\n# Command `Network.setBlockedURLs`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetBlockedUrLsCommand`](struct.SetBlockedUrLsCommand.html)  \n*Response Struct:* [`cdp::network::SetBlockedUrLsResponse`](struct.SetBlockedUrLsResponse.html)"]
    pub struct SetBlockedUrLsCommand<'a> {
        #[serde(rename = "urls")]
        #[doc = "URL patterns to block. Wildcards \\('\\*'\\) are allowed."]
        pub urls: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetBlockedUrLsCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.setBlockedURLs";
    }
    impl<'a> ::SerializeCdpCommand for SetBlockedUrLsCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setBlockedURLs"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBlockedUrLsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setBlockedURLs" {
                Ok(
                    <SetBlockedUrLsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Blocks URLs from loading.\n\n# Command `Network.setBlockedURLs`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetBlockedUrLsCommand`](struct.SetBlockedUrLsCommand.html)  \n*Response Struct:* [`cdp::network::SetBlockedUrLsResponse`](struct.SetBlockedUrLsResponse.html)"]
    pub struct SetBlockedUrLsResponse;
    impl ::serde::Serialize for SetBlockedUrLsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlockedUrLsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlockedUrLsResponse)
        }
    }
    impl ::CdpCommand for SetBlockedUrLsResponse {
        const COMMAND_NAME: &'static str = "Network.setBlockedURLs";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBlockedUrLsCommand<'a> {
        type Response = SetBlockedUrLsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBlockedUrLsResponse {
        type Command = SetBlockedUrLsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles ignoring of service worker for each request.\n\n# Command `Network.setBypassServiceWorker`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetBypassServiceWorkerCommand`](struct.SetBypassServiceWorkerCommand.html)  \n*Response Struct:* [`cdp::network::SetBypassServiceWorkerResponse`](struct.SetBypassServiceWorkerResponse.html)"]
    pub struct SetBypassServiceWorkerCommand {
        #[serde(rename = "bypass")]
        #[doc = "Bypass service worker and load from network."]
        pub bypass: bool,
    }
    impl ::CdpCommand for SetBypassServiceWorkerCommand {
        const COMMAND_NAME: &'static str = "Network.setBypassServiceWorker";
    }
    impl ::SerializeCdpCommand for SetBypassServiceWorkerCommand {
        fn command_name(&self) -> &str {
            "Network.setBypassServiceWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetBypassServiceWorkerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setBypassServiceWorker" {
                Ok ( < SetBypassServiceWorkerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles ignoring of service worker for each request.\n\n# Command `Network.setBypassServiceWorker`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetBypassServiceWorkerCommand`](struct.SetBypassServiceWorkerCommand.html)  \n*Response Struct:* [`cdp::network::SetBypassServiceWorkerResponse`](struct.SetBypassServiceWorkerResponse.html)"]
    pub struct SetBypassServiceWorkerResponse;
    impl ::serde::Serialize for SetBypassServiceWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBypassServiceWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBypassServiceWorkerResponse)
        }
    }
    impl ::CdpCommand for SetBypassServiceWorkerResponse {
        const COMMAND_NAME: &'static str = "Network.setBypassServiceWorker";
    }
    impl<'b> ::HasCdpResponse<'b> for SetBypassServiceWorkerCommand {
        type Response = SetBypassServiceWorkerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBypassServiceWorkerResponse {
        type Command = SetBypassServiceWorkerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Toggles ignoring cache for each request. If `true`, cache will not be used.\n\n# Command `Network.setCacheDisabled`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCacheDisabledCommand`](struct.SetCacheDisabledCommand.html)  \n*Response Struct:* [`cdp::network::SetCacheDisabledResponse`](struct.SetCacheDisabledResponse.html)"]
    pub struct SetCacheDisabledCommand {
        #[serde(rename = "cacheDisabled")]
        #[doc = "Cache disabled state."]
        pub cache_disabled: bool,
    }
    impl ::CdpCommand for SetCacheDisabledCommand {
        const COMMAND_NAME: &'static str = "Network.setCacheDisabled";
    }
    impl ::SerializeCdpCommand for SetCacheDisabledCommand {
        fn command_name(&self) -> &str {
            "Network.setCacheDisabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetCacheDisabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setCacheDisabled" {
                Ok ( < SetCacheDisabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Toggles ignoring cache for each request. If `true`, cache will not be used.\n\n# Command `Network.setCacheDisabled`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCacheDisabledCommand`](struct.SetCacheDisabledCommand.html)  \n*Response Struct:* [`cdp::network::SetCacheDisabledResponse`](struct.SetCacheDisabledResponse.html)"]
    pub struct SetCacheDisabledResponse;
    impl ::serde::Serialize for SetCacheDisabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCacheDisabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCacheDisabledResponse)
        }
    }
    impl ::CdpCommand for SetCacheDisabledResponse {
        const COMMAND_NAME: &'static str = "Network.setCacheDisabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetCacheDisabledCommand {
        type Response = SetCacheDisabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetCacheDisabledResponse {
        type Command = SetCacheDisabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n\n# Command `Network.setCookie`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCookieCommand`](struct.SetCookieCommand.html)  \n*Response Struct:* [`cdp::network::SetCookieResponse`](struct.SetCookieResponse.html)"]
    pub struct SetCookieCommand<'a> {
        #[serde(rename = "name")]
        #[doc = "Cookie name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Cookie value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "The request-URI to associate with the setting of the cookie. This value can affect the\ndefault domain and path values of the created cookie."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "domain", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie domain."]
        pub domain: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie path."]
        pub path: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "secure", skip_serializing_if = "Option::is_none")]
        #[doc = "True if cookie is secure."]
        pub secure: Option<bool>,
        #[serde(rename = "httpOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "True if cookie is http-only."]
        pub http_only: Option<bool>,
        #[serde(rename = "sameSite", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie SameSite type."]
        pub same_site: Option<::network::CookieSameSite>,
        #[serde(rename = "expires", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie expiration date, session cookie if not set"]
        pub expires: Option<::network::TimeSinceEpoch>,
    }
    impl<'a> ::CdpCommand for SetCookieCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.setCookie";
    }
    impl<'a> ::SerializeCdpCommand for SetCookieCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setCookie"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetCookieCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setCookie" {
                Ok(
                    <SetCookieCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.\n\n# Command `Network.setCookie`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCookieCommand`](struct.SetCookieCommand.html)  \n*Response Struct:* [`cdp::network::SetCookieResponse`](struct.SetCookieResponse.html)"]
    pub struct SetCookieResponse {
        #[serde(rename = "success")]
        #[doc = "True if successfully set cookie."]
        pub success: bool,
    }
    impl ::CdpCommand for SetCookieResponse {
        const COMMAND_NAME: &'static str = "Network.setCookie";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetCookieCommand<'a> {
        type Response = SetCookieResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetCookieResponse {
        type Command = SetCookieCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets given cookies.\n\n# Command `Network.setCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCookiesCommand`](struct.SetCookiesCommand.html)  \n*Response Struct:* [`cdp::network::SetCookiesResponse`](struct.SetCookiesResponse.html)"]
    pub struct SetCookiesCommand<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Cookies to be set."]
        pub cookies: Vec<::network::CookieParam<'a>>,
    }
    impl<'a> ::CdpCommand for SetCookiesCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.setCookies";
    }
    impl<'a> ::SerializeCdpCommand for SetCookiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetCookiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setCookies" {
                Ok(
                    <SetCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets given cookies.\n\n# Command `Network.setCookies`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetCookiesCommand`](struct.SetCookiesCommand.html)  \n*Response Struct:* [`cdp::network::SetCookiesResponse`](struct.SetCookiesResponse.html)"]
    pub struct SetCookiesResponse;
    impl ::serde::Serialize for SetCookiesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCookiesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCookiesResponse)
        }
    }
    impl ::CdpCommand for SetCookiesResponse {
        const COMMAND_NAME: &'static str = "Network.setCookies";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetCookiesCommand<'a> {
        type Response = SetCookiesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetCookiesResponse {
        type Command = SetCookiesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Network.setDataSizeLimitsForTest`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetDataSizeLimitsForTestCommand`](struct.SetDataSizeLimitsForTestCommand.html)  \n*Response Struct:* [`cdp::network::SetDataSizeLimitsForTestResponse`](struct.SetDataSizeLimitsForTestResponse.html)"]
    pub struct SetDataSizeLimitsForTestCommand {
        #[serde(rename = "maxTotalSize")]
        #[doc = "Maximum total buffer size."]
        pub max_total_size: i32,
        #[serde(rename = "maxResourceSize")]
        #[doc = "Maximum per-resource size."]
        pub max_resource_size: i32,
    }
    impl ::CdpCommand for SetDataSizeLimitsForTestCommand {
        const COMMAND_NAME: &'static str = "Network.setDataSizeLimitsForTest";
    }
    impl ::SerializeCdpCommand for SetDataSizeLimitsForTestCommand {
        fn command_name(&self) -> &str {
            "Network.setDataSizeLimitsForTest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDataSizeLimitsForTestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setDataSizeLimitsForTest" {
                Ok ( < SetDataSizeLimitsForTestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Network.setDataSizeLimitsForTest`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetDataSizeLimitsForTestCommand`](struct.SetDataSizeLimitsForTestCommand.html)  \n*Response Struct:* [`cdp::network::SetDataSizeLimitsForTestResponse`](struct.SetDataSizeLimitsForTestResponse.html)"]
    pub struct SetDataSizeLimitsForTestResponse;
    impl ::serde::Serialize for SetDataSizeLimitsForTestResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDataSizeLimitsForTestResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDataSizeLimitsForTestResponse)
        }
    }
    impl ::CdpCommand for SetDataSizeLimitsForTestResponse {
        const COMMAND_NAME: &'static str = "Network.setDataSizeLimitsForTest";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDataSizeLimitsForTestCommand {
        type Response = SetDataSizeLimitsForTestResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDataSizeLimitsForTestResponse {
        type Command = SetDataSizeLimitsForTestCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n\n# Command `Network.setExtraHTTPHeaders`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetExtraHttpHeadersCommand`](struct.SetExtraHttpHeadersCommand.html)  \n*Response Struct:* [`cdp::network::SetExtraHttpHeadersResponse`](struct.SetExtraHttpHeadersResponse.html)"]
    pub struct SetExtraHttpHeadersCommand {
        #[serde(rename = "headers")]
        #[doc = "Map with extra HTTP headers."]
        pub headers: ::network::Headers,
    }
    impl ::CdpCommand for SetExtraHttpHeadersCommand {
        const COMMAND_NAME: &'static str = "Network.setExtraHTTPHeaders";
    }
    impl ::SerializeCdpCommand for SetExtraHttpHeadersCommand {
        fn command_name(&self) -> &str {
            "Network.setExtraHTTPHeaders"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetExtraHttpHeadersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setExtraHTTPHeaders" {
                Ok ( < SetExtraHttpHeadersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Specifies whether to always send extra HTTP headers with the requests from this page.\n\n# Command `Network.setExtraHTTPHeaders`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetExtraHttpHeadersCommand`](struct.SetExtraHttpHeadersCommand.html)  \n*Response Struct:* [`cdp::network::SetExtraHttpHeadersResponse`](struct.SetExtraHttpHeadersResponse.html)"]
    pub struct SetExtraHttpHeadersResponse;
    impl ::serde::Serialize for SetExtraHttpHeadersResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetExtraHttpHeadersResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetExtraHttpHeadersResponse)
        }
    }
    impl ::CdpCommand for SetExtraHttpHeadersResponse {
        const COMMAND_NAME: &'static str = "Network.setExtraHTTPHeaders";
    }
    impl<'b> ::HasCdpResponse<'b> for SetExtraHttpHeadersCommand {
        type Response = SetExtraHttpHeadersResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetExtraHttpHeadersResponse {
        type Command = SetExtraHttpHeadersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the requests to intercept that match a the provided patterns and optionally resource types.\n\n# Command `Network.setRequestInterception`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetRequestInterceptionCommand`](struct.SetRequestInterceptionCommand.html)  \n*Response Struct:* [`cdp::network::SetRequestInterceptionResponse`](struct.SetRequestInterceptionResponse.html)"]
    pub struct SetRequestInterceptionCommand<'a> {
        #[serde(rename = "patterns")]
        #[doc = "Requests matching any of these patterns will be forwarded and wait for the corresponding\ncontinueInterceptedRequest call."]
        pub patterns: Vec<::network::RequestPattern<'a>>,
    }
    impl<'a> ::CdpCommand for SetRequestInterceptionCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.setRequestInterception";
    }
    impl<'a> ::SerializeCdpCommand for SetRequestInterceptionCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setRequestInterception"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetRequestInterceptionCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setRequestInterception" {
                Ok ( < SetRequestInterceptionCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets the requests to intercept that match a the provided patterns and optionally resource types.\n\n# Command `Network.setRequestInterception`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetRequestInterceptionCommand`](struct.SetRequestInterceptionCommand.html)  \n*Response Struct:* [`cdp::network::SetRequestInterceptionResponse`](struct.SetRequestInterceptionResponse.html)"]
    pub struct SetRequestInterceptionResponse;
    impl ::serde::Serialize for SetRequestInterceptionResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetRequestInterceptionResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetRequestInterceptionResponse)
        }
    }
    impl ::CdpCommand for SetRequestInterceptionResponse {
        const COMMAND_NAME: &'static str = "Network.setRequestInterception";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetRequestInterceptionCommand<'a> {
        type Response = SetRequestInterceptionResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetRequestInterceptionResponse {
        type Command = SetRequestInterceptionCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Network.setUserAgentOverride`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::network::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideCommand<'a> {
        #[serde(rename = "userAgent")]
        #[doc = "User agent to use."]
        pub user_agent: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "acceptLanguage", skip_serializing_if = "Option::is_none")]
        #[doc = "Browser langugage to emulate."]
        pub accept_language: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "platform", skip_serializing_if = "Option::is_none")]
        #[doc = "The platform navigator.platform should return."]
        pub platform: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetUserAgentOverrideCommand<'a> {
        const COMMAND_NAME: &'static str = "Network.setUserAgentOverride";
    }
    impl<'a> ::SerializeCdpCommand for SetUserAgentOverrideCommand<'a> {
        fn command_name(&self) -> &str {
            "Network.setUserAgentOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetUserAgentOverrideCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.setUserAgentOverride" {
                Ok ( < SetUserAgentOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Allows overriding user agent with the given string.\n\n# Command `Network.setUserAgentOverride`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Command Struct:* [`cdp::network::SetUserAgentOverrideCommand`](struct.SetUserAgentOverrideCommand.html)  \n*Response Struct:* [`cdp::network::SetUserAgentOverrideResponse`](struct.SetUserAgentOverrideResponse.html)"]
    pub struct SetUserAgentOverrideResponse;
    impl ::serde::Serialize for SetUserAgentOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetUserAgentOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetUserAgentOverrideResponse)
        }
    }
    impl ::CdpCommand for SetUserAgentOverrideResponse {
        const COMMAND_NAME: &'static str = "Network.setUserAgentOverride";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetUserAgentOverrideCommand<'a> {
        type Response = SetUserAgentOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetUserAgentOverrideResponse {
        type Command = SetUserAgentOverrideCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when data chunk was received over the network.\n\n# Event `Network.dataReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::DataReceivedEvent`](struct.DataReceivedEvent.html)"]
    pub struct DataReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "dataLength")]
        #[doc = "Data chunk length."]
        pub data_length: i32,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Actual bytes received \\(might be less than dataLength for compressed encodings\\)."]
        pub encoded_data_length: i32,
    }
    impl<'a> ::CdpEvent for DataReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.dataReceived";
    }
    impl<'a> ::SerializeCdpEvent for DataReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.dataReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DataReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.dataReceived" {
                Ok(
                    <DataReceivedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when EventSource message is received.\n\n# Event `Network.eventSourceMessageReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::EventSourceMessageReceivedEvent`](struct.EventSourceMessageReceivedEvent.html)"]
    pub struct EventSourceMessageReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "eventName")]
        #[doc = "Message type."]
        pub event_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "eventId")]
        #[doc = "Message identifier."]
        pub event_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        #[doc = "Message content."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for EventSourceMessageReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.eventSourceMessageReceived";
    }
    impl<'a> ::SerializeCdpEvent for EventSourceMessageReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.eventSourceMessageReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for EventSourceMessageReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.eventSourceMessageReceived" {
                Ok ( < EventSourceMessageReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP request has failed to load.\n\n# Event `Network.loadingFailed`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::LoadingFailedEvent`](struct.LoadingFailedEvent.html)"]
    pub struct LoadingFailedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::network::ResourceType,
        #[serde(rename = "errorText")]
        #[doc = "User friendly error message."]
        pub error_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "canceled", skip_serializing_if = "Option::is_none")]
        #[doc = "True if loading was canceled."]
        pub canceled: Option<bool>,
        #[serde(rename = "blockedReason", skip_serializing_if = "Option::is_none")]
        #[doc = "The reason why loading was blocked, if any."]
        pub blocked_reason: Option<::network::BlockedReason>,
    }
    impl<'a> ::CdpEvent for LoadingFailedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.loadingFailed";
    }
    impl<'a> ::SerializeCdpEvent for LoadingFailedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.loadingFailed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for LoadingFailedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.loadingFailed" {
                Ok(
                    <LoadingFailedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP request has finished loading.\n\n# Event `Network.loadingFinished`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::LoadingFinishedEvent`](struct.LoadingFinishedEvent.html)"]
    pub struct LoadingFinishedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Total number of bytes received for this request."]
        pub encoded_data_length: f64,
        #[serde(rename = "shouldReportCorbBlocking", skip_serializing_if = "Option::is_none")]
        #[doc = "Set when 1\\) response was blocked by Cross-Origin Read Blocking and also\n2\\) this needs to be reported to the DevTools console."]
        pub should_report_corb_blocking: Option<bool>,
    }
    impl<'a> ::CdpEvent for LoadingFinishedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.loadingFinished";
    }
    impl<'a> ::SerializeCdpEvent for LoadingFinishedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.loadingFinished"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for LoadingFinishedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.loadingFinished" {
                Ok(
                    <LoadingFinishedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Details of an intercepted HTTP request, which must be either allowed, blocked, modified or\nmocked.\n\n# Event `Network.requestIntercepted`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::RequestInterceptedEvent`](struct.RequestInterceptedEvent.html)"]
    pub struct RequestInterceptedEvent<'a> {
        #[serde(rename = "interceptionId")]
        #[doc = "Each request the page makes will have a unique id, however if any redirects are encountered\nwhile processing that fetch, they will be reported with the same id as the original fetch.\nLikewise if HTTP authentication is needed then the same fetch id will be used."]
        pub interception_id: ::network::InterceptionId<'a>,
        #[serde(rename = "request")]
        pub request: ::network::Request<'a>,
        #[serde(rename = "frameId")]
        #[doc = "The id of the frame that initiated the request."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "resourceType")]
        #[doc = "How the requested resource will be used."]
        pub resource_type: ::network::ResourceType,
        #[serde(rename = "isNavigationRequest")]
        #[doc = "Whether this is a navigation request, which can abort the navigation completely."]
        pub is_navigation_request: bool,
        #[serde(rename = "isDownload", skip_serializing_if = "Option::is_none")]
        #[doc = "Set if the request is a navigation that will result in a download.\nOnly present after response is received from the server \\(i.e. HeadersReceived stage\\)."]
        pub is_download: Option<bool>,
        #[serde(rename = "redirectUrl", skip_serializing_if = "Option::is_none")]
        #[doc = "Redirect location, only sent if a redirect was intercepted."]
        pub redirect_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "authChallenge", skip_serializing_if = "Option::is_none")]
        #[doc = "Details of the Authorization Challenge encountered. If this is set then\ncontinueInterceptedRequest must contain an authChallengeResponse."]
        pub auth_challenge: Option<::network::AuthChallenge<'a>>,
        #[serde(rename = "responseErrorReason", skip_serializing_if = "Option::is_none")]
        #[doc = "Response error if intercepted at response stage or if redirect occurred while intercepting\nrequest."]
        pub response_error_reason: Option<::network::ErrorReason>,
        #[serde(rename = "responseStatusCode", skip_serializing_if = "Option::is_none")]
        #[doc = "Response code if intercepted at response stage or if redirect occurred while intercepting\nrequest or auth retry occurred."]
        pub response_status_code: Option<i32>,
        #[serde(rename = "responseHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "Response headers if intercepted at the response stage or if redirect occurred while\nintercepting request or auth retry occurred."]
        pub response_headers: Option<::network::Headers>,
    }
    impl<'a> ::CdpEvent for RequestInterceptedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.requestIntercepted";
    }
    impl<'a> ::SerializeCdpEvent for RequestInterceptedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestIntercepted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for RequestInterceptedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestIntercepted" {
                Ok ( < RequestInterceptedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired if request ended up loading from cache.\n\n# Event `Network.requestServedFromCache`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::RequestServedFromCacheEvent`](struct.RequestServedFromCacheEvent.html)"]
    pub struct RequestServedFromCacheEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
    }
    impl<'a> ::CdpEvent for RequestServedFromCacheEvent<'a> {
        const EVENT_NAME: &'static str = "Network.requestServedFromCache";
    }
    impl<'a> ::SerializeCdpEvent for RequestServedFromCacheEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestServedFromCache"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for RequestServedFromCacheEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestServedFromCache" {
                Ok ( < RequestServedFromCacheEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when page is about to send HTTP request.\n\n# Event `Network.requestWillBeSent`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::RequestWillBeSentEvent`](struct.RequestWillBeSentEvent.html)"]
    pub struct RequestWillBeSentEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "loaderId")]
        #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
        pub loader_id: ::network::LoaderId<'a>,
        #[serde(rename = "documentURL")]
        #[doc = "URL of the document this request is loaded for."]
        pub document_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "request")]
        #[doc = "Request data."]
        pub request: ::network::Request<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "wallTime")]
        #[doc = "Timestamp."]
        pub wall_time: ::network::TimeSinceEpoch,
        #[serde(rename = "initiator")]
        #[doc = "Request initiator."]
        pub initiator: ::network::Initiator<'a>,
        #[serde(rename = "redirectResponse", skip_serializing_if = "Option::is_none")]
        #[doc = "Redirect response data."]
        pub redirect_response: Option<::network::Response<'a>>,
        #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
        #[doc = "Type of this resource."]
        pub ty: Option<::network::ResourceType>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame identifier."]
        pub frame_id: Option<::page::FrameId<'a>>,
        #[serde(rename = "hasUserGesture", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the request is initiated by a user gesture. Defaults to false."]
        pub has_user_gesture: Option<bool>,
    }
    impl<'a> ::CdpEvent for RequestWillBeSentEvent<'a> {
        const EVENT_NAME: &'static str = "Network.requestWillBeSent";
    }
    impl<'a> ::SerializeCdpEvent for RequestWillBeSentEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.requestWillBeSent"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for RequestWillBeSentEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.requestWillBeSent" {
                Ok(
                    <RequestWillBeSentEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when resource loading priority is changed\n\n# Event `Network.resourceChangedPriority`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::ResourceChangedPriorityEvent`](struct.ResourceChangedPriorityEvent.html)"]
    pub struct ResourceChangedPriorityEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "newPriority")]
        #[doc = "New priority"]
        pub new_priority: ::network::ResourcePriority,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
    }
    impl<'a> ::CdpEvent for ResourceChangedPriorityEvent<'a> {
        const EVENT_NAME: &'static str = "Network.resourceChangedPriority";
    }
    impl<'a> ::SerializeCdpEvent for ResourceChangedPriorityEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.resourceChangedPriority"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ResourceChangedPriorityEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.resourceChangedPriority" {
                Ok ( < ResourceChangedPriorityEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when a signed exchange was received over the network\n\n# Event `Network.signedExchangeReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::SignedExchangeReceivedEvent`](struct.SignedExchangeReceivedEvent.html)"]
    pub struct SignedExchangeReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "info")]
        #[doc = "Information about the signed exchange response."]
        pub info: ::network::SignedExchangeInfo<'a>,
    }
    impl<'a> ::CdpEvent for SignedExchangeReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.signedExchangeReceived";
    }
    impl<'a> ::SerializeCdpEvent for SignedExchangeReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.signedExchangeReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for SignedExchangeReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.signedExchangeReceived" {
                Ok ( < SignedExchangeReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when HTTP response is available.\n\n# Event `Network.responseReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::ResponseReceivedEvent`](struct.ResponseReceivedEvent.html)"]
    pub struct ResponseReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "loaderId")]
        #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
        pub loader_id: ::network::LoaderId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "type")]
        #[doc = "Resource type."]
        pub ty: ::network::ResourceType,
        #[serde(rename = "response")]
        #[doc = "Response data."]
        pub response: ::network::Response<'a>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame identifier."]
        pub frame_id: Option<::page::FrameId<'a>>,
    }
    impl<'a> ::CdpEvent for ResponseReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.responseReceived";
    }
    impl<'a> ::SerializeCdpEvent for ResponseReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.responseReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ResponseReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.responseReceived" {
                Ok(
                    <ResponseReceivedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket is closed.\n\n# Event `Network.webSocketClosed`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketClosedEvent`](struct.WebSocketClosedEvent.html)"]
    pub struct WebSocketClosedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
    }
    impl<'a> ::CdpEvent for WebSocketClosedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketClosed";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketClosedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketClosed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketClosedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketClosed" {
                Ok(
                    <WebSocketClosedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired upon WebSocket creation.\n\n# Event `Network.webSocketCreated`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketCreatedEvent`](struct.WebSocketCreatedEvent.html)"]
    pub struct WebSocketCreatedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "url")]
        #[doc = "WebSocket request URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "initiator", skip_serializing_if = "Option::is_none")]
        #[doc = "Request initiator."]
        pub initiator: Option<::network::Initiator<'a>>,
    }
    impl<'a> ::CdpEvent for WebSocketCreatedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketCreated";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketCreated" {
                Ok(
                    <WebSocketCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket frame error occurs.\n\n# Event `Network.webSocketFrameError`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketFrameErrorEvent`](struct.WebSocketFrameErrorEvent.html)"]
    pub struct WebSocketFrameErrorEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "errorMessage")]
        #[doc = "WebSocket frame error message."]
        pub error_message: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for WebSocketFrameErrorEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketFrameError";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketFrameErrorEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameError"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketFrameErrorEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameError" {
                Ok ( < WebSocketFrameErrorEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket frame is received.\n\n# Event `Network.webSocketFrameReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketFrameReceivedEvent`](struct.WebSocketFrameReceivedEvent.html)"]
    pub struct WebSocketFrameReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::network::WebSocketFrame<'a>,
    }
    impl<'a> ::CdpEvent for WebSocketFrameReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketFrameReceived";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketFrameReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketFrameReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameReceived" {
                Ok ( < WebSocketFrameReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket frame is sent.\n\n# Event `Network.webSocketFrameSent`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketFrameSentEvent`](struct.WebSocketFrameSentEvent.html)"]
    pub struct WebSocketFrameSentEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::network::WebSocketFrame<'a>,
    }
    impl<'a> ::CdpEvent for WebSocketFrameSentEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketFrameSent";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketFrameSentEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketFrameSent"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketFrameSentEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketFrameSent" {
                Ok ( < WebSocketFrameSentEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket handshake response becomes available.\n\n# Event `Network.webSocketHandshakeResponseReceived`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketHandshakeResponseReceivedEvent`](struct.WebSocketHandshakeResponseReceivedEvent.html)"]
    pub struct WebSocketHandshakeResponseReceivedEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "response")]
        #[doc = "WebSocket response data."]
        pub response: ::network::WebSocketResponse<'a>,
    }
    impl<'a> ::CdpEvent for WebSocketHandshakeResponseReceivedEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketHandshakeResponseReceived";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketHandshakeResponseReceivedEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketHandshakeResponseReceived"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketHandshakeResponseReceivedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketHandshakeResponseReceived" {
                Ok ( < WebSocketHandshakeResponseReceivedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when WebSocket is about to initiate handshake.\n\n# Event `Network.webSocketWillSendHandshakeRequest`\n\n*Domain Module:* [`cdp::network`](index.html)  \n*Event Struct:* [`cdp::network::WebSocketWillSendHandshakeRequestEvent`](struct.WebSocketWillSendHandshakeRequestEvent.html)"]
    pub struct WebSocketWillSendHandshakeRequestEvent<'a> {
        #[serde(rename = "requestId")]
        #[doc = "Request identifier."]
        pub request_id: ::network::RequestId<'a>,
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp."]
        pub timestamp: ::network::MonotonicTime,
        #[serde(rename = "wallTime")]
        #[doc = "UTC Timestamp."]
        pub wall_time: ::network::TimeSinceEpoch,
        #[serde(rename = "request")]
        #[doc = "WebSocket request data."]
        pub request: ::network::WebSocketRequest,
    }
    impl<'a> ::CdpEvent for WebSocketWillSendHandshakeRequestEvent<'a> {
        const EVENT_NAME: &'static str = "Network.webSocketWillSendHandshakeRequest";
    }
    impl<'a> ::SerializeCdpEvent for WebSocketWillSendHandshakeRequestEvent<'a> {
        fn event_name(&self) -> &str {
            "Network.webSocketWillSendHandshakeRequest"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WebSocketWillSendHandshakeRequestEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Network.webSocketWillSendHandshakeRequest" {
                Ok ( < WebSocketWillSendHandshakeRequestEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Resource type as it was perceived by the rendering engine."]
    pub enum ResourceType {
        #[serde(rename = "Document")]
        #[doc = "Represented as `\"Document\"`."]
        Document,
        #[serde(rename = "Stylesheet")]
        #[doc = "Represented as `\"Stylesheet\"`."]
        Stylesheet,
        #[serde(rename = "Image")]
        #[doc = "Represented as `\"Image\"`."]
        Image,
        #[serde(rename = "Media")]
        #[doc = "Represented as `\"Media\"`."]
        Media,
        #[serde(rename = "Font")]
        #[doc = "Represented as `\"Font\"`."]
        Font,
        #[serde(rename = "Script")]
        #[doc = "Represented as `\"Script\"`."]
        Script,
        #[serde(rename = "TextTrack")]
        #[doc = "Represented as `\"TextTrack\"`."]
        TextTrack,
        #[serde(rename = "XHR")]
        #[doc = "Represented as `\"XHR\"`."]
        Xhr,
        #[serde(rename = "Fetch")]
        #[doc = "Represented as `\"Fetch\"`."]
        Fetch,
        #[serde(rename = "EventSource")]
        #[doc = "Represented as `\"EventSource\"`."]
        EventSource,
        #[serde(rename = "WebSocket")]
        #[doc = "Represented as `\"WebSocket\"`."]
        WebSocket,
        #[serde(rename = "Manifest")]
        #[doc = "Represented as `\"Manifest\"`."]
        Manifest,
        #[serde(rename = "SignedExchange")]
        #[doc = "Represented as `\"SignedExchange\"`."]
        SignedExchange,
        #[serde(rename = "Ping")]
        #[doc = "Represented as `\"Ping\"`."]
        Ping,
        #[serde(rename = "CSPViolationReport")]
        #[doc = "Represented as `\"CSPViolationReport\"`."]
        CspViolationReport,
        #[serde(rename = "Other")]
        #[doc = "Represented as `\"Other\"`."]
        Other,
    }
    impl ResourceType {
        pub const ENUM_VALUES: &'static [ResourceType] = &[
            ResourceType::Document,
            ResourceType::Stylesheet,
            ResourceType::Image,
            ResourceType::Media,
            ResourceType::Font,
            ResourceType::Script,
            ResourceType::TextTrack,
            ResourceType::Xhr,
            ResourceType::Fetch,
            ResourceType::EventSource,
            ResourceType::WebSocket,
            ResourceType::Manifest,
            ResourceType::SignedExchange,
            ResourceType::Ping,
            ResourceType::CspViolationReport,
            ResourceType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "Document",
            "Stylesheet",
            "Image",
            "Media",
            "Font",
            "Script",
            "TextTrack",
            "XHR",
            "Fetch",
            "EventSource",
            "WebSocket",
            "Manifest",
            "SignedExchange",
            "Ping",
            "CSPViolationReport",
            "Other",
        ];
    }
    impl ::std::str::FromStr for ResourceType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Document" => Ok(ResourceType::Document),
                "Stylesheet" => Ok(ResourceType::Stylesheet),
                "Image" => Ok(ResourceType::Image),
                "Media" => Ok(ResourceType::Media),
                "Font" => Ok(ResourceType::Font),
                "Script" => Ok(ResourceType::Script),
                "TextTrack" => Ok(ResourceType::TextTrack),
                "XHR" => Ok(ResourceType::Xhr),
                "Fetch" => Ok(ResourceType::Fetch),
                "EventSource" => Ok(ResourceType::EventSource),
                "WebSocket" => Ok(ResourceType::WebSocket),
                "Manifest" => Ok(ResourceType::Manifest),
                "SignedExchange" => Ok(ResourceType::SignedExchange),
                "Ping" => Ok(ResourceType::Ping),
                "CSPViolationReport" => Ok(ResourceType::CspViolationReport),
                "Other" => Ok(ResourceType::Other),
                _ => Err(::ParseEnumError {
                    expected: ResourceType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ResourceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ResourceType::Document => "Document",
                    ResourceType::Stylesheet => "Stylesheet",
                    ResourceType::Image => "Image",
                    ResourceType::Media => "Media",
                    ResourceType::Font => "Font",
                    ResourceType::Script => "Script",
                    ResourceType::TextTrack => "TextTrack",
                    ResourceType::Xhr => "XHR",
                    ResourceType::Fetch => "Fetch",
                    ResourceType::EventSource => "EventSource",
                    ResourceType::WebSocket => "WebSocket",
                    ResourceType::Manifest => "Manifest",
                    ResourceType::SignedExchange => "SignedExchange",
                    ResourceType::Ping => "Ping",
                    ResourceType::CspViolationReport => "CSPViolationReport",
                    ResourceType::Other => "Other",
                }
            )
        }
    }
    #[doc = "Unique loader identifier."]
    pub type LoaderId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique request identifier."]
    pub type RequestId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique intercepted request identifier."]
    pub type InterceptionId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Network level fetch failure reason."]
    pub enum ErrorReason {
        #[serde(rename = "Failed")]
        #[doc = "Represented as `\"Failed\"`."]
        Failed,
        #[serde(rename = "Aborted")]
        #[doc = "Represented as `\"Aborted\"`."]
        Aborted,
        #[serde(rename = "TimedOut")]
        #[doc = "Represented as `\"TimedOut\"`."]
        TimedOut,
        #[serde(rename = "AccessDenied")]
        #[doc = "Represented as `\"AccessDenied\"`."]
        AccessDenied,
        #[serde(rename = "ConnectionClosed")]
        #[doc = "Represented as `\"ConnectionClosed\"`."]
        ConnectionClosed,
        #[serde(rename = "ConnectionReset")]
        #[doc = "Represented as `\"ConnectionReset\"`."]
        ConnectionReset,
        #[serde(rename = "ConnectionRefused")]
        #[doc = "Represented as `\"ConnectionRefused\"`."]
        ConnectionRefused,
        #[serde(rename = "ConnectionAborted")]
        #[doc = "Represented as `\"ConnectionAborted\"`."]
        ConnectionAborted,
        #[serde(rename = "ConnectionFailed")]
        #[doc = "Represented as `\"ConnectionFailed\"`."]
        ConnectionFailed,
        #[serde(rename = "NameNotResolved")]
        #[doc = "Represented as `\"NameNotResolved\"`."]
        NameNotResolved,
        #[serde(rename = "InternetDisconnected")]
        #[doc = "Represented as `\"InternetDisconnected\"`."]
        InternetDisconnected,
        #[serde(rename = "AddressUnreachable")]
        #[doc = "Represented as `\"AddressUnreachable\"`."]
        AddressUnreachable,
        #[serde(rename = "BlockedByClient")]
        #[doc = "Represented as `\"BlockedByClient\"`."]
        BlockedByClient,
        #[serde(rename = "BlockedByResponse")]
        #[doc = "Represented as `\"BlockedByResponse\"`."]
        BlockedByResponse,
    }
    impl ErrorReason {
        pub const ENUM_VALUES: &'static [ErrorReason] = &[
            ErrorReason::Failed,
            ErrorReason::Aborted,
            ErrorReason::TimedOut,
            ErrorReason::AccessDenied,
            ErrorReason::ConnectionClosed,
            ErrorReason::ConnectionReset,
            ErrorReason::ConnectionRefused,
            ErrorReason::ConnectionAborted,
            ErrorReason::ConnectionFailed,
            ErrorReason::NameNotResolved,
            ErrorReason::InternetDisconnected,
            ErrorReason::AddressUnreachable,
            ErrorReason::BlockedByClient,
            ErrorReason::BlockedByResponse,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "Failed",
            "Aborted",
            "TimedOut",
            "AccessDenied",
            "ConnectionClosed",
            "ConnectionReset",
            "ConnectionRefused",
            "ConnectionAborted",
            "ConnectionFailed",
            "NameNotResolved",
            "InternetDisconnected",
            "AddressUnreachable",
            "BlockedByClient",
            "BlockedByResponse",
        ];
    }
    impl ::std::str::FromStr for ErrorReason {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Failed" => Ok(ErrorReason::Failed),
                "Aborted" => Ok(ErrorReason::Aborted),
                "TimedOut" => Ok(ErrorReason::TimedOut),
                "AccessDenied" => Ok(ErrorReason::AccessDenied),
                "ConnectionClosed" => Ok(ErrorReason::ConnectionClosed),
                "ConnectionReset" => Ok(ErrorReason::ConnectionReset),
                "ConnectionRefused" => Ok(ErrorReason::ConnectionRefused),
                "ConnectionAborted" => Ok(ErrorReason::ConnectionAborted),
                "ConnectionFailed" => Ok(ErrorReason::ConnectionFailed),
                "NameNotResolved" => Ok(ErrorReason::NameNotResolved),
                "InternetDisconnected" => Ok(ErrorReason::InternetDisconnected),
                "AddressUnreachable" => Ok(ErrorReason::AddressUnreachable),
                "BlockedByClient" => Ok(ErrorReason::BlockedByClient),
                "BlockedByResponse" => Ok(ErrorReason::BlockedByResponse),
                _ => Err(::ParseEnumError {
                    expected: ErrorReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ErrorReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ErrorReason::Failed => "Failed",
                    ErrorReason::Aborted => "Aborted",
                    ErrorReason::TimedOut => "TimedOut",
                    ErrorReason::AccessDenied => "AccessDenied",
                    ErrorReason::ConnectionClosed => "ConnectionClosed",
                    ErrorReason::ConnectionReset => "ConnectionReset",
                    ErrorReason::ConnectionRefused => "ConnectionRefused",
                    ErrorReason::ConnectionAborted => "ConnectionAborted",
                    ErrorReason::ConnectionFailed => "ConnectionFailed",
                    ErrorReason::NameNotResolved => "NameNotResolved",
                    ErrorReason::InternetDisconnected => "InternetDisconnected",
                    ErrorReason::AddressUnreachable => "AddressUnreachable",
                    ErrorReason::BlockedByClient => "BlockedByClient",
                    ErrorReason::BlockedByResponse => "BlockedByResponse",
                }
            )
        }
    }
    #[doc = "UTC time in seconds, counted from January 1, 1970."]
    pub type TimeSinceEpoch = f64;
    #[doc = "Monotonically increasing time in seconds since an arbitrary point in the past."]
    pub type MonotonicTime = f64;
    #[doc = "Request / response headers as keys / values of JSON object."]
    pub type Headers = ::Empty;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "The underlying connection technology that the browser is supposedly using."]
    pub enum ConnectionType {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "cellular2g")]
        #[doc = "Represented as `\"cellular2g\"`."]
        Cellular2G,
        #[serde(rename = "cellular3g")]
        #[doc = "Represented as `\"cellular3g\"`."]
        Cellular3G,
        #[serde(rename = "cellular4g")]
        #[doc = "Represented as `\"cellular4g\"`."]
        Cellular4G,
        #[serde(rename = "bluetooth")]
        #[doc = "Represented as `\"bluetooth\"`."]
        Bluetooth,
        #[serde(rename = "ethernet")]
        #[doc = "Represented as `\"ethernet\"`."]
        Ethernet,
        #[serde(rename = "wifi")]
        #[doc = "Represented as `\"wifi\"`."]
        Wifi,
        #[serde(rename = "wimax")]
        #[doc = "Represented as `\"wimax\"`."]
        Wimax,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl ConnectionType {
        pub const ENUM_VALUES: &'static [ConnectionType] = &[
            ConnectionType::None,
            ConnectionType::Cellular2G,
            ConnectionType::Cellular3G,
            ConnectionType::Cellular4G,
            ConnectionType::Bluetooth,
            ConnectionType::Ethernet,
            ConnectionType::Wifi,
            ConnectionType::Wimax,
            ConnectionType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "none",
            "cellular2g",
            "cellular3g",
            "cellular4g",
            "bluetooth",
            "ethernet",
            "wifi",
            "wimax",
            "other",
        ];
    }
    impl ::std::str::FromStr for ConnectionType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(ConnectionType::None),
                "cellular2g" => Ok(ConnectionType::Cellular2G),
                "cellular3g" => Ok(ConnectionType::Cellular3G),
                "cellular4g" => Ok(ConnectionType::Cellular4G),
                "bluetooth" => Ok(ConnectionType::Bluetooth),
                "ethernet" => Ok(ConnectionType::Ethernet),
                "wifi" => Ok(ConnectionType::Wifi),
                "wimax" => Ok(ConnectionType::Wimax),
                "other" => Ok(ConnectionType::Other),
                _ => Err(::ParseEnumError {
                    expected: ConnectionType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConnectionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConnectionType::None => "none",
                    ConnectionType::Cellular2G => "cellular2g",
                    ConnectionType::Cellular3G => "cellular3g",
                    ConnectionType::Cellular4G => "cellular4g",
                    ConnectionType::Bluetooth => "bluetooth",
                    ConnectionType::Ethernet => "ethernet",
                    ConnectionType::Wifi => "wifi",
                    ConnectionType::Wimax => "wimax",
                    ConnectionType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Represents the cookie's 'SameSite' status:\nhttps://tools.ietf.org/html/draft-west-first-party-cookies"]
    pub enum CookieSameSite {
        #[serde(rename = "Strict")]
        #[doc = "Represented as `\"Strict\"`."]
        Strict,
        #[serde(rename = "Lax")]
        #[doc = "Represented as `\"Lax\"`."]
        Lax,
    }
    impl CookieSameSite {
        pub const ENUM_VALUES: &'static [CookieSameSite] =
            &[CookieSameSite::Strict, CookieSameSite::Lax];
        pub const STR_VALUES: &'static [&'static str] = &["Strict", "Lax"];
    }
    impl ::std::str::FromStr for CookieSameSite {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Strict" => Ok(CookieSameSite::Strict),
                "Lax" => Ok(CookieSameSite::Lax),
                _ => Err(::ParseEnumError {
                    expected: CookieSameSite::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CookieSameSite {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CookieSameSite::Strict => "Strict",
                    CookieSameSite::Lax => "Lax",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Timing information for the request."]
    pub struct ResourceTiming {
        #[serde(rename = "requestTime")]
        #[doc = "Timing's requestTime is a baseline in seconds, while the other numbers are ticks in\nmilliseconds relatively to this requestTime."]
        pub request_time: f64,
        #[serde(rename = "proxyStart")]
        #[doc = "Started resolving proxy."]
        pub proxy_start: f64,
        #[serde(rename = "proxyEnd")]
        #[doc = "Finished resolving proxy."]
        pub proxy_end: f64,
        #[serde(rename = "dnsStart")]
        #[doc = "Started DNS address resolve."]
        pub dns_start: f64,
        #[serde(rename = "dnsEnd")]
        #[doc = "Finished DNS address resolve."]
        pub dns_end: f64,
        #[serde(rename = "connectStart")]
        #[doc = "Started connecting to the remote host."]
        pub connect_start: f64,
        #[serde(rename = "connectEnd")]
        #[doc = "Connected to the remote host."]
        pub connect_end: f64,
        #[serde(rename = "sslStart")]
        #[doc = "Started SSL handshake."]
        pub ssl_start: f64,
        #[serde(rename = "sslEnd")]
        #[doc = "Finished SSL handshake."]
        pub ssl_end: f64,
        #[serde(rename = "workerStart")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Started running ServiceWorker."]
        pub worker_start: f64,
        #[serde(rename = "workerReady")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Finished Starting ServiceWorker."]
        pub worker_ready: f64,
        #[serde(rename = "sendStart")]
        #[doc = "Started sending request."]
        pub send_start: f64,
        #[serde(rename = "sendEnd")]
        #[doc = "Finished sending request."]
        pub send_end: f64,
        #[serde(rename = "pushStart")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Time the server started pushing request."]
        pub push_start: f64,
        #[serde(rename = "pushEnd")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Time the server finished pushing request."]
        pub push_end: f64,
        #[serde(rename = "receiveHeadersEnd")]
        #[doc = "Finished receiving response headers."]
        pub receive_headers_end: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Loading priority of a resource request."]
    pub enum ResourcePriority {
        #[serde(rename = "VeryLow")]
        #[doc = "Represented as `\"VeryLow\"`."]
        VeryLow,
        #[serde(rename = "Low")]
        #[doc = "Represented as `\"Low\"`."]
        Low,
        #[serde(rename = "Medium")]
        #[doc = "Represented as `\"Medium\"`."]
        Medium,
        #[serde(rename = "High")]
        #[doc = "Represented as `\"High\"`."]
        High,
        #[serde(rename = "VeryHigh")]
        #[doc = "Represented as `\"VeryHigh\"`."]
        VeryHigh,
    }
    impl ResourcePriority {
        pub const ENUM_VALUES: &'static [ResourcePriority] = &[
            ResourcePriority::VeryLow,
            ResourcePriority::Low,
            ResourcePriority::Medium,
            ResourcePriority::High,
            ResourcePriority::VeryHigh,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["VeryLow", "Low", "Medium", "High", "VeryHigh"];
    }
    impl ::std::str::FromStr for ResourcePriority {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "VeryLow" => Ok(ResourcePriority::VeryLow),
                "Low" => Ok(ResourcePriority::Low),
                "Medium" => Ok(ResourcePriority::Medium),
                "High" => Ok(ResourcePriority::High),
                "VeryHigh" => Ok(ResourcePriority::VeryHigh),
                _ => Err(::ParseEnumError {
                    expected: ResourcePriority::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ResourcePriority {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ResourcePriority::VeryLow => "VeryLow",
                    ResourcePriority::Low => "Low",
                    ResourcePriority::Medium => "Medium",
                    ResourcePriority::High => "High",
                    ResourcePriority::VeryHigh => "VeryHigh",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::network::Request::referrer_policy`](struct.Request.html#structfield.referrer_policy)."]
    pub enum RequestReferrerPolicy {
        #[serde(rename = "unsafe-url")]
        #[doc = "Represented as `\"unsafe-url\"`."]
        UnsafeUrl,
        #[serde(rename = "no-referrer-when-downgrade")]
        #[doc = "Represented as `\"no-referrer-when-downgrade\"`."]
        NoReferrerWhenDowngrade,
        #[serde(rename = "no-referrer")]
        #[doc = "Represented as `\"no-referrer\"`."]
        NoReferrer,
        #[serde(rename = "origin")]
        #[doc = "Represented as `\"origin\"`."]
        Origin,
        #[serde(rename = "origin-when-cross-origin")]
        #[doc = "Represented as `\"origin-when-cross-origin\"`."]
        OriginWhenCrossOrigin,
        #[serde(rename = "same-origin")]
        #[doc = "Represented as `\"same-origin\"`."]
        SameOrigin,
        #[serde(rename = "strict-origin")]
        #[doc = "Represented as `\"strict-origin\"`."]
        StrictOrigin,
        #[serde(rename = "strict-origin-when-cross-origin")]
        #[doc = "Represented as `\"strict-origin-when-cross-origin\"`."]
        StrictOriginWhenCrossOrigin,
    }
    impl RequestReferrerPolicy {
        pub const ENUM_VALUES: &'static [RequestReferrerPolicy] =
            &[
                RequestReferrerPolicy::UnsafeUrl,
                RequestReferrerPolicy::NoReferrerWhenDowngrade,
                RequestReferrerPolicy::NoReferrer,
                RequestReferrerPolicy::Origin,
                RequestReferrerPolicy::OriginWhenCrossOrigin,
                RequestReferrerPolicy::SameOrigin,
                RequestReferrerPolicy::StrictOrigin,
                RequestReferrerPolicy::StrictOriginWhenCrossOrigin,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "unsafe-url",
            "no-referrer-when-downgrade",
            "no-referrer",
            "origin",
            "origin-when-cross-origin",
            "same-origin",
            "strict-origin",
            "strict-origin-when-cross-origin",
        ];
    }
    impl ::std::str::FromStr for RequestReferrerPolicy {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "unsafe-url" => Ok(RequestReferrerPolicy::UnsafeUrl),
                "no-referrer-when-downgrade" => Ok(RequestReferrerPolicy::NoReferrerWhenDowngrade),
                "no-referrer" => Ok(RequestReferrerPolicy::NoReferrer),
                "origin" => Ok(RequestReferrerPolicy::Origin),
                "origin-when-cross-origin" => Ok(RequestReferrerPolicy::OriginWhenCrossOrigin),
                "same-origin" => Ok(RequestReferrerPolicy::SameOrigin),
                "strict-origin" => Ok(RequestReferrerPolicy::StrictOrigin),
                "strict-origin-when-cross-origin" => {
                    Ok(RequestReferrerPolicy::StrictOriginWhenCrossOrigin)
                }
                _ => Err(::ParseEnumError {
                    expected: RequestReferrerPolicy::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RequestReferrerPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RequestReferrerPolicy::UnsafeUrl => "unsafe-url",
                    RequestReferrerPolicy::NoReferrerWhenDowngrade => "no-referrer-when-downgrade",
                    RequestReferrerPolicy::NoReferrer => "no-referrer",
                    RequestReferrerPolicy::Origin => "origin",
                    RequestReferrerPolicy::OriginWhenCrossOrigin => "origin-when-cross-origin",
                    RequestReferrerPolicy::SameOrigin => "same-origin",
                    RequestReferrerPolicy::StrictOrigin => "strict-origin",
                    RequestReferrerPolicy::StrictOriginWhenCrossOrigin => {
                        "strict-origin-when-cross-origin"
                    }
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "HTTP request data."]
    pub struct Request<'a> {
        #[serde(rename = "url")]
        #[doc = "Request URL \\(without fragment\\)."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "urlFragment", skip_serializing_if = "Option::is_none")]
        #[doc = "Fragment of the requested URL starting with hash, if present."]
        pub url_fragment: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "method")]
        #[doc = "HTTP request method."]
        pub method: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP request headers."]
        pub headers: ::network::Headers,
        #[serde(rename = "postData", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP POST request data."]
        pub post_data: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "hasPostData", skip_serializing_if = "Option::is_none")]
        #[doc = "True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long."]
        pub has_post_data: Option<bool>,
        #[serde(rename = "mixedContentType", skip_serializing_if = "Option::is_none")]
        #[doc = "The mixed content type of the request."]
        pub mixed_content_type: Option<::security::MixedContentType>,
        #[serde(rename = "initialPriority")]
        #[doc = "Priority of the resource request at the time request is sent."]
        pub initial_priority: ::network::ResourcePriority,
        #[serde(rename = "referrerPolicy")]
        #[doc = "The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/"]
        pub referrer_policy: ::network::RequestReferrerPolicy,
        #[serde(rename = "isLinkPreload", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether is loaded via link preload."]
        pub is_link_preload: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Details of a signed certificate timestamp \\(SCT\\)."]
    pub struct SignedCertificateTimestamp<'a> {
        #[serde(rename = "status")]
        #[doc = "Validation status."]
        pub status: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "origin")]
        #[doc = "Origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "logDescription")]
        #[doc = "Log name / description."]
        pub log_description: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "logId")]
        #[doc = "Log ID."]
        pub log_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "timestamp")]
        #[doc = "Issuance date."]
        pub timestamp: ::network::TimeSinceEpoch,
        #[serde(rename = "hashAlgorithm")]
        #[doc = "Hash algorithm."]
        pub hash_algorithm: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signatureAlgorithm")]
        #[doc = "Signature algorithm."]
        pub signature_algorithm: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signatureData")]
        #[doc = "Signature data."]
        pub signature_data: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Security details about a request."]
    pub struct SecurityDetails<'a> {
        #[serde(rename = "protocol")]
        #[doc = "Protocol name \\(e.g. \"TLS 1.2\" or \"QUIC\"\\)."]
        pub protocol: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyExchange")]
        #[doc = "Key Exchange used by the connection, or the empty string if not applicable."]
        pub key_exchange: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "keyExchangeGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "\\(EC\\)DH group used by the connection, if applicable."]
        pub key_exchange_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "cipher")]
        #[doc = "Cipher name."]
        pub cipher: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "mac", skip_serializing_if = "Option::is_none")]
        #[doc = "TLS MAC. Note that AEAD ciphers do not have separate MACs."]
        pub mac: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "certificateId")]
        #[doc = "Certificate ID value."]
        pub certificate_id: ::security::CertificateId,
        #[serde(rename = "subjectName")]
        #[doc = "Certificate subject name."]
        pub subject_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sanList")]
        #[doc = "Subject Alternative Name \\(SAN\\) DNS names and IP addresses."]
        pub san_list: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "issuer")]
        #[doc = "Name of the issuing CA."]
        pub issuer: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "validFrom")]
        #[doc = "Certificate valid from date."]
        pub valid_from: ::network::TimeSinceEpoch,
        #[serde(rename = "validTo")]
        #[doc = "Certificate valid to \\(expiration\\) date"]
        pub valid_to: ::network::TimeSinceEpoch,
        #[serde(rename = "signedCertificateTimestampList")]
        #[doc = "List of signed certificate timestamps \\(SCTs\\)."]
        pub signed_certificate_timestamp_list:
            Vec<::network::SignedCertificateTimestamp<'a>>,
        #[serde(rename = "certificateTransparencyCompliance")]
        #[doc = "Whether the request complied with Certificate Transparency policy"]
        pub certificate_transparency_compliance:
            ::network::CertificateTransparencyCompliance,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Whether the request complied with Certificate Transparency policy."]
    pub enum CertificateTransparencyCompliance {
        #[serde(rename = "unknown")]
        #[doc = "Represented as `\"unknown\"`."]
        Unknown,
        #[serde(rename = "not-compliant")]
        #[doc = "Represented as `\"not-compliant\"`."]
        NotCompliant,
        #[serde(rename = "compliant")]
        #[doc = "Represented as `\"compliant\"`."]
        Compliant,
    }
    impl CertificateTransparencyCompliance {
        pub const ENUM_VALUES: &'static [CertificateTransparencyCompliance] =
            &[
                CertificateTransparencyCompliance::Unknown,
                CertificateTransparencyCompliance::NotCompliant,
                CertificateTransparencyCompliance::Compliant,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["unknown", "not-compliant", "compliant"];
    }
    impl ::std::str::FromStr for CertificateTransparencyCompliance {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "unknown" => Ok(CertificateTransparencyCompliance::Unknown),
                "not-compliant" => Ok(CertificateTransparencyCompliance::NotCompliant),
                "compliant" => Ok(CertificateTransparencyCompliance::Compliant),
                _ => Err(::ParseEnumError {
                    expected: CertificateTransparencyCompliance::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CertificateTransparencyCompliance {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CertificateTransparencyCompliance::Unknown => "unknown",
                    CertificateTransparencyCompliance::NotCompliant => "not-compliant",
                    CertificateTransparencyCompliance::Compliant => "compliant",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "The reason why request was blocked."]
    pub enum BlockedReason {
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
        #[serde(rename = "csp")]
        #[doc = "Represented as `\"csp\"`."]
        Csp,
        #[serde(rename = "mixed-content")]
        #[doc = "Represented as `\"mixed-content\"`."]
        MixedContent,
        #[serde(rename = "origin")]
        #[doc = "Represented as `\"origin\"`."]
        Origin,
        #[serde(rename = "inspector")]
        #[doc = "Represented as `\"inspector\"`."]
        Inspector,
        #[serde(rename = "subresource-filter")]
        #[doc = "Represented as `\"subresource-filter\"`."]
        SubresourceFilter,
        #[serde(rename = "content-type")]
        #[doc = "Represented as `\"content-type\"`."]
        ContentType,
        #[serde(rename = "collapsed-by-client")]
        #[doc = "Represented as `\"collapsed-by-client\"`."]
        CollapsedByClient,
    }
    impl BlockedReason {
        pub const ENUM_VALUES: &'static [BlockedReason] = &[
            BlockedReason::Other,
            BlockedReason::Csp,
            BlockedReason::MixedContent,
            BlockedReason::Origin,
            BlockedReason::Inspector,
            BlockedReason::SubresourceFilter,
            BlockedReason::ContentType,
            BlockedReason::CollapsedByClient,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "other",
            "csp",
            "mixed-content",
            "origin",
            "inspector",
            "subresource-filter",
            "content-type",
            "collapsed-by-client",
        ];
    }
    impl ::std::str::FromStr for BlockedReason {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "other" => Ok(BlockedReason::Other),
                "csp" => Ok(BlockedReason::Csp),
                "mixed-content" => Ok(BlockedReason::MixedContent),
                "origin" => Ok(BlockedReason::Origin),
                "inspector" => Ok(BlockedReason::Inspector),
                "subresource-filter" => Ok(BlockedReason::SubresourceFilter),
                "content-type" => Ok(BlockedReason::ContentType),
                "collapsed-by-client" => Ok(BlockedReason::CollapsedByClient),
                _ => Err(::ParseEnumError {
                    expected: BlockedReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for BlockedReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    BlockedReason::Other => "other",
                    BlockedReason::Csp => "csp",
                    BlockedReason::MixedContent => "mixed-content",
                    BlockedReason::Origin => "origin",
                    BlockedReason::Inspector => "inspector",
                    BlockedReason::SubresourceFilter => "subresource-filter",
                    BlockedReason::ContentType => "content-type",
                    BlockedReason::CollapsedByClient => "collapsed-by-client",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "HTTP response data."]
    pub struct Response<'a> {
        #[serde(rename = "url")]
        #[doc = "Response URL. This URL can be different from CachedResource.url in case of redirect."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "status")]
        #[doc = "HTTP response status code."]
        pub status: i32,
        #[serde(rename = "statusText")]
        #[doc = "HTTP response status text."]
        pub status_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP response headers."]
        pub headers: ::network::Headers,
        #[serde(rename = "headersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response headers text."]
        pub headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "mimeType")]
        #[doc = "Resource mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "Refined HTTP request headers that were actually transmitted over the network."]
        pub request_headers: Option<::network::Headers>,
        #[serde(rename = "requestHeadersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers text."]
        pub request_headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "connectionReused")]
        #[doc = "Specifies whether physical connection was actually reused for this request."]
        pub connection_reused: bool,
        #[serde(rename = "connectionId")]
        #[doc = "Physical connection id that was actually used for this request."]
        pub connection_id: f64,
        #[serde(rename = "remoteIPAddress", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote IP address."]
        pub remote_ip_address: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "remotePort", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote port."]
        pub remote_port: Option<i32>,
        #[serde(rename = "fromDiskCache", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies that the request was served from the disk cache."]
        pub from_disk_cache: Option<bool>,
        #[serde(rename = "fromServiceWorker", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies that the request was served from the ServiceWorker."]
        pub from_service_worker: Option<bool>,
        #[serde(rename = "encodedDataLength")]
        #[doc = "Total number of bytes received for this request so far."]
        pub encoded_data_length: f64,
        #[serde(rename = "timing", skip_serializing_if = "Option::is_none")]
        #[doc = "Timing information for the given request."]
        pub timing: Option<::network::ResourceTiming>,
        #[serde(rename = "protocol", skip_serializing_if = "Option::is_none")]
        #[doc = "Protocol used to fetch this request."]
        pub protocol: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "securityState")]
        #[doc = "Security state of the request resource."]
        pub security_state: ::security::SecurityState,
        #[serde(rename = "securityDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Security details for the request."]
        pub security_details: Option<::network::SecurityDetails<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "WebSocket request data."]
    pub struct WebSocketRequest {
        #[serde(rename = "headers")]
        #[doc = "HTTP request headers."]
        pub headers: ::network::Headers,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "WebSocket response data."]
    pub struct WebSocketResponse<'a> {
        #[serde(rename = "status")]
        #[doc = "HTTP response status code."]
        pub status: i32,
        #[serde(rename = "statusText")]
        #[doc = "HTTP response status text."]
        pub status_text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "headers")]
        #[doc = "HTTP response headers."]
        pub headers: ::network::Headers,
        #[serde(rename = "headersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP response headers text."]
        pub headers_text: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "requestHeaders", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers."]
        pub request_headers: Option<::network::Headers>,
        #[serde(rename = "requestHeadersText", skip_serializing_if = "Option::is_none")]
        #[doc = "HTTP request headers text."]
        pub request_headers_text: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "WebSocket frame data."]
    pub struct WebSocketFrame<'a> {
        #[serde(rename = "opcode")]
        #[doc = "WebSocket frame opcode."]
        pub opcode: f64,
        #[serde(rename = "mask")]
        #[doc = "WebSocke frame mask."]
        pub mask: bool,
        #[serde(rename = "payloadData")]
        #[doc = "WebSocke frame payload data."]
        pub payload_data: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the cached resource."]
    pub struct CachedResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL. This is the url of the original network request."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Type of this resource."]
        pub ty: ::network::ResourceType,
        #[serde(rename = "response", skip_serializing_if = "Option::is_none")]
        #[doc = "Cached response data."]
        pub response: Option<::network::Response<'a>>,
        #[serde(rename = "bodySize")]
        #[doc = "Cached response body size."]
        pub body_size: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::network::Initiator::ty`](struct.Initiator.html#structfield.ty)."]
    pub enum InitiatorType {
        #[serde(rename = "parser")]
        #[doc = "Represented as `\"parser\"`."]
        Parser,
        #[serde(rename = "script")]
        #[doc = "Represented as `\"script\"`."]
        Script,
        #[serde(rename = "preload")]
        #[doc = "Represented as `\"preload\"`."]
        Preload,
        #[serde(rename = "SignedExchange")]
        #[doc = "Represented as `\"SignedExchange\"`."]
        SignedExchange,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl InitiatorType {
        pub const ENUM_VALUES: &'static [InitiatorType] = &[
            InitiatorType::Parser,
            InitiatorType::Script,
            InitiatorType::Preload,
            InitiatorType::SignedExchange,
            InitiatorType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["parser", "script", "preload", "SignedExchange", "other"];
    }
    impl ::std::str::FromStr for InitiatorType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "parser" => Ok(InitiatorType::Parser),
                "script" => Ok(InitiatorType::Script),
                "preload" => Ok(InitiatorType::Preload),
                "SignedExchange" => Ok(InitiatorType::SignedExchange),
                "other" => Ok(InitiatorType::Other),
                _ => Err(::ParseEnumError {
                    expected: InitiatorType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for InitiatorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    InitiatorType::Parser => "parser",
                    InitiatorType::Script => "script",
                    InitiatorType::Preload => "preload",
                    InitiatorType::SignedExchange => "SignedExchange",
                    InitiatorType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the request initiator."]
    pub struct Initiator<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of this initiator."]
        pub ty: ::network::InitiatorType,
        #[serde(rename = "stack", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator JavaScript stack trace, set for Script only."]
        pub stack: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator URL, set for Parser type or for Script type \\(when script is importing module\\) or for SignedExchange type."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "lineNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Initiator line number, set for Parser type or for Script type \\(when script is importing\nmodule\\) \\(0-based\\)."]
        pub line_number: Option<f64>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Cookie object"]
    pub struct Cookie<'a> {
        #[serde(rename = "name")]
        #[doc = "Cookie name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Cookie value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "domain")]
        #[doc = "Cookie domain."]
        pub domain: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "path")]
        #[doc = "Cookie path."]
        pub path: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "expires")]
        #[doc = "Cookie expiration date as the number of seconds since the UNIX epoch."]
        pub expires: f64,
        #[serde(rename = "size")]
        #[doc = "Cookie size."]
        pub size: i32,
        #[serde(rename = "httpOnly")]
        #[doc = "True if cookie is http-only."]
        pub http_only: bool,
        #[serde(rename = "secure")]
        #[doc = "True if cookie is secure."]
        pub secure: bool,
        #[serde(rename = "session")]
        #[doc = "True in case of session cookie."]
        pub session: bool,
        #[serde(rename = "sameSite", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie SameSite type."]
        pub same_site: Option<::network::CookieSameSite>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Cookie parameter object"]
    pub struct CookieParam<'a> {
        #[serde(rename = "name")]
        #[doc = "Cookie name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Cookie value."]
        pub value: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "The request-URI to associate with the setting of the cookie. This value can affect the\ndefault domain and path values of the created cookie."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "domain", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie domain."]
        pub domain: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "path", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie path."]
        pub path: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "secure", skip_serializing_if = "Option::is_none")]
        #[doc = "True if cookie is secure."]
        pub secure: Option<bool>,
        #[serde(rename = "httpOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "True if cookie is http-only."]
        pub http_only: Option<bool>,
        #[serde(rename = "sameSite", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie SameSite type."]
        pub same_site: Option<::network::CookieSameSite>,
        #[serde(rename = "expires", skip_serializing_if = "Option::is_none")]
        #[doc = "Cookie expiration date, session cookie if not set"]
        pub expires: Option<::network::TimeSinceEpoch>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::network::AuthChallenge::source`](struct.AuthChallenge.html#structfield.source)."]
    pub enum AuthChallengeSource {
        #[serde(rename = "Server")]
        #[doc = "Represented as `\"Server\"`."]
        Server,
        #[serde(rename = "Proxy")]
        #[doc = "Represented as `\"Proxy\"`."]
        Proxy,
    }
    impl AuthChallengeSource {
        pub const ENUM_VALUES: &'static [AuthChallengeSource] =
            &[AuthChallengeSource::Server, AuthChallengeSource::Proxy];
        pub const STR_VALUES: &'static [&'static str] = &["Server", "Proxy"];
    }
    impl ::std::str::FromStr for AuthChallengeSource {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Server" => Ok(AuthChallengeSource::Server),
                "Proxy" => Ok(AuthChallengeSource::Proxy),
                _ => Err(::ParseEnumError {
                    expected: AuthChallengeSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AuthChallengeSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AuthChallengeSource::Server => "Server",
                    AuthChallengeSource::Proxy => "Proxy",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Authorization challenge for HTTP status code 401 or 407."]
    pub struct AuthChallenge<'a> {
        #[serde(rename = "source", skip_serializing_if = "Option::is_none")]
        #[doc = "Source of the authentication challenge."]
        pub source: Option<::network::AuthChallengeSource>,
        #[serde(rename = "origin")]
        #[doc = "Origin of the challenger."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scheme")]
        #[doc = "The authentication scheme used, such as basic or digest"]
        pub scheme: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "realm")]
        #[doc = "The realm of the challenge. May be empty."]
        pub realm: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::network::AuthChallengeResponse::response`](struct.AuthChallengeResponse.html#structfield.response)."]
    pub enum AuthChallengeResponseResponse {
        #[serde(rename = "Default")]
        #[doc = "Represented as `\"Default\"`."]
        Default,
        #[serde(rename = "CancelAuth")]
        #[doc = "Represented as `\"CancelAuth\"`."]
        CancelAuth,
        #[serde(rename = "ProvideCredentials")]
        #[doc = "Represented as `\"ProvideCredentials\"`."]
        ProvideCredentials,
    }
    impl AuthChallengeResponseResponse {
        pub const ENUM_VALUES: &'static [AuthChallengeResponseResponse] =
            &[
                AuthChallengeResponseResponse::Default,
                AuthChallengeResponseResponse::CancelAuth,
                AuthChallengeResponseResponse::ProvideCredentials,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["Default", "CancelAuth", "ProvideCredentials"];
    }
    impl ::std::str::FromStr for AuthChallengeResponseResponse {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Default" => Ok(AuthChallengeResponseResponse::Default),
                "CancelAuth" => Ok(AuthChallengeResponseResponse::CancelAuth),
                "ProvideCredentials" => Ok(AuthChallengeResponseResponse::ProvideCredentials),
                _ => Err(::ParseEnumError {
                    expected: AuthChallengeResponseResponse::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for AuthChallengeResponseResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    AuthChallengeResponseResponse::Default => "Default",
                    AuthChallengeResponseResponse::CancelAuth => "CancelAuth",
                    AuthChallengeResponseResponse::ProvideCredentials => "ProvideCredentials",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Response to an AuthChallenge."]
    pub struct AuthChallengeResponse<'a> {
        #[serde(rename = "response")]
        #[doc = "The decision on what to do in response to the authorization challenge.  Default means\ndeferring to the default behavior of the net stack, which will likely either the Cancel\nauthentication or display a popup dialog box."]
        pub response: ::network::AuthChallengeResponseResponse,
        #[serde(rename = "username", skip_serializing_if = "Option::is_none")]
        #[doc = "The username to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
        pub username: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "password", skip_serializing_if = "Option::is_none")]
        #[doc = "The password to provide, possibly empty. Should only be set if response is\nProvideCredentials."]
        pub password: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stages of the interception to begin intercepting. Request will intercept before the request is\nsent. Response will intercept after the response is received."]
    pub enum InterceptionStage {
        #[serde(rename = "Request")]
        #[doc = "Represented as `\"Request\"`."]
        Request,
        #[serde(rename = "HeadersReceived")]
        #[doc = "Represented as `\"HeadersReceived\"`."]
        HeadersReceived,
    }
    impl InterceptionStage {
        pub const ENUM_VALUES: &'static [InterceptionStage] = &[
            InterceptionStage::Request,
            InterceptionStage::HeadersReceived,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["Request", "HeadersReceived"];
    }
    impl ::std::str::FromStr for InterceptionStage {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "Request" => Ok(InterceptionStage::Request),
                "HeadersReceived" => Ok(InterceptionStage::HeadersReceived),
                _ => Err(::ParseEnumError {
                    expected: InterceptionStage::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for InterceptionStage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    InterceptionStage::Request => "Request",
                    InterceptionStage::HeadersReceived => "HeadersReceived",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request pattern for interception."]
    pub struct RequestPattern<'a> {
        #[serde(rename = "urlPattern", skip_serializing_if = "Option::is_none")]
        #[doc = "Wildcards \\('\\*' -> zero or more, '?' -> exactly one\\) are allowed. Escape character is\nbackslash. Omitting is equivalent to \"\\*\"."]
        pub url_pattern: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "resourceType", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, only requests for matching resource types will be intercepted."]
        pub resource_type: Option<::network::ResourceType>,
        #[serde(rename = "interceptionStage", skip_serializing_if = "Option::is_none")]
        #[doc = "Stage at wich to begin intercepting requests. Default is Request."]
        pub interception_stage: Option<::network::InterceptionStage>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a signed exchange signature.\nhttps://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1"]
    pub struct SignedExchangeSignature<'a> {
        #[serde(rename = "label")]
        #[doc = "Signed exchange signature label."]
        pub label: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signature")]
        #[doc = "The hex string of signed exchange signature."]
        pub signature: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "integrity")]
        #[doc = "Signed exchange signature integrity."]
        pub integrity: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "certUrl", skip_serializing_if = "Option::is_none")]
        #[doc = "Signed exchange signature cert Url."]
        pub cert_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "certSha256", skip_serializing_if = "Option::is_none")]
        #[doc = "The hex string of signed exchange signature cert sha256."]
        pub cert_sha_256: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "validityUrl")]
        #[doc = "Signed exchange signature validity Url."]
        pub validity_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "date")]
        #[doc = "Signed exchange signature date."]
        pub date: i32,
        #[serde(rename = "expires")]
        #[doc = "Signed exchange signature expires."]
        pub expires: i32,
        #[serde(rename = "certificates", skip_serializing_if = "Option::is_none")]
        #[doc = "The encoded certificates."]
        pub certificates: Option<Vec<::std::borrow::Cow<'a, str>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a signed exchange header.\nhttps://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation"]
    pub struct SignedExchangeHeader<'a> {
        #[serde(rename = "requestUrl")]
        #[doc = "Signed exchange request URL."]
        pub request_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestMethod")]
        #[doc = "Signed exchange request method."]
        pub request_method: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "responseCode")]
        #[doc = "Signed exchange response code."]
        pub response_code: i32,
        #[serde(rename = "responseHeaders")]
        #[doc = "Signed exchange response headers."]
        pub response_headers: ::network::Headers,
        #[serde(rename = "signatures")]
        #[doc = "Signed exchange response signature."]
        pub signatures: Vec<::network::SignedExchangeSignature<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Field type for a signed exchange related error."]
    pub enum SignedExchangeErrorField {
        #[serde(rename = "signatureSig")]
        #[doc = "Represented as `\"signatureSig\"`."]
        SignatureSig,
        #[serde(rename = "signatureIntegrity")]
        #[doc = "Represented as `\"signatureIntegrity\"`."]
        SignatureIntegrity,
        #[serde(rename = "signatureCertUrl")]
        #[doc = "Represented as `\"signatureCertUrl\"`."]
        SignatureCertUrl,
        #[serde(rename = "signatureCertSha256")]
        #[doc = "Represented as `\"signatureCertSha256\"`."]
        SignatureCertSha256,
        #[serde(rename = "signatureValidityUrl")]
        #[doc = "Represented as `\"signatureValidityUrl\"`."]
        SignatureValidityUrl,
        #[serde(rename = "signatureTimestamps")]
        #[doc = "Represented as `\"signatureTimestamps\"`."]
        SignatureTimestamps,
    }
    impl SignedExchangeErrorField {
        pub const ENUM_VALUES: &'static [SignedExchangeErrorField] =
            &[
                SignedExchangeErrorField::SignatureSig,
                SignedExchangeErrorField::SignatureIntegrity,
                SignedExchangeErrorField::SignatureCertUrl,
                SignedExchangeErrorField::SignatureCertSha256,
                SignedExchangeErrorField::SignatureValidityUrl,
                SignedExchangeErrorField::SignatureTimestamps,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "signatureSig",
            "signatureIntegrity",
            "signatureCertUrl",
            "signatureCertSha256",
            "signatureValidityUrl",
            "signatureTimestamps",
        ];
    }
    impl ::std::str::FromStr for SignedExchangeErrorField {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "signatureSig" => Ok(SignedExchangeErrorField::SignatureSig),
                "signatureIntegrity" => Ok(SignedExchangeErrorField::SignatureIntegrity),
                "signatureCertUrl" => Ok(SignedExchangeErrorField::SignatureCertUrl),
                "signatureCertSha256" => Ok(SignedExchangeErrorField::SignatureCertSha256),
                "signatureValidityUrl" => Ok(SignedExchangeErrorField::SignatureValidityUrl),
                "signatureTimestamps" => Ok(SignedExchangeErrorField::SignatureTimestamps),
                _ => Err(::ParseEnumError {
                    expected: SignedExchangeErrorField::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SignedExchangeErrorField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SignedExchangeErrorField::SignatureSig => "signatureSig",
                    SignedExchangeErrorField::SignatureIntegrity => "signatureIntegrity",
                    SignedExchangeErrorField::SignatureCertUrl => "signatureCertUrl",
                    SignedExchangeErrorField::SignatureCertSha256 => "signatureCertSha256",
                    SignedExchangeErrorField::SignatureValidityUrl => "signatureValidityUrl",
                    SignedExchangeErrorField::SignatureTimestamps => "signatureTimestamps",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a signed exchange response."]
    pub struct SignedExchangeError<'a> {
        #[serde(rename = "message")]
        #[doc = "Error message."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "signatureIndex", skip_serializing_if = "Option::is_none")]
        #[doc = "The index of the signature which caused the error."]
        pub signature_index: Option<i32>,
        #[serde(rename = "errorField", skip_serializing_if = "Option::is_none")]
        #[doc = "The field which caused the error."]
        pub error_field: Option<::network::SignedExchangeErrorField>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about a signed exchange response."]
    pub struct SignedExchangeInfo<'a> {
        #[serde(rename = "outerResponse")]
        #[doc = "The outer response of signed HTTP exchange which was received from network."]
        pub outer_response: ::network::Response<'a>,
        #[serde(rename = "header", skip_serializing_if = "Option::is_none")]
        #[doc = "Information about the signed exchange header."]
        pub header: Option<::network::SignedExchangeHeader<'a>>,
        #[serde(rename = "securityDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Security details for the signed exchange header."]
        pub security_details: Option<::network::SecurityDetails<'a>>,
        #[serde(rename = "errors", skip_serializing_if = "Option::is_none")]
        #[doc = "Errors occurred while handling the signed exchagne."]
        pub errors: Option<Vec<::network::SignedExchangeError<'a>>>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> This domain provides various functionality related to drawing atop the inspected page.\n\n# Overlay\n\n## Commands\n\n- [`Overlay.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disables domain notifications.\n- [`Overlay.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables domain notifications.\n- [`Overlay.getHighlightObjectForTest`](struct.GetHighlightObjectForTestCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  For testing.\n- [`Overlay.hideHighlight`](struct.HideHighlightCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Hides any highlight.\n- [`Overlay.highlightFrame`](struct.HighlightFrameCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights owner element of the frame with given id.\n- [`Overlay.highlightNode`](struct.HighlightNodeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or\n  objectId must be specified.\n- [`Overlay.highlightQuad`](struct.HighlightQuadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n- [`Overlay.highlightRect`](struct.HighlightRectCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n- [`Overlay.setInspectMode`](struct.SetInspectModeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.\n  Backend then generates 'inspectNodeRequested' event upon element selection.\n- [`Overlay.setPausedInDebuggerMessage`](struct.SetPausedInDebuggerMessageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Overlay.setShowDebugBorders`](struct.SetShowDebugBordersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows debug borders on layers\n- [`Overlay.setShowFPSCounter`](struct.SetShowFpsCounterCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows the FPS counter\n- [`Overlay.setShowPaintRects`](struct.SetShowPaintRectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows paint rectangles\n- [`Overlay.setShowScrollBottleneckRects`](struct.SetShowScrollBottleneckRectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Requests that backend shows scroll bottleneck rects\n- [`Overlay.setShowViewportSizeOnResize`](struct.SetShowViewportSizeOnResizeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Paints viewport size upon main frame resize.\n- [`Overlay.setSuspended`](struct.SetSuspendedCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`Overlay.inspectNodeRequested`](struct.InspectNodeRequestedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the node should be inspected. This happens after call to `setInspectMode` or when\n  user manually inspects an element.\n- [`Overlay.nodeHighlightRequested`](struct.NodeHighlightRequestedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the node should be highlighted. This happens after call to `setInspectMode`.\n- [`Overlay.screenshotRequested`](struct.ScreenshotRequestedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when user asks to capture screenshot of some area on the page.\n\n##Types\n\n- [`HighlightConfig`](struct.HighlightConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Configuration data for the highlighting of page elements.\n- [`InspectMode`](enum.InspectMode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod overlay {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables domain notifications.\n\n# Command `Overlay.disable`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::overlay::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Overlay.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Overlay.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disables domain notifications.\n\n# Command `Overlay.disable`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::overlay::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Overlay.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables domain notifications.\n\n# Command `Overlay.enable`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::overlay::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Overlay.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Overlay.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables domain notifications.\n\n# Command `Overlay.enable`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::overlay::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Overlay.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Overlay.getHighlightObjectForTest`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::GetHighlightObjectForTestCommand`](struct.GetHighlightObjectForTestCommand.html)  \n*Response Struct:* [`cdp::overlay::GetHighlightObjectForTestResponse`](struct.GetHighlightObjectForTestResponse.html)"]
    pub struct GetHighlightObjectForTestCommand {
        #[serde(rename = "nodeId")]
        #[doc = "Id of the node to get highlight object for."]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpCommand for GetHighlightObjectForTestCommand {
        const COMMAND_NAME: &'static str = "Overlay.getHighlightObjectForTest";
    }
    impl ::SerializeCdpCommand for GetHighlightObjectForTestCommand {
        fn command_name(&self) -> &str {
            "Overlay.getHighlightObjectForTest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetHighlightObjectForTestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.getHighlightObjectForTest" {
                Ok ( < GetHighlightObjectForTestCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> For testing.\n\n# Command `Overlay.getHighlightObjectForTest`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::GetHighlightObjectForTestCommand`](struct.GetHighlightObjectForTestCommand.html)  \n*Response Struct:* [`cdp::overlay::GetHighlightObjectForTestResponse`](struct.GetHighlightObjectForTestResponse.html)"]
    pub struct GetHighlightObjectForTestResponse {
        #[serde(rename = "highlight")]
        #[doc = "Highlight data for the node."]
        pub highlight: ::Empty,
    }
    impl ::CdpCommand for GetHighlightObjectForTestResponse {
        const COMMAND_NAME: &'static str = "Overlay.getHighlightObjectForTest";
    }
    impl<'b> ::HasCdpResponse<'b> for GetHighlightObjectForTestCommand {
        type Response = GetHighlightObjectForTestResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetHighlightObjectForTestResponse {
        type Command = GetHighlightObjectForTestCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Hides any highlight.\n\n# Command `Overlay.hideHighlight`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::overlay::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightCommand;
    impl ::serde::Serialize for HideHighlightCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightCommand)
        }
    }
    impl ::CdpCommand for HideHighlightCommand {
        const COMMAND_NAME: &'static str = "Overlay.hideHighlight";
    }
    impl ::SerializeCdpCommand for HideHighlightCommand {
        fn command_name(&self) -> &str {
            "Overlay.hideHighlight"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HideHighlightCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.hideHighlight" {
                Ok(
                    <HideHighlightCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Hides any highlight.\n\n# Command `Overlay.hideHighlight`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HideHighlightCommand`](struct.HideHighlightCommand.html)  \n*Response Struct:* [`cdp::overlay::HideHighlightResponse`](struct.HideHighlightResponse.html)"]
    pub struct HideHighlightResponse;
    impl ::serde::Serialize for HideHighlightResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HideHighlightResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HideHighlightResponse)
        }
    }
    impl ::CdpCommand for HideHighlightResponse {
        const COMMAND_NAME: &'static str = "Overlay.hideHighlight";
    }
    impl<'b> ::HasCdpResponse<'b> for HideHighlightCommand {
        type Response = HideHighlightResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HideHighlightResponse {
        type Command = HideHighlightCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights owner element of the frame with given id.\n\n# Command `Overlay.highlightFrame`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightFrameCommand`](struct.HighlightFrameCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightFrameResponse`](struct.HighlightFrameResponse.html)"]
    pub struct HighlightFrameCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Identifier of the frame to highlight."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "contentColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight fill color \\(default: transparent\\)."]
        pub content_color: Option<::dom::Rgba>,
        #[serde(rename = "contentOutlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight outline color \\(default: transparent\\)."]
        pub content_outline_color: Option<::dom::Rgba>,
    }
    impl<'a> ::CdpCommand for HighlightFrameCommand<'a> {
        const COMMAND_NAME: &'static str = "Overlay.highlightFrame";
    }
    impl<'a> ::SerializeCdpCommand for HighlightFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.highlightFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for HighlightFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightFrame" {
                Ok(
                    <HighlightFrameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights owner element of the frame with given id.\n\n# Command `Overlay.highlightFrame`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightFrameCommand`](struct.HighlightFrameCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightFrameResponse`](struct.HighlightFrameResponse.html)"]
    pub struct HighlightFrameResponse;
    impl ::serde::Serialize for HighlightFrameResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightFrameResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightFrameResponse)
        }
    }
    impl ::CdpCommand for HighlightFrameResponse {
        const COMMAND_NAME: &'static str = "Overlay.highlightFrame";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for HighlightFrameCommand<'a> {
        type Response = HighlightFrameResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightFrameResponse {
        type Command = HighlightFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or\nobjectId must be specified.\n\n# Command `Overlay.highlightNode`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeCommand<'a> {
        #[serde(rename = "highlightConfig")]
        #[doc = "A descriptor for the highlight appearance."]
        pub highlight_config: ::overlay::HighlightConfig<'a>,
        #[serde(rename = "nodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the node to highlight."]
        pub node_id: Option<::dom::NodeId>,
        #[serde(rename = "backendNodeId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the backend node to highlight."]
        pub backend_node_id: Option<::dom::BackendNodeId>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript object id of the node to be highlighted."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    impl<'a> ::CdpCommand for HighlightNodeCommand<'a> {
        const COMMAND_NAME: &'static str = "Overlay.highlightNode";
    }
    impl<'a> ::SerializeCdpCommand for HighlightNodeCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.highlightNode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for HighlightNodeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightNode" {
                Ok(
                    <HighlightNodeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or\nobjectId must be specified.\n\n# Command `Overlay.highlightNode`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightNodeCommand`](struct.HighlightNodeCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightNodeResponse`](struct.HighlightNodeResponse.html)"]
    pub struct HighlightNodeResponse;
    impl ::serde::Serialize for HighlightNodeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightNodeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightNodeResponse)
        }
    }
    impl ::CdpCommand for HighlightNodeResponse {
        const COMMAND_NAME: &'static str = "Overlay.highlightNode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for HighlightNodeCommand<'a> {
        type Response = HighlightNodeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightNodeResponse {
        type Command = HighlightNodeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightQuad`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightQuadCommand`](struct.HighlightQuadCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightQuadResponse`](struct.HighlightQuadResponse.html)"]
    pub struct HighlightQuadCommand {
        #[serde(rename = "quad")]
        #[doc = "Quad to highlight"]
        pub quad: ::dom::Quad,
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight fill color \\(default: transparent\\)."]
        pub color: Option<::dom::Rgba>,
        #[serde(rename = "outlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight outline color \\(default: transparent\\)."]
        pub outline_color: Option<::dom::Rgba>,
    }
    impl ::CdpCommand for HighlightQuadCommand {
        const COMMAND_NAME: &'static str = "Overlay.highlightQuad";
    }
    impl ::SerializeCdpCommand for HighlightQuadCommand {
        fn command_name(&self) -> &str {
            "Overlay.highlightQuad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HighlightQuadCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightQuad" {
                Ok(
                    <HighlightQuadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given quad. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightQuad`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightQuadCommand`](struct.HighlightQuadCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightQuadResponse`](struct.HighlightQuadResponse.html)"]
    pub struct HighlightQuadResponse;
    impl ::serde::Serialize for HighlightQuadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightQuadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightQuadResponse)
        }
    }
    impl ::CdpCommand for HighlightQuadResponse {
        const COMMAND_NAME: &'static str = "Overlay.highlightQuad";
    }
    impl<'b> ::HasCdpResponse<'b> for HighlightQuadCommand {
        type Response = HighlightQuadResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightQuadResponse {
        type Command = HighlightQuadCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightRect`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectCommand {
        #[serde(rename = "x")]
        #[doc = "X coordinate"]
        pub x: i32,
        #[serde(rename = "y")]
        #[doc = "Y coordinate"]
        pub y: i32,
        #[serde(rename = "width")]
        #[doc = "Rectangle width"]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Rectangle height"]
        pub height: i32,
        #[serde(rename = "color", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight fill color \\(default: transparent\\)."]
        pub color: Option<::dom::Rgba>,
        #[serde(rename = "outlineColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The highlight outline color \\(default: transparent\\)."]
        pub outline_color: Option<::dom::Rgba>,
    }
    impl ::CdpCommand for HighlightRectCommand {
        const COMMAND_NAME: &'static str = "Overlay.highlightRect";
    }
    impl ::SerializeCdpCommand for HighlightRectCommand {
        fn command_name(&self) -> &str {
            "Overlay.highlightRect"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HighlightRectCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.highlightRect" {
                Ok(
                    <HighlightRectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.\n\n# Command `Overlay.highlightRect`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::HighlightRectCommand`](struct.HighlightRectCommand.html)  \n*Response Struct:* [`cdp::overlay::HighlightRectResponse`](struct.HighlightRectResponse.html)"]
    pub struct HighlightRectResponse;
    impl ::serde::Serialize for HighlightRectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HighlightRectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HighlightRectResponse)
        }
    }
    impl ::CdpCommand for HighlightRectResponse {
        const COMMAND_NAME: &'static str = "Overlay.highlightRect";
    }
    impl<'b> ::HasCdpResponse<'b> for HighlightRectCommand {
        type Response = HighlightRectResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HighlightRectResponse {
        type Command = HighlightRectCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.\nBackend then generates 'inspectNodeRequested' event upon element selection.\n\n# Command `Overlay.setInspectMode`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetInspectModeCommand`](struct.SetInspectModeCommand.html)  \n*Response Struct:* [`cdp::overlay::SetInspectModeResponse`](struct.SetInspectModeResponse.html)"]
    pub struct SetInspectModeCommand<'a> {
        #[serde(rename = "mode")]
        #[doc = "Set an inspection mode."]
        pub mode: ::overlay::InspectMode,
        #[serde(rename = "highlightConfig", skip_serializing_if = "Option::is_none")]
        #[doc = "A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled\n== false`."]
        pub highlight_config: Option<::overlay::HighlightConfig<'a>>,
    }
    impl<'a> ::CdpCommand for SetInspectModeCommand<'a> {
        const COMMAND_NAME: &'static str = "Overlay.setInspectMode";
    }
    impl<'a> ::SerializeCdpCommand for SetInspectModeCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.setInspectMode"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetInspectModeCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setInspectMode" {
                Ok(
                    <SetInspectModeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.\nBackend then generates 'inspectNodeRequested' event upon element selection.\n\n# Command `Overlay.setInspectMode`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetInspectModeCommand`](struct.SetInspectModeCommand.html)  \n*Response Struct:* [`cdp::overlay::SetInspectModeResponse`](struct.SetInspectModeResponse.html)"]
    pub struct SetInspectModeResponse;
    impl ::serde::Serialize for SetInspectModeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetInspectModeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetInspectModeResponse)
        }
    }
    impl ::CdpCommand for SetInspectModeResponse {
        const COMMAND_NAME: &'static str = "Overlay.setInspectMode";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetInspectModeCommand<'a> {
        type Response = SetInspectModeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetInspectModeResponse {
        type Command = SetInspectModeCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setPausedInDebuggerMessage`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetPausedInDebuggerMessageCommand`](struct.SetPausedInDebuggerMessageCommand.html)  \n*Response Struct:* [`cdp::overlay::SetPausedInDebuggerMessageResponse`](struct.SetPausedInDebuggerMessageResponse.html)"]
    pub struct SetPausedInDebuggerMessageCommand<'a> {
        #[serde(rename = "message", skip_serializing_if = "Option::is_none")]
        #[doc = "The message to display, also triggers resume and step over controls."]
        pub message: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetPausedInDebuggerMessageCommand<'a> {
        const COMMAND_NAME: &'static str = "Overlay.setPausedInDebuggerMessage";
    }
    impl<'a> ::SerializeCdpCommand for SetPausedInDebuggerMessageCommand<'a> {
        fn command_name(&self) -> &str {
            "Overlay.setPausedInDebuggerMessage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetPausedInDebuggerMessageCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setPausedInDebuggerMessage" {
                Ok ( < SetPausedInDebuggerMessageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setPausedInDebuggerMessage`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetPausedInDebuggerMessageCommand`](struct.SetPausedInDebuggerMessageCommand.html)  \n*Response Struct:* [`cdp::overlay::SetPausedInDebuggerMessageResponse`](struct.SetPausedInDebuggerMessageResponse.html)"]
    pub struct SetPausedInDebuggerMessageResponse;
    impl ::serde::Serialize for SetPausedInDebuggerMessageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPausedInDebuggerMessageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPausedInDebuggerMessageResponse)
        }
    }
    impl ::CdpCommand for SetPausedInDebuggerMessageResponse {
        const COMMAND_NAME: &'static str = "Overlay.setPausedInDebuggerMessage";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetPausedInDebuggerMessageCommand<'a> {
        type Response = SetPausedInDebuggerMessageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPausedInDebuggerMessageResponse {
        type Command = SetPausedInDebuggerMessageCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows debug borders on layers\n\n# Command `Overlay.setShowDebugBorders`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowDebugBordersCommand`](struct.SetShowDebugBordersCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowDebugBordersResponse`](struct.SetShowDebugBordersResponse.html)"]
    pub struct SetShowDebugBordersCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing debug borders"]
        pub show: bool,
    }
    impl ::CdpCommand for SetShowDebugBordersCommand {
        const COMMAND_NAME: &'static str = "Overlay.setShowDebugBorders";
    }
    impl ::SerializeCdpCommand for SetShowDebugBordersCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowDebugBorders"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetShowDebugBordersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowDebugBorders" {
                Ok ( < SetShowDebugBordersCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows debug borders on layers\n\n# Command `Overlay.setShowDebugBorders`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowDebugBordersCommand`](struct.SetShowDebugBordersCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowDebugBordersResponse`](struct.SetShowDebugBordersResponse.html)"]
    pub struct SetShowDebugBordersResponse;
    impl ::serde::Serialize for SetShowDebugBordersResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowDebugBordersResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowDebugBordersResponse)
        }
    }
    impl ::CdpCommand for SetShowDebugBordersResponse {
        const COMMAND_NAME: &'static str = "Overlay.setShowDebugBorders";
    }
    impl<'b> ::HasCdpResponse<'b> for SetShowDebugBordersCommand {
        type Response = SetShowDebugBordersResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetShowDebugBordersResponse {
        type Command = SetShowDebugBordersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows the FPS counter\n\n# Command `Overlay.setShowFPSCounter`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowFpsCounterCommand`](struct.SetShowFpsCounterCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowFpsCounterResponse`](struct.SetShowFpsCounterResponse.html)"]
    pub struct SetShowFpsCounterCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing the FPS counter"]
        pub show: bool,
    }
    impl ::CdpCommand for SetShowFpsCounterCommand {
        const COMMAND_NAME: &'static str = "Overlay.setShowFPSCounter";
    }
    impl ::SerializeCdpCommand for SetShowFpsCounterCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowFPSCounter"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetShowFpsCounterCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowFPSCounter" {
                Ok ( < SetShowFpsCounterCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows the FPS counter\n\n# Command `Overlay.setShowFPSCounter`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowFpsCounterCommand`](struct.SetShowFpsCounterCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowFpsCounterResponse`](struct.SetShowFpsCounterResponse.html)"]
    pub struct SetShowFpsCounterResponse;
    impl ::serde::Serialize for SetShowFpsCounterResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowFpsCounterResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowFpsCounterResponse)
        }
    }
    impl ::CdpCommand for SetShowFpsCounterResponse {
        const COMMAND_NAME: &'static str = "Overlay.setShowFPSCounter";
    }
    impl<'b> ::HasCdpResponse<'b> for SetShowFpsCounterCommand {
        type Response = SetShowFpsCounterResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetShowFpsCounterResponse {
        type Command = SetShowFpsCounterCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows paint rectangles\n\n# Command `Overlay.setShowPaintRects`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowPaintRectsCommand`](struct.SetShowPaintRectsCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowPaintRectsResponse`](struct.SetShowPaintRectsResponse.html)"]
    pub struct SetShowPaintRectsCommand {
        #[serde(rename = "result")]
        #[doc = "True for showing paint rectangles"]
        pub result: bool,
    }
    impl ::CdpCommand for SetShowPaintRectsCommand {
        const COMMAND_NAME: &'static str = "Overlay.setShowPaintRects";
    }
    impl ::SerializeCdpCommand for SetShowPaintRectsCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowPaintRects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetShowPaintRectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowPaintRects" {
                Ok ( < SetShowPaintRectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows paint rectangles\n\n# Command `Overlay.setShowPaintRects`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowPaintRectsCommand`](struct.SetShowPaintRectsCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowPaintRectsResponse`](struct.SetShowPaintRectsResponse.html)"]
    pub struct SetShowPaintRectsResponse;
    impl ::serde::Serialize for SetShowPaintRectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowPaintRectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowPaintRectsResponse)
        }
    }
    impl ::CdpCommand for SetShowPaintRectsResponse {
        const COMMAND_NAME: &'static str = "Overlay.setShowPaintRects";
    }
    impl<'b> ::HasCdpResponse<'b> for SetShowPaintRectsCommand {
        type Response = SetShowPaintRectsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetShowPaintRectsResponse {
        type Command = SetShowPaintRectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows scroll bottleneck rects\n\n# Command `Overlay.setShowScrollBottleneckRects`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowScrollBottleneckRectsCommand`](struct.SetShowScrollBottleneckRectsCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowScrollBottleneckRectsResponse`](struct.SetShowScrollBottleneckRectsResponse.html)"]
    pub struct SetShowScrollBottleneckRectsCommand {
        #[serde(rename = "show")]
        #[doc = "True for showing scroll bottleneck rects"]
        pub show: bool,
    }
    impl ::CdpCommand for SetShowScrollBottleneckRectsCommand {
        const COMMAND_NAME: &'static str = "Overlay.setShowScrollBottleneckRects";
    }
    impl ::SerializeCdpCommand for SetShowScrollBottleneckRectsCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowScrollBottleneckRects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetShowScrollBottleneckRectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowScrollBottleneckRects" {
                Ok ( < SetShowScrollBottleneckRectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Requests that backend shows scroll bottleneck rects\n\n# Command `Overlay.setShowScrollBottleneckRects`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowScrollBottleneckRectsCommand`](struct.SetShowScrollBottleneckRectsCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowScrollBottleneckRectsResponse`](struct.SetShowScrollBottleneckRectsResponse.html)"]
    pub struct SetShowScrollBottleneckRectsResponse;
    impl ::serde::Serialize for SetShowScrollBottleneckRectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowScrollBottleneckRectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowScrollBottleneckRectsResponse)
        }
    }
    impl ::CdpCommand for SetShowScrollBottleneckRectsResponse {
        const COMMAND_NAME: &'static str = "Overlay.setShowScrollBottleneckRects";
    }
    impl<'b> ::HasCdpResponse<'b> for SetShowScrollBottleneckRectsCommand {
        type Response = SetShowScrollBottleneckRectsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetShowScrollBottleneckRectsResponse {
        type Command = SetShowScrollBottleneckRectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Paints viewport size upon main frame resize.\n\n# Command `Overlay.setShowViewportSizeOnResize`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowViewportSizeOnResizeCommand`](struct.SetShowViewportSizeOnResizeCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowViewportSizeOnResizeResponse`](struct.SetShowViewportSizeOnResizeResponse.html)"]
    pub struct SetShowViewportSizeOnResizeCommand {
        #[serde(rename = "show")]
        #[doc = "Whether to paint size or not."]
        pub show: bool,
    }
    impl ::CdpCommand for SetShowViewportSizeOnResizeCommand {
        const COMMAND_NAME: &'static str = "Overlay.setShowViewportSizeOnResize";
    }
    impl ::SerializeCdpCommand for SetShowViewportSizeOnResizeCommand {
        fn command_name(&self) -> &str {
            "Overlay.setShowViewportSizeOnResize"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetShowViewportSizeOnResizeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setShowViewportSizeOnResize" {
                Ok ( < SetShowViewportSizeOnResizeCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Paints viewport size upon main frame resize.\n\n# Command `Overlay.setShowViewportSizeOnResize`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetShowViewportSizeOnResizeCommand`](struct.SetShowViewportSizeOnResizeCommand.html)  \n*Response Struct:* [`cdp::overlay::SetShowViewportSizeOnResizeResponse`](struct.SetShowViewportSizeOnResizeResponse.html)"]
    pub struct SetShowViewportSizeOnResizeResponse;
    impl ::serde::Serialize for SetShowViewportSizeOnResizeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetShowViewportSizeOnResizeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetShowViewportSizeOnResizeResponse)
        }
    }
    impl ::CdpCommand for SetShowViewportSizeOnResizeResponse {
        const COMMAND_NAME: &'static str = "Overlay.setShowViewportSizeOnResize";
    }
    impl<'b> ::HasCdpResponse<'b> for SetShowViewportSizeOnResizeCommand {
        type Response = SetShowViewportSizeOnResizeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetShowViewportSizeOnResizeResponse {
        type Command = SetShowViewportSizeOnResizeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setSuspended`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetSuspendedCommand`](struct.SetSuspendedCommand.html)  \n*Response Struct:* [`cdp::overlay::SetSuspendedResponse`](struct.SetSuspendedResponse.html)"]
    pub struct SetSuspendedCommand {
        #[serde(rename = "suspended")]
        #[doc = "Whether overlay should be suspended and not consume any resources until resumed."]
        pub suspended: bool,
    }
    impl ::CdpCommand for SetSuspendedCommand {
        const COMMAND_NAME: &'static str = "Overlay.setSuspended";
    }
    impl ::SerializeCdpCommand for SetSuspendedCommand {
        fn command_name(&self) -> &str {
            "Overlay.setSuspended"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetSuspendedCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.setSuspended" {
                Ok(
                    <SetSuspendedCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Overlay.setSuspended`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Command Struct:* [`cdp::overlay::SetSuspendedCommand`](struct.SetSuspendedCommand.html)  \n*Response Struct:* [`cdp::overlay::SetSuspendedResponse`](struct.SetSuspendedResponse.html)"]
    pub struct SetSuspendedResponse;
    impl ::serde::Serialize for SetSuspendedResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSuspendedResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSuspendedResponse)
        }
    }
    impl ::CdpCommand for SetSuspendedResponse {
        const COMMAND_NAME: &'static str = "Overlay.setSuspended";
    }
    impl<'b> ::HasCdpResponse<'b> for SetSuspendedCommand {
        type Response = SetSuspendedResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetSuspendedResponse {
        type Command = SetSuspendedCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the node should be inspected. This happens after call to `setInspectMode` or when\nuser manually inspects an element.\n\n# Event `Overlay.inspectNodeRequested`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Event Struct:* [`cdp::overlay::InspectNodeRequestedEvent`](struct.InspectNodeRequestedEvent.html)"]
    pub struct InspectNodeRequestedEvent {
        #[serde(rename = "backendNodeId")]
        #[doc = "Id of the node to inspect."]
        pub backend_node_id: ::dom::BackendNodeId,
    }
    impl ::CdpEvent for InspectNodeRequestedEvent {
        const EVENT_NAME: &'static str = "Overlay.inspectNodeRequested";
    }
    impl ::SerializeCdpEvent for InspectNodeRequestedEvent {
        fn event_name(&self) -> &str {
            "Overlay.inspectNodeRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for InspectNodeRequestedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.inspectNodeRequested" {
                Ok ( < InspectNodeRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the node should be highlighted. This happens after call to `setInspectMode`.\n\n# Event `Overlay.nodeHighlightRequested`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Event Struct:* [`cdp::overlay::NodeHighlightRequestedEvent`](struct.NodeHighlightRequestedEvent.html)"]
    pub struct NodeHighlightRequestedEvent {
        #[serde(rename = "nodeId")]
        pub node_id: ::dom::NodeId,
    }
    impl ::CdpEvent for NodeHighlightRequestedEvent {
        const EVENT_NAME: &'static str = "Overlay.nodeHighlightRequested";
    }
    impl ::SerializeCdpEvent for NodeHighlightRequestedEvent {
        fn event_name(&self) -> &str {
            "Overlay.nodeHighlightRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for NodeHighlightRequestedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.nodeHighlightRequested" {
                Ok ( < NodeHighlightRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when user asks to capture screenshot of some area on the page.\n\n# Event `Overlay.screenshotRequested`\n\n*Domain Module:* [`cdp::overlay`](index.html)  \n*Event Struct:* [`cdp::overlay::ScreenshotRequestedEvent`](struct.ScreenshotRequestedEvent.html)"]
    pub struct ScreenshotRequestedEvent {
        #[serde(rename = "viewport")]
        #[doc = "Viewport to capture, in CSS."]
        pub viewport: ::page::Viewport,
    }
    impl ::CdpEvent for ScreenshotRequestedEvent {
        const EVENT_NAME: &'static str = "Overlay.screenshotRequested";
    }
    impl ::SerializeCdpEvent for ScreenshotRequestedEvent {
        fn event_name(&self) -> &str {
            "Overlay.screenshotRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ScreenshotRequestedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Overlay.screenshotRequested" {
                Ok ( < ScreenshotRequestedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Configuration data for the highlighting of page elements."]
    pub struct HighlightConfig<'a> {
        #[serde(rename = "showInfo", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the node info tooltip should be shown \\(default: false\\)."]
        pub show_info: Option<bool>,
        #[serde(rename = "showRulers", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the rulers should be shown \\(default: false\\)."]
        pub show_rulers: Option<bool>,
        #[serde(rename = "showExtensionLines", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the extension lines from node to the rulers should be shown \\(default: false\\)."]
        pub show_extension_lines: Option<bool>,
        #[serde(rename = "displayAsMaterial", skip_serializing_if = "Option::is_none")]
        pub display_as_material: Option<bool>,
        #[serde(rename = "contentColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The content box highlight fill color \\(default: transparent\\)."]
        pub content_color: Option<::dom::Rgba>,
        #[serde(rename = "paddingColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The padding highlight fill color \\(default: transparent\\)."]
        pub padding_color: Option<::dom::Rgba>,
        #[serde(rename = "borderColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The border highlight fill color \\(default: transparent\\)."]
        pub border_color: Option<::dom::Rgba>,
        #[serde(rename = "marginColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The margin highlight fill color \\(default: transparent\\)."]
        pub margin_color: Option<::dom::Rgba>,
        #[serde(rename = "eventTargetColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The event target element highlight fill color \\(default: transparent\\)."]
        pub event_target_color: Option<::dom::Rgba>,
        #[serde(rename = "shapeColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The shape outside fill color \\(default: transparent\\)."]
        pub shape_color: Option<::dom::Rgba>,
        #[serde(rename = "shapeMarginColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The shape margin fill color \\(default: transparent\\)."]
        pub shape_margin_color: Option<::dom::Rgba>,
        #[serde(rename = "selectorList", skip_serializing_if = "Option::is_none")]
        #[doc = "Selectors to highlight relevant nodes."]
        pub selector_list: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "cssGridColor", skip_serializing_if = "Option::is_none")]
        #[doc = "The grid layout color \\(default: transparent\\)."]
        pub css_grid_color: Option<::dom::Rgba>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum InspectMode {
        #[serde(rename = "searchForNode")]
        #[doc = "Represented as `\"searchForNode\"`."]
        SearchForNode,
        #[serde(rename = "searchForUAShadowDOM")]
        #[doc = "Represented as `\"searchForUAShadowDOM\"`."]
        SearchForUaShadowDom,
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
    }
    impl InspectMode {
        pub const ENUM_VALUES: &'static [InspectMode] = &[
            InspectMode::SearchForNode,
            InspectMode::SearchForUaShadowDom,
            InspectMode::None,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["searchForNode", "searchForUAShadowDOM", "none"];
    }
    impl ::std::str::FromStr for InspectMode {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "searchForNode" => Ok(InspectMode::SearchForNode),
                "searchForUAShadowDOM" => Ok(InspectMode::SearchForUaShadowDom),
                "none" => Ok(InspectMode::None),
                _ => Err(::ParseEnumError {
                    expected: InspectMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for InspectMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    InspectMode::SearchForNode => "searchForNode",
                    InspectMode::SearchForUaShadowDom => "searchForUAShadowDOM",
                    InspectMode::None => "none",
                }
            )
        }
    }
}
#[doc = "Actions and events related to the inspected page belong to the page domain.\n\n# Page\n\n## Commands\n\n- [`Page.addScriptToEvaluateOnLoad`](struct.AddScriptToEvaluateOnLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n  \n  <span class=\"stab deprecated\">please use addScriptToEvaluateOnNewDocument instead.</span>\n- [`Page.addScriptToEvaluateOnNewDocument`](struct.AddScriptToEvaluateOnNewDocumentCommand.html)\n\n  Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n- [`Page.bringToFront`](struct.BringToFrontCommand.html)\n\n  Brings page to front \\(activates tab\\).\n- [`Page.captureScreenshot`](struct.CaptureScreenshotCommand.html)\n\n  Capture page screenshot.\n- [`Page.clearDeviceMetricsOverride`](struct.ClearDeviceMetricsOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Clears the overriden device metrics.\n- [`Page.clearDeviceOrientationOverride`](struct.ClearDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Clears the overridden Device Orientation.\n- [`Page.clearGeolocationOverride`](struct.ClearGeolocationOverrideCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Clears the overriden Geolocation Position and Error.\n- [`Page.createIsolatedWorld`](struct.CreateIsolatedWorldCommand.html)\n\n  Creates an isolated world for the given frame.\n- [`Page.deleteCookie`](struct.DeleteCookieCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Deletes browser cookie with given name, domain and path.\n- [`Page.disable`](struct.DisableCommand.html)\n\n  Disables page domain notifications.\n- [`Page.enable`](struct.EnableCommand.html)\n\n  Enables page domain notifications.\n- [`Page.getAppManifest`](struct.GetAppManifestCommand.html)\n- [`Page.getCookies`](struct.GetCookiesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Returns all browser cookies. Depending on the backend support, will return detailed cookie\n  information in the `cookies` field.\n- [`Page.getFrameTree`](struct.GetFrameTreeCommand.html)\n\n  Returns present frame tree structure.\n- [`Page.getLayoutMetrics`](struct.GetLayoutMetricsCommand.html)\n\n  Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n- [`Page.getNavigationHistory`](struct.GetNavigationHistoryCommand.html)\n\n  Returns navigation history for the current page.\n- [`Page.getResourceContent`](struct.GetResourceContentCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns content of the given resource.\n- [`Page.getResourceTree`](struct.GetResourceTreeCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns present frame / resource tree structure.\n- [`Page.handleJavaScriptDialog`](struct.HandleJavaScriptDialogCommand.html)\n\n  Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n- [`Page.navigate`](struct.NavigateCommand.html)\n\n  Navigates current page to the given URL.\n- [`Page.navigateToHistoryEntry`](struct.NavigateToHistoryEntryCommand.html)\n\n  Navigates current page to the given history entry.\n- [`Page.printToPDF`](struct.PrintToPdfCommand.html)\n\n  Print page as PDF.\n- [`Page.reload`](struct.ReloadCommand.html)\n\n  Reloads given page optionally ignoring the cache.\n- [`Page.removeScriptToEvaluateOnLoad`](struct.RemoveScriptToEvaluateOnLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n  \n  <span class=\"stab deprecated\">please use removeScriptToEvaluateOnNewDocument instead.</span>\n- [`Page.removeScriptToEvaluateOnNewDocument`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html)\n\n  Removes given script from the list.\n- [`Page.requestAppBanner`](struct.RequestAppBannerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Page.screencastFrameAck`](struct.ScreencastFrameAckCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Acknowledges that a screencast frame has been received by the frontend.\n- [`Page.searchInResource`](struct.SearchInResourceCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Searches for given string in resource content.\n- [`Page.setAdBlockingEnabled`](struct.SetAdBlockingEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable Chrome's experimental ad filter on all sites.\n- [`Page.setBypassCSP`](struct.SetBypassCspCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable page Content Security Policy by-passing.\n- [`Page.setDeviceMetricsOverride`](struct.SetDeviceMetricsOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\n  window.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\n  query results\\).\n- [`Page.setDeviceOrientationOverride`](struct.SetDeviceOrientationOverrideCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Overrides the Device Orientation.\n- [`Page.setFontFamilies`](struct.SetFontFamiliesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Set generic font families.\n- [`Page.setFontSizes`](struct.SetFontSizesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Set default font sizes.\n- [`Page.setDocumentContent`](struct.SetDocumentContentCommand.html)\n\n  Sets given markup as the document's HTML.\n- [`Page.setDownloadBehavior`](struct.SetDownloadBehaviorCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Set the behavior when downloading a file.\n- [`Page.setGeolocationOverride`](struct.SetGeolocationOverrideCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\n  unavailable.\n- [`Page.setLifecycleEventsEnabled`](struct.SetLifecycleEventsEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Controls whether page will emit lifecycle events.\n- [`Page.setTouchEmulationEnabled`](struct.SetTouchEmulationEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span> <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Toggles mouse event-based touch event emulation.\n- [`Page.startScreencast`](struct.StartScreencastCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Starts sending each frame using the `screencastFrame` event.\n- [`Page.stopLoading`](struct.StopLoadingCommand.html)\n\n  Force the page stop all navigations and pending resource fetches.\n- [`Page.crash`](struct.CrashCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Crashes renderer on the IO thread, generates minidumps.\n- [`Page.close`](struct.CloseCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Tries to close page, running its beforeunload hooks, if any.\n- [`Page.setWebLifecycleState`](struct.SetWebLifecycleStateCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Tries to update the web lifecycle state of the page.\n  It will transition the page to the given state according to:\n  https://github.com/WICG/web-lifecycle/\n- [`Page.stopScreencast`](struct.StopScreencastCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stops sending each frame in the `screencastFrame`.\n- [`Page.setProduceCompilationCache`](struct.SetProduceCompilationCacheCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Forces compilation cache to be generated for every subresource script.\n- [`Page.addCompilationCache`](struct.AddCompilationCacheCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Seeds compilation cache for given url. Compilation cache does not survive\n  cross-process navigation.\n- [`Page.clearCompilationCache`](struct.ClearCompilationCacheCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears seeded compilation cache.\n- [`Page.generateTestReport`](struct.GenerateTestReportCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Generates a report for testing.\n\n## Events\n\n- [`Page.domContentEventFired`](struct.DomContentEventFiredEvent.html)\n- [`Page.frameAttached`](struct.FrameAttachedEvent.html)\n\n  Fired when frame has been attached to its parent.\n- [`Page.frameClearedScheduledNavigation`](struct.FrameClearedScheduledNavigationEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame no longer has a scheduled navigation.\n- [`Page.frameDetached`](struct.FrameDetachedEvent.html)\n\n  Fired when frame has been detached from its parent.\n- [`Page.frameNavigated`](struct.FrameNavigatedEvent.html)\n\n  Fired once navigation of the frame has completed. Frame is now associated with the new loader.\n- [`Page.frameResized`](struct.FrameResizedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Page.frameScheduledNavigation`](struct.FrameScheduledNavigationEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame schedules a potential navigation.\n- [`Page.frameStartedLoading`](struct.FrameStartedLoadingEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame has started loading.\n- [`Page.frameStoppedLoading`](struct.FrameStoppedLoadingEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when frame has stopped loading.\n- [`Page.interstitialHidden`](struct.InterstitialHiddenEvent.html)\n\n  Fired when interstitial page was hidden\n- [`Page.interstitialShown`](struct.InterstitialShownEvent.html)\n\n  Fired when interstitial page was shown\n- [`Page.javascriptDialogClosed`](struct.JavascriptDialogClosedEvent.html)\n\n  Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) has been\n  closed.\n- [`Page.javascriptDialogOpening`](struct.JavascriptDialogOpeningEvent.html)\n\n  Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) is about to\n  open.\n- [`Page.lifecycleEvent`](struct.LifecycleEventEvent.html)\n\n  Fired for top level page lifecycle events such as navigation, load, paint, etc.\n- [`Page.loadEventFired`](struct.LoadEventFiredEvent.html)\n- [`Page.navigatedWithinDocument`](struct.NavigatedWithinDocumentEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.\n- [`Page.screencastFrame`](struct.ScreencastFrameEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Compressed image data requested by the `startScreencast`.\n- [`Page.screencastVisibilityChanged`](struct.ScreencastVisibilityChangedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Fired when the page with currently enabled screencast was shown or hidden `.\n- [`Page.windowOpen`](struct.WindowOpenEvent.html)\n\n  Fired when a new window is going to be opened, via window.open\\(\\), link click, form submission,\n  etc.\n- [`Page.compilationCacheProduced`](struct.CompilationCacheProducedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued for every compilation cache generated. Is only available\n  if Page.setGenerateCompilationCache is enabled.\n\n##Types\n\n- [`FrameId`](type.FrameId.html)\n\n  Unique frame identifier.\n- [`Frame`](struct.Frame.html)\n\n  Information about the Frame on the page.\n- [`FrameResource`](struct.FrameResource.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about the Resource on the page.\n- [`FrameResourceTree`](struct.FrameResourceTree.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Information about the Frame hierarchy along with their cached resources.\n- [`FrameTree`](struct.FrameTree.html)\n\n  Information about the Frame hierarchy.\n- [`ScriptIdentifier`](type.ScriptIdentifier.html)\n\n  Unique script identifier.\n- [`TransitionType`](enum.TransitionType.html)\n\n  Transition type.\n- [`NavigationEntry`](struct.NavigationEntry.html)\n\n  Navigation history entry.\n- [`ScreencastFrameMetadata`](struct.ScreencastFrameMetadata.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Screencast frame metadata.\n- [`DialogType`](enum.DialogType.html)\n\n  Javascript dialog type.\n- [`AppManifestError`](struct.AppManifestError.html)\n\n  Error while paring app manifest.\n- [`LayoutViewport`](struct.LayoutViewport.html)\n\n  Layout viewport position and dimensions.\n- [`VisualViewport`](struct.VisualViewport.html)\n\n  Visual viewport position, dimensions, and scale.\n- [`Viewport`](struct.Viewport.html)\n\n  Viewport for capturing screenshot.\n- [`FontFamilies`](struct.FontFamilies.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Generic font families collection.\n- [`FontSizes`](struct.FontSizes.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Default font sizes.\n"]
pub mod page {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.addScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddScriptToEvaluateOnLoadCommand`](struct.AddScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::page::AddScriptToEvaluateOnLoadResponse`](struct.AddScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use addScriptToEvaluateOnNewDocument instead.")]
    pub struct AddScriptToEvaluateOnLoadCommand<'a> {
        #[serde(rename = "scriptSource")]
        pub script_source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for AddScriptToEvaluateOnLoadCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.addScriptToEvaluateOnLoad";
    }
    impl<'a> ::SerializeCdpCommand for AddScriptToEvaluateOnLoadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.addScriptToEvaluateOnLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddScriptToEvaluateOnLoadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.addScriptToEvaluateOnLoad" {
                Ok ( < AddScriptToEvaluateOnLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.addScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddScriptToEvaluateOnLoadCommand`](struct.AddScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::page::AddScriptToEvaluateOnLoadResponse`](struct.AddScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use addScriptToEvaluateOnNewDocument instead.")]
    pub struct AddScriptToEvaluateOnLoadResponse<'a> {
        #[serde(rename = "identifier")]
        #[doc = "Identifier of the added script."]
        pub identifier: ::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::CdpCommand for AddScriptToEvaluateOnLoadResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.addScriptToEvaluateOnLoad";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddScriptToEvaluateOnLoadCommand<'a> {
        type Response = AddScriptToEvaluateOnLoadResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AddScriptToEvaluateOnLoadResponse<'b> {
        type Command = AddScriptToEvaluateOnLoadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n\n# Command `Page.addScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddScriptToEvaluateOnNewDocumentCommand`](struct.AddScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::page::AddScriptToEvaluateOnNewDocumentResponse`](struct.AddScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct AddScriptToEvaluateOnNewDocumentCommand<'a> {
        #[serde(rename = "source")]
        pub source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.addScriptToEvaluateOnNewDocument";
    }
    impl<'a> ::SerializeCdpCommand for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.addScriptToEvaluateOnNewDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.addScriptToEvaluateOnNewDocument" {
                Ok ( < AddScriptToEvaluateOnNewDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates given script in every frame upon creation \\(before loading frame's scripts\\).\n\n# Command `Page.addScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddScriptToEvaluateOnNewDocumentCommand`](struct.AddScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::page::AddScriptToEvaluateOnNewDocumentResponse`](struct.AddScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct AddScriptToEvaluateOnNewDocumentResponse<'a> {
        #[serde(rename = "identifier")]
        #[doc = "Identifier of the added script."]
        pub identifier: ::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::CdpCommand for AddScriptToEvaluateOnNewDocumentResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.addScriptToEvaluateOnNewDocument";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddScriptToEvaluateOnNewDocumentCommand<'a> {
        type Response = AddScriptToEvaluateOnNewDocumentResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AddScriptToEvaluateOnNewDocumentResponse<'b> {
        type Command = AddScriptToEvaluateOnNewDocumentCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Brings page to front \\(activates tab\\).\n\n# Command `Page.bringToFront`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::BringToFrontCommand`](struct.BringToFrontCommand.html)  \n*Response Struct:* [`cdp::page::BringToFrontResponse`](struct.BringToFrontResponse.html)"]
    pub struct BringToFrontCommand;
    impl ::serde::Serialize for BringToFrontCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BringToFrontCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| BringToFrontCommand)
        }
    }
    impl ::CdpCommand for BringToFrontCommand {
        const COMMAND_NAME: &'static str = "Page.bringToFront";
    }
    impl ::SerializeCdpCommand for BringToFrontCommand {
        fn command_name(&self) -> &str {
            "Page.bringToFront"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for BringToFrontCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.bringToFront" {
                Ok(
                    <BringToFrontCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Brings page to front \\(activates tab\\).\n\n# Command `Page.bringToFront`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::BringToFrontCommand`](struct.BringToFrontCommand.html)  \n*Response Struct:* [`cdp::page::BringToFrontResponse`](struct.BringToFrontResponse.html)"]
    pub struct BringToFrontResponse;
    impl ::serde::Serialize for BringToFrontResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BringToFrontResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| BringToFrontResponse)
        }
    }
    impl ::CdpCommand for BringToFrontResponse {
        const COMMAND_NAME: &'static str = "Page.bringToFront";
    }
    impl<'b> ::HasCdpResponse<'b> for BringToFrontCommand {
        type Response = BringToFrontResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for BringToFrontResponse {
        type Command = BringToFrontCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::page::CaptureScreenshotCommand::format`](struct.CaptureScreenshotCommand.html#structfield.format)."]
    pub enum CaptureScreenshotCommandFormat {
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl CaptureScreenshotCommandFormat {
        pub const ENUM_VALUES: &'static [CaptureScreenshotCommandFormat] =
            &[
                CaptureScreenshotCommandFormat::Jpeg,
                CaptureScreenshotCommandFormat::Png,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["jpeg", "png"];
    }
    impl ::std::str::FromStr for CaptureScreenshotCommandFormat {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "jpeg" => Ok(CaptureScreenshotCommandFormat::Jpeg),
                "png" => Ok(CaptureScreenshotCommandFormat::Png),
                _ => Err(::ParseEnumError {
                    expected: CaptureScreenshotCommandFormat::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CaptureScreenshotCommandFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CaptureScreenshotCommandFormat::Jpeg => "jpeg",
                    CaptureScreenshotCommandFormat::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Capture page screenshot.\n\n# Command `Page.captureScreenshot`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CaptureScreenshotCommand`](struct.CaptureScreenshotCommand.html)  \n*Response Struct:* [`cdp::page::CaptureScreenshotResponse`](struct.CaptureScreenshotResponse.html)"]
    pub struct CaptureScreenshotCommand {
        #[serde(rename = "format", skip_serializing_if = "Option::is_none")]
        #[doc = "Image compression format \\(defaults to png\\)."]
        pub format: Option<::page::CaptureScreenshotCommandFormat>,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression quality from range \\[0..100\\] \\(jpeg only\\)."]
        pub quality: Option<i32>,
        #[serde(rename = "clip", skip_serializing_if = "Option::is_none")]
        #[doc = "Capture the screenshot of a given region only."]
        pub clip: Option<::page::Viewport>,
        #[serde(rename = "fromSurface", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Capture the screenshot from the surface, rather than the view. Defaults to true."]
        pub from_surface: Option<bool>,
    }
    impl ::CdpCommand for CaptureScreenshotCommand {
        const COMMAND_NAME: &'static str = "Page.captureScreenshot";
    }
    impl ::SerializeCdpCommand for CaptureScreenshotCommand {
        fn command_name(&self) -> &str {
            "Page.captureScreenshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CaptureScreenshotCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.captureScreenshot" {
                Ok ( < CaptureScreenshotCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Capture page screenshot.\n\n# Command `Page.captureScreenshot`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CaptureScreenshotCommand`](struct.CaptureScreenshotCommand.html)  \n*Response Struct:* [`cdp::page::CaptureScreenshotResponse`](struct.CaptureScreenshotResponse.html)"]
    pub struct CaptureScreenshotResponse<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded image data."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for CaptureScreenshotResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.captureScreenshot";
    }
    impl<'b> ::HasCdpResponse<'b> for CaptureScreenshotCommand {
        type Response = CaptureScreenshotResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CaptureScreenshotResponse<'b> {
        type Command = CaptureScreenshotCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden device metrics.\n\n# Command `Page.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearDeviceMetricsOverrideCommand;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearDeviceMetricsOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.clearDeviceMetricsOverride";
    }
    impl ::SerializeCdpCommand for ClearDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearDeviceMetricsOverride" {
                Ok ( < ClearDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overriden device metrics.\n\n# Command `Page.clearDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearDeviceMetricsOverrideCommand`](struct.ClearDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearDeviceMetricsOverrideResponse`](struct.ClearDeviceMetricsOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for ClearDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceMetricsOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearDeviceMetricsOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.clearDeviceMetricsOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearDeviceMetricsOverrideCommand {
        type Response = ClearDeviceMetricsOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearDeviceMetricsOverrideResponse {
        type Command = ClearDeviceMetricsOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `Page.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearDeviceOrientationOverrideCommand;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearDeviceOrientationOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.clearDeviceOrientationOverride";
    }
    impl ::SerializeCdpCommand for ClearDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearDeviceOrientationOverride" {
                Ok ( < ClearDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears the overridden Device Orientation.\n\n# Command `Page.clearDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearDeviceOrientationOverrideCommand`](struct.ClearDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearDeviceOrientationOverrideResponse`](struct.ClearDeviceOrientationOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for ClearDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDeviceOrientationOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearDeviceOrientationOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.clearDeviceOrientationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearDeviceOrientationOverrideCommand {
        type Response = ClearDeviceOrientationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearDeviceOrientationOverrideResponse {
        type Command = ClearDeviceOrientationOverrideCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Page.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearGeolocationOverrideCommand;
    impl ::serde::Serialize for ClearGeolocationOverrideCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideCommand)
        }
    }
    impl ::CdpCommand for ClearGeolocationOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.clearGeolocationOverride";
    }
    impl ::SerializeCdpCommand for ClearGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.clearGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearGeolocationOverride" {
                Ok ( < ClearGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Clears the overriden Geolocation Position and Error.\n\n# Command `Page.clearGeolocationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearGeolocationOverrideCommand`](struct.ClearGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::ClearGeolocationOverrideResponse`](struct.ClearGeolocationOverrideResponse.html)"]
    #[deprecated]
    pub struct ClearGeolocationOverrideResponse;
    impl ::serde::Serialize for ClearGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearGeolocationOverrideResponse)
        }
    }
    impl ::CdpCommand for ClearGeolocationOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.clearGeolocationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearGeolocationOverrideCommand {
        type Response = ClearGeolocationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearGeolocationOverrideResponse {
        type Command = ClearGeolocationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Creates an isolated world for the given frame.\n\n# Command `Page.createIsolatedWorld`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CreateIsolatedWorldCommand`](struct.CreateIsolatedWorldCommand.html)  \n*Response Struct:* [`cdp::page::CreateIsolatedWorldResponse`](struct.CreateIsolatedWorldResponse.html)"]
    pub struct CreateIsolatedWorldCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame in which the isolated world should be created."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "worldName", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional name which is reported in the Execution Context."]
        pub world_name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "grantUniveralAccess", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not universal access should be granted to the isolated world. This is a powerful\noption, use with caution."]
        pub grant_univeral_access: Option<bool>,
    }
    impl<'a> ::CdpCommand for CreateIsolatedWorldCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.createIsolatedWorld";
    }
    impl<'a> ::SerializeCdpCommand for CreateIsolatedWorldCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.createIsolatedWorld"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CreateIsolatedWorldCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.createIsolatedWorld" {
                Ok ( < CreateIsolatedWorldCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Creates an isolated world for the given frame.\n\n# Command `Page.createIsolatedWorld`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CreateIsolatedWorldCommand`](struct.CreateIsolatedWorldCommand.html)  \n*Response Struct:* [`cdp::page::CreateIsolatedWorldResponse`](struct.CreateIsolatedWorldResponse.html)"]
    pub struct CreateIsolatedWorldResponse {
        #[serde(rename = "executionContextId")]
        #[doc = "Execution context of the isolated world."]
        pub execution_context_id: ::runtime::ExecutionContextId,
    }
    impl ::CdpCommand for CreateIsolatedWorldResponse {
        const COMMAND_NAME: &'static str = "Page.createIsolatedWorld";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CreateIsolatedWorldCommand<'a> {
        type Response = CreateIsolatedWorldResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CreateIsolatedWorldResponse {
        type Command = CreateIsolatedWorldCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Page.deleteCookie`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::page::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    #[deprecated]
    pub struct DeleteCookieCommand<'a> {
        #[serde(rename = "cookieName")]
        #[doc = "Name of the cookie to remove."]
        pub cookie_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url")]
        #[doc = "URL to match cooke domain and path."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for DeleteCookieCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.deleteCookie";
    }
    impl<'a> ::SerializeCdpCommand for DeleteCookieCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.deleteCookie"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeleteCookieCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.deleteCookie" {
                Ok(
                    <DeleteCookieCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes browser cookie with given name, domain and path.\n\n# Command `Page.deleteCookie`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::DeleteCookieCommand`](struct.DeleteCookieCommand.html)  \n*Response Struct:* [`cdp::page::DeleteCookieResponse`](struct.DeleteCookieResponse.html)"]
    #[deprecated]
    pub struct DeleteCookieResponse;
    impl ::serde::Serialize for DeleteCookieResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeleteCookieResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeleteCookieResponse)
        }
    }
    impl ::CdpCommand for DeleteCookieResponse {
        const COMMAND_NAME: &'static str = "Page.deleteCookie";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeleteCookieCommand<'a> {
        type Response = DeleteCookieResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeleteCookieResponse {
        type Command = DeleteCookieCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables page domain notifications.\n\n# Command `Page.disable`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::page::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Page.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Page.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables page domain notifications.\n\n# Command `Page.disable`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::page::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Page.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables page domain notifications.\n\n# Command `Page.enable`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::page::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Page.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Page.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables page domain notifications.\n\n# Command `Page.enable`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::page::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Page.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Page.getAppManifest`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetAppManifestCommand`](struct.GetAppManifestCommand.html)  \n*Response Struct:* [`cdp::page::GetAppManifestResponse`](struct.GetAppManifestResponse.html)"]
    pub struct GetAppManifestCommand;
    impl ::serde::Serialize for GetAppManifestCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetAppManifestCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetAppManifestCommand)
        }
    }
    impl ::CdpCommand for GetAppManifestCommand {
        const COMMAND_NAME: &'static str = "Page.getAppManifest";
    }
    impl ::SerializeCdpCommand for GetAppManifestCommand {
        fn command_name(&self) -> &str {
            "Page.getAppManifest"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetAppManifestCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getAppManifest" {
                Ok(
                    <GetAppManifestCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Command `Page.getAppManifest`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetAppManifestCommand`](struct.GetAppManifestCommand.html)  \n*Response Struct:* [`cdp::page::GetAppManifestResponse`](struct.GetAppManifestResponse.html)"]
    pub struct GetAppManifestResponse<'a> {
        #[serde(rename = "url")]
        #[doc = "Manifest location."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "errors")]
        pub errors: Vec<::page::AppManifestError<'a>>,
        #[serde(rename = "data", skip_serializing_if = "Option::is_none")]
        #[doc = "Manifest content."]
        pub data: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetAppManifestResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getAppManifest";
    }
    impl<'b> ::HasCdpResponse<'b> for GetAppManifestCommand {
        type Response = GetAppManifestResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetAppManifestResponse<'b> {
        type Command = GetAppManifestCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n\n# Command `Page.getCookies`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::page::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    #[deprecated]
    pub struct GetCookiesCommand;
    impl ::serde::Serialize for GetCookiesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCookiesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetCookiesCommand)
        }
    }
    impl ::CdpCommand for GetCookiesCommand {
        const COMMAND_NAME: &'static str = "Page.getCookies";
    }
    impl ::SerializeCdpCommand for GetCookiesCommand {
        fn command_name(&self) -> &str {
            "Page.getCookies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetCookiesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getCookies" {
                Ok(
                    <GetCookiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser cookies. Depending on the backend support, will return detailed cookie\ninformation in the `cookies` field.\n\n# Command `Page.getCookies`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetCookiesCommand`](struct.GetCookiesCommand.html)  \n*Response Struct:* [`cdp::page::GetCookiesResponse`](struct.GetCookiesResponse.html)"]
    #[deprecated]
    pub struct GetCookiesResponse<'a> {
        #[serde(rename = "cookies")]
        #[doc = "Array of cookie objects."]
        pub cookies: Vec<::network::Cookie<'a>>,
    }
    impl<'a> ::CdpCommand for GetCookiesResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getCookies";
    }
    impl<'b> ::HasCdpResponse<'b> for GetCookiesCommand {
        type Response = GetCookiesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetCookiesResponse<'b> {
        type Command = GetCookiesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns present frame tree structure.\n\n# Command `Page.getFrameTree`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetFrameTreeCommand`](struct.GetFrameTreeCommand.html)  \n*Response Struct:* [`cdp::page::GetFrameTreeResponse`](struct.GetFrameTreeResponse.html)"]
    pub struct GetFrameTreeCommand;
    impl ::serde::Serialize for GetFrameTreeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetFrameTreeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetFrameTreeCommand)
        }
    }
    impl ::CdpCommand for GetFrameTreeCommand {
        const COMMAND_NAME: &'static str = "Page.getFrameTree";
    }
    impl ::SerializeCdpCommand for GetFrameTreeCommand {
        fn command_name(&self) -> &str {
            "Page.getFrameTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetFrameTreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getFrameTree" {
                Ok(
                    <GetFrameTreeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns present frame tree structure.\n\n# Command `Page.getFrameTree`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetFrameTreeCommand`](struct.GetFrameTreeCommand.html)  \n*Response Struct:* [`cdp::page::GetFrameTreeResponse`](struct.GetFrameTreeResponse.html)"]
    pub struct GetFrameTreeResponse<'a> {
        #[serde(rename = "frameTree")]
        #[doc = "Present frame tree structure."]
        pub frame_tree: ::page::FrameTree<'a>,
    }
    impl<'a> ::CdpCommand for GetFrameTreeResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getFrameTree";
    }
    impl<'b> ::HasCdpResponse<'b> for GetFrameTreeCommand {
        type Response = GetFrameTreeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetFrameTreeResponse<'b> {
        type Command = GetFrameTreeCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n\n# Command `Page.getLayoutMetrics`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetLayoutMetricsCommand`](struct.GetLayoutMetricsCommand.html)  \n*Response Struct:* [`cdp::page::GetLayoutMetricsResponse`](struct.GetLayoutMetricsResponse.html)"]
    pub struct GetLayoutMetricsCommand;
    impl ::serde::Serialize for GetLayoutMetricsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetLayoutMetricsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetLayoutMetricsCommand)
        }
    }
    impl ::CdpCommand for GetLayoutMetricsCommand {
        const COMMAND_NAME: &'static str = "Page.getLayoutMetrics";
    }
    impl ::SerializeCdpCommand for GetLayoutMetricsCommand {
        fn command_name(&self) -> &str {
            "Page.getLayoutMetrics"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetLayoutMetricsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getLayoutMetrics" {
                Ok ( < GetLayoutMetricsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns metrics relating to the layouting of the page, such as viewport bounds/scale.\n\n# Command `Page.getLayoutMetrics`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetLayoutMetricsCommand`](struct.GetLayoutMetricsCommand.html)  \n*Response Struct:* [`cdp::page::GetLayoutMetricsResponse`](struct.GetLayoutMetricsResponse.html)"]
    pub struct GetLayoutMetricsResponse {
        #[serde(rename = "layoutViewport")]
        #[doc = "Metrics relating to the layout viewport."]
        pub layout_viewport: ::page::LayoutViewport,
        #[serde(rename = "visualViewport")]
        #[doc = "Metrics relating to the visual viewport."]
        pub visual_viewport: ::page::VisualViewport,
        #[serde(rename = "contentSize")]
        #[doc = "Size of scrollable area."]
        pub content_size: ::dom::Rect,
    }
    impl ::CdpCommand for GetLayoutMetricsResponse {
        const COMMAND_NAME: &'static str = "Page.getLayoutMetrics";
    }
    impl<'b> ::HasCdpResponse<'b> for GetLayoutMetricsCommand {
        type Response = GetLayoutMetricsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetLayoutMetricsResponse {
        type Command = GetLayoutMetricsCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns navigation history for the current page.\n\n# Command `Page.getNavigationHistory`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetNavigationHistoryCommand`](struct.GetNavigationHistoryCommand.html)  \n*Response Struct:* [`cdp::page::GetNavigationHistoryResponse`](struct.GetNavigationHistoryResponse.html)"]
    pub struct GetNavigationHistoryCommand;
    impl ::serde::Serialize for GetNavigationHistoryCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetNavigationHistoryCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetNavigationHistoryCommand)
        }
    }
    impl ::CdpCommand for GetNavigationHistoryCommand {
        const COMMAND_NAME: &'static str = "Page.getNavigationHistory";
    }
    impl ::SerializeCdpCommand for GetNavigationHistoryCommand {
        fn command_name(&self) -> &str {
            "Page.getNavigationHistory"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetNavigationHistoryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getNavigationHistory" {
                Ok ( < GetNavigationHistoryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns navigation history for the current page.\n\n# Command `Page.getNavigationHistory`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetNavigationHistoryCommand`](struct.GetNavigationHistoryCommand.html)  \n*Response Struct:* [`cdp::page::GetNavigationHistoryResponse`](struct.GetNavigationHistoryResponse.html)"]
    pub struct GetNavigationHistoryResponse<'a> {
        #[serde(rename = "currentIndex")]
        #[doc = "Index of the current navigation history entry."]
        pub current_index: i32,
        #[serde(rename = "entries")]
        #[doc = "Array of navigation history entries."]
        pub entries: Vec<::page::NavigationEntry<'a>>,
    }
    impl<'a> ::CdpCommand for GetNavigationHistoryResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getNavigationHistory";
    }
    impl<'b> ::HasCdpResponse<'b> for GetNavigationHistoryCommand {
        type Response = GetNavigationHistoryResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetNavigationHistoryResponse<'b> {
        type Command = GetNavigationHistoryCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content of the given resource.\n\n# Command `Page.getResourceContent`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetResourceContentCommand`](struct.GetResourceContentCommand.html)  \n*Response Struct:* [`cdp::page::GetResourceContentResponse`](struct.GetResourceContentResponse.html)"]
    pub struct GetResourceContentCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id to get resource for."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL of the resource to get content for."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetResourceContentCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.getResourceContent";
    }
    impl<'a> ::SerializeCdpCommand for GetResourceContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.getResourceContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetResourceContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getResourceContent" {
                Ok ( < GetResourceContentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns content of the given resource.\n\n# Command `Page.getResourceContent`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetResourceContentCommand`](struct.GetResourceContentCommand.html)  \n*Response Struct:* [`cdp::page::GetResourceContentResponse`](struct.GetResourceContentResponse.html)"]
    pub struct GetResourceContentResponse<'a> {
        #[serde(rename = "content")]
        #[doc = "Resource content."]
        pub content: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "base64Encoded")]
        #[doc = "True, if content was served as base64."]
        pub base_64_encoded: bool,
    }
    impl<'a> ::CdpCommand for GetResourceContentResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getResourceContent";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetResourceContentCommand<'a> {
        type Response = GetResourceContentResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetResourceContentResponse<'b> {
        type Command = GetResourceContentCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns present frame / resource tree structure.\n\n# Command `Page.getResourceTree`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetResourceTreeCommand`](struct.GetResourceTreeCommand.html)  \n*Response Struct:* [`cdp::page::GetResourceTreeResponse`](struct.GetResourceTreeResponse.html)"]
    pub struct GetResourceTreeCommand;
    impl ::serde::Serialize for GetResourceTreeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetResourceTreeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetResourceTreeCommand)
        }
    }
    impl ::CdpCommand for GetResourceTreeCommand {
        const COMMAND_NAME: &'static str = "Page.getResourceTree";
    }
    impl ::SerializeCdpCommand for GetResourceTreeCommand {
        fn command_name(&self) -> &str {
            "Page.getResourceTree"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetResourceTreeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.getResourceTree" {
                Ok(
                    <GetResourceTreeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns present frame / resource tree structure.\n\n# Command `Page.getResourceTree`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GetResourceTreeCommand`](struct.GetResourceTreeCommand.html)  \n*Response Struct:* [`cdp::page::GetResourceTreeResponse`](struct.GetResourceTreeResponse.html)"]
    pub struct GetResourceTreeResponse<'a> {
        #[serde(rename = "frameTree")]
        #[doc = "Present frame / resource tree structure."]
        pub frame_tree: ::page::FrameResourceTree<'a>,
    }
    impl<'a> ::CdpCommand for GetResourceTreeResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.getResourceTree";
    }
    impl<'b> ::HasCdpResponse<'b> for GetResourceTreeCommand {
        type Response = GetResourceTreeResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetResourceTreeResponse<'b> {
        type Command = GetResourceTreeCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n\n# Command `Page.handleJavaScriptDialog`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::HandleJavaScriptDialogCommand`](struct.HandleJavaScriptDialogCommand.html)  \n*Response Struct:* [`cdp::page::HandleJavaScriptDialogResponse`](struct.HandleJavaScriptDialogResponse.html)"]
    pub struct HandleJavaScriptDialogCommand<'a> {
        #[serde(rename = "accept")]
        #[doc = "Whether to accept or dismiss the dialog."]
        pub accept: bool,
        #[serde(rename = "promptText", skip_serializing_if = "Option::is_none")]
        #[doc = "The text to enter into the dialog prompt before accepting. Used only if this is a prompt\ndialog."]
        pub prompt_text: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for HandleJavaScriptDialogCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.handleJavaScriptDialog";
    }
    impl<'a> ::SerializeCdpCommand for HandleJavaScriptDialogCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.handleJavaScriptDialog"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for HandleJavaScriptDialogCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.handleJavaScriptDialog" {
                Ok ( < HandleJavaScriptDialogCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Accepts or dismisses a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\).\n\n# Command `Page.handleJavaScriptDialog`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::HandleJavaScriptDialogCommand`](struct.HandleJavaScriptDialogCommand.html)  \n*Response Struct:* [`cdp::page::HandleJavaScriptDialogResponse`](struct.HandleJavaScriptDialogResponse.html)"]
    pub struct HandleJavaScriptDialogResponse;
    impl ::serde::Serialize for HandleJavaScriptDialogResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HandleJavaScriptDialogResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HandleJavaScriptDialogResponse)
        }
    }
    impl ::CdpCommand for HandleJavaScriptDialogResponse {
        const COMMAND_NAME: &'static str = "Page.handleJavaScriptDialog";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for HandleJavaScriptDialogCommand<'a> {
        type Response = HandleJavaScriptDialogResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HandleJavaScriptDialogResponse {
        type Command = HandleJavaScriptDialogCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given URL.\n\n# Command `Page.navigate`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::NavigateCommand`](struct.NavigateCommand.html)  \n*Response Struct:* [`cdp::page::NavigateResponse`](struct.NavigateResponse.html)"]
    pub struct NavigateCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "URL to navigate the page to."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "referrer", skip_serializing_if = "Option::is_none")]
        #[doc = "Referrer URL."]
        pub referrer: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "transitionType", skip_serializing_if = "Option::is_none")]
        #[doc = "Intended transition type."]
        pub transition_type: Option<::page::TransitionType>,
        #[serde(rename = "frameId", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame id to navigate, if not specified navigates the top frame."]
        pub frame_id: Option<::page::FrameId<'a>>,
    }
    impl<'a> ::CdpCommand for NavigateCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.navigate";
    }
    impl<'a> ::SerializeCdpCommand for NavigateCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.navigate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for NavigateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigate" {
                Ok(
                    <NavigateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given URL.\n\n# Command `Page.navigate`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::NavigateCommand`](struct.NavigateCommand.html)  \n*Response Struct:* [`cdp::page::NavigateResponse`](struct.NavigateResponse.html)"]
    pub struct NavigateResponse<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id that has navigated \\(or failed to navigate\\)"]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "loaderId", skip_serializing_if = "Option::is_none")]
        #[doc = "Loader identifier."]
        pub loader_id: Option<::network::LoaderId<'a>>,
        #[serde(rename = "errorText", skip_serializing_if = "Option::is_none")]
        #[doc = "User friendly error message, present if and only if navigation has failed."]
        pub error_text: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for NavigateResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.navigate";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for NavigateCommand<'a> {
        type Response = NavigateResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for NavigateResponse<'b> {
        type Command = NavigateCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given history entry.\n\n# Command `Page.navigateToHistoryEntry`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::NavigateToHistoryEntryCommand`](struct.NavigateToHistoryEntryCommand.html)  \n*Response Struct:* [`cdp::page::NavigateToHistoryEntryResponse`](struct.NavigateToHistoryEntryResponse.html)"]
    pub struct NavigateToHistoryEntryCommand {
        #[serde(rename = "entryId")]
        #[doc = "Unique id of the entry to navigate to."]
        pub entry_id: i32,
    }
    impl ::CdpCommand for NavigateToHistoryEntryCommand {
        const COMMAND_NAME: &'static str = "Page.navigateToHistoryEntry";
    }
    impl ::SerializeCdpCommand for NavigateToHistoryEntryCommand {
        fn command_name(&self) -> &str {
            "Page.navigateToHistoryEntry"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for NavigateToHistoryEntryCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigateToHistoryEntry" {
                Ok ( < NavigateToHistoryEntryCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Navigates current page to the given history entry.\n\n# Command `Page.navigateToHistoryEntry`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::NavigateToHistoryEntryCommand`](struct.NavigateToHistoryEntryCommand.html)  \n*Response Struct:* [`cdp::page::NavigateToHistoryEntryResponse`](struct.NavigateToHistoryEntryResponse.html)"]
    pub struct NavigateToHistoryEntryResponse;
    impl ::serde::Serialize for NavigateToHistoryEntryResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for NavigateToHistoryEntryResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| NavigateToHistoryEntryResponse)
        }
    }
    impl ::CdpCommand for NavigateToHistoryEntryResponse {
        const COMMAND_NAME: &'static str = "Page.navigateToHistoryEntry";
    }
    impl<'b> ::HasCdpResponse<'b> for NavigateToHistoryEntryCommand {
        type Response = NavigateToHistoryEntryResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for NavigateToHistoryEntryResponse {
        type Command = NavigateToHistoryEntryCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Print page as PDF.\n\n# Command `Page.printToPDF`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::PrintToPdfCommand`](struct.PrintToPdfCommand.html)  \n*Response Struct:* [`cdp::page::PrintToPdfResponse`](struct.PrintToPdfResponse.html)"]
    pub struct PrintToPdfCommand<'a> {
        #[serde(rename = "landscape", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper orientation. Defaults to false."]
        pub landscape: Option<bool>,
        #[serde(rename = "displayHeaderFooter", skip_serializing_if = "Option::is_none")]
        #[doc = "Display header and footer. Defaults to false."]
        pub display_header_footer: Option<bool>,
        #[serde(rename = "printBackground", skip_serializing_if = "Option::is_none")]
        #[doc = "Print background graphics. Defaults to false."]
        pub print_background: Option<bool>,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "Scale of the webpage rendering. Defaults to 1."]
        pub scale: Option<f64>,
        #[serde(rename = "paperWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper width in inches. Defaults to 8.5 inches."]
        pub paper_width: Option<f64>,
        #[serde(rename = "paperHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper height in inches. Defaults to 11 inches."]
        pub paper_height: Option<f64>,
        #[serde(rename = "marginTop", skip_serializing_if = "Option::is_none")]
        #[doc = "Top margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_top: Option<f64>,
        #[serde(rename = "marginBottom", skip_serializing_if = "Option::is_none")]
        #[doc = "Bottom margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_bottom: Option<f64>,
        #[serde(rename = "marginLeft", skip_serializing_if = "Option::is_none")]
        #[doc = "Left margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_left: Option<f64>,
        #[serde(rename = "marginRight", skip_serializing_if = "Option::is_none")]
        #[doc = "Right margin in inches. Defaults to 1cm \\(~0.4 inches\\)."]
        pub margin_right: Option<f64>,
        #[serde(rename = "pageRanges", skip_serializing_if = "Option::is_none")]
        #[doc = "Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means\nprint all pages."]
        pub page_ranges: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "ignoreInvalidPageRanges", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.\nDefaults to false."]
        pub ignore_invalid_page_ranges: Option<bool>,
        #[serde(rename = "headerTemplate", skip_serializing_if = "Option::is_none")]
        #[doc = "HTML template for the print header. Should be valid HTML markup with following\nclasses used to inject printing values into them:\n- `date`: formatted print date\n- `title`: document title\n- `url`: document location\n- `pageNumber`: current page number\n- `totalPages`: total pages in the document\n\nFor example, `<span class=title></span>` would generate span containing the title."]
        pub header_template: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "footerTemplate", skip_serializing_if = "Option::is_none")]
        #[doc = "HTML template for the print footer. Should use the same format as the `headerTemplate`."]
        pub footer_template: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "preferCSSPageSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether or not to prefer page size as defined by css. Defaults to false,\nin which case the content will be scaled to fit the paper size."]
        pub prefer_css_page_size: Option<bool>,
    }
    impl<'a> ::CdpCommand for PrintToPdfCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.printToPDF";
    }
    impl<'a> ::SerializeCdpCommand for PrintToPdfCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.printToPDF"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for PrintToPdfCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.printToPDF" {
                Ok(
                    <PrintToPdfCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Print page as PDF.\n\n# Command `Page.printToPDF`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::PrintToPdfCommand`](struct.PrintToPdfCommand.html)  \n*Response Struct:* [`cdp::page::PrintToPdfResponse`](struct.PrintToPdfResponse.html)"]
    pub struct PrintToPdfResponse<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded pdf data."]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for PrintToPdfResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.printToPDF";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for PrintToPdfCommand<'a> {
        type Response = PrintToPdfResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for PrintToPdfResponse<'b> {
        type Command = PrintToPdfCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Reloads given page optionally ignoring the cache.\n\n# Command `Page.reload`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ReloadCommand`](struct.ReloadCommand.html)  \n*Response Struct:* [`cdp::page::ReloadResponse`](struct.ReloadResponse.html)"]
    pub struct ReloadCommand<'a> {
        #[serde(rename = "ignoreCache", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, browser cache is ignored \\(as if the user pressed Shift+refresh\\)."]
        pub ignore_cache: Option<bool>,
        #[serde(rename = "scriptToEvaluateOnLoad", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, the script will be injected into all frames of the inspected page after reload.\nArgument will be ignored if reloading dataURL origin."]
        pub script_to_evaluate_on_load: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for ReloadCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.reload";
    }
    impl<'a> ::SerializeCdpCommand for ReloadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.reload"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReloadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.reload" {
                Ok(
                    <ReloadCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Reloads given page optionally ignoring the cache.\n\n# Command `Page.reload`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ReloadCommand`](struct.ReloadCommand.html)  \n*Response Struct:* [`cdp::page::ReloadResponse`](struct.ReloadResponse.html)"]
    pub struct ReloadResponse;
    impl ::serde::Serialize for ReloadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReloadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReloadResponse)
        }
    }
    impl ::CdpCommand for ReloadResponse {
        const COMMAND_NAME: &'static str = "Page.reload";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReloadCommand<'a> {
        type Response = ReloadResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReloadResponse {
        type Command = ReloadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.removeScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RemoveScriptToEvaluateOnLoadCommand`](struct.RemoveScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::page::RemoveScriptToEvaluateOnLoadResponse`](struct.RemoveScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use removeScriptToEvaluateOnNewDocument instead.")]
    pub struct RemoveScriptToEvaluateOnLoadCommand<'a> {
        #[serde(rename = "identifier")]
        pub identifier: ::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::CdpCommand for RemoveScriptToEvaluateOnLoadCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.removeScriptToEvaluateOnLoad";
    }
    impl<'a> ::SerializeCdpCommand for RemoveScriptToEvaluateOnLoadCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.removeScriptToEvaluateOnLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveScriptToEvaluateOnLoadCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.removeScriptToEvaluateOnLoad" {
                Ok ( < RemoveScriptToEvaluateOnLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.removeScriptToEvaluateOnLoad`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RemoveScriptToEvaluateOnLoadCommand`](struct.RemoveScriptToEvaluateOnLoadCommand.html)  \n*Response Struct:* [`cdp::page::RemoveScriptToEvaluateOnLoadResponse`](struct.RemoveScriptToEvaluateOnLoadResponse.html)"]
    #[deprecated(note = "please use removeScriptToEvaluateOnNewDocument instead.")]
    pub struct RemoveScriptToEvaluateOnLoadResponse;
    impl ::serde::Serialize for RemoveScriptToEvaluateOnLoadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveScriptToEvaluateOnLoadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveScriptToEvaluateOnLoadResponse)
        }
    }
    impl ::CdpCommand for RemoveScriptToEvaluateOnLoadResponse {
        const COMMAND_NAME: &'static str = "Page.removeScriptToEvaluateOnLoad";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveScriptToEvaluateOnLoadCommand<'a> {
        type Response = RemoveScriptToEvaluateOnLoadResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveScriptToEvaluateOnLoadResponse {
        type Command = RemoveScriptToEvaluateOnLoadCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes given script from the list.\n\n# Command `Page.removeScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RemoveScriptToEvaluateOnNewDocumentCommand`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::page::RemoveScriptToEvaluateOnNewDocumentResponse`](struct.RemoveScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        #[serde(rename = "identifier")]
        pub identifier: ::page::ScriptIdentifier<'a>,
    }
    impl<'a> ::CdpCommand for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.removeScriptToEvaluateOnNewDocument";
    }
    impl<'a> ::SerializeCdpCommand for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.removeScriptToEvaluateOnNewDocument"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.removeScriptToEvaluateOnNewDocument" {
                Ok ( < RemoveScriptToEvaluateOnNewDocumentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes given script from the list.\n\n# Command `Page.removeScriptToEvaluateOnNewDocument`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RemoveScriptToEvaluateOnNewDocumentCommand`](struct.RemoveScriptToEvaluateOnNewDocumentCommand.html)  \n*Response Struct:* [`cdp::page::RemoveScriptToEvaluateOnNewDocumentResponse`](struct.RemoveScriptToEvaluateOnNewDocumentResponse.html)"]
    pub struct RemoveScriptToEvaluateOnNewDocumentResponse;
    impl ::serde::Serialize for RemoveScriptToEvaluateOnNewDocumentResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveScriptToEvaluateOnNewDocumentResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveScriptToEvaluateOnNewDocumentResponse)
        }
    }
    impl ::CdpCommand for RemoveScriptToEvaluateOnNewDocumentResponse {
        const COMMAND_NAME: &'static str = "Page.removeScriptToEvaluateOnNewDocument";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveScriptToEvaluateOnNewDocumentCommand<'a> {
        type Response = RemoveScriptToEvaluateOnNewDocumentResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveScriptToEvaluateOnNewDocumentResponse {
        type Command = RemoveScriptToEvaluateOnNewDocumentCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.requestAppBanner`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RequestAppBannerCommand`](struct.RequestAppBannerCommand.html)  \n*Response Struct:* [`cdp::page::RequestAppBannerResponse`](struct.RequestAppBannerResponse.html)"]
    pub struct RequestAppBannerCommand;
    impl ::serde::Serialize for RequestAppBannerCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestAppBannerCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestAppBannerCommand)
        }
    }
    impl ::CdpCommand for RequestAppBannerCommand {
        const COMMAND_NAME: &'static str = "Page.requestAppBanner";
    }
    impl ::SerializeCdpCommand for RequestAppBannerCommand {
        fn command_name(&self) -> &str {
            "Page.requestAppBanner"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RequestAppBannerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.requestAppBanner" {
                Ok ( < RequestAppBannerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Page.requestAppBanner`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::RequestAppBannerCommand`](struct.RequestAppBannerCommand.html)  \n*Response Struct:* [`cdp::page::RequestAppBannerResponse`](struct.RequestAppBannerResponse.html)"]
    pub struct RequestAppBannerResponse;
    impl ::serde::Serialize for RequestAppBannerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestAppBannerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestAppBannerResponse)
        }
    }
    impl ::CdpCommand for RequestAppBannerResponse {
        const COMMAND_NAME: &'static str = "Page.requestAppBanner";
    }
    impl<'b> ::HasCdpResponse<'b> for RequestAppBannerCommand {
        type Response = RequestAppBannerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RequestAppBannerResponse {
        type Command = RequestAppBannerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Acknowledges that a screencast frame has been received by the frontend.\n\n# Command `Page.screencastFrameAck`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ScreencastFrameAckCommand`](struct.ScreencastFrameAckCommand.html)  \n*Response Struct:* [`cdp::page::ScreencastFrameAckResponse`](struct.ScreencastFrameAckResponse.html)"]
    pub struct ScreencastFrameAckCommand {
        #[serde(rename = "sessionId")]
        #[doc = "Frame number."]
        pub session_id: i32,
    }
    impl ::CdpCommand for ScreencastFrameAckCommand {
        const COMMAND_NAME: &'static str = "Page.screencastFrameAck";
    }
    impl ::SerializeCdpCommand for ScreencastFrameAckCommand {
        fn command_name(&self) -> &str {
            "Page.screencastFrameAck"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ScreencastFrameAckCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastFrameAck" {
                Ok ( < ScreencastFrameAckCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Acknowledges that a screencast frame has been received by the frontend.\n\n# Command `Page.screencastFrameAck`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ScreencastFrameAckCommand`](struct.ScreencastFrameAckCommand.html)  \n*Response Struct:* [`cdp::page::ScreencastFrameAckResponse`](struct.ScreencastFrameAckResponse.html)"]
    pub struct ScreencastFrameAckResponse;
    impl ::serde::Serialize for ScreencastFrameAckResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScreencastFrameAckResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScreencastFrameAckResponse)
        }
    }
    impl ::CdpCommand for ScreencastFrameAckResponse {
        const COMMAND_NAME: &'static str = "Page.screencastFrameAck";
    }
    impl<'b> ::HasCdpResponse<'b> for ScreencastFrameAckCommand {
        type Response = ScreencastFrameAckResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ScreencastFrameAckResponse {
        type Command = ScreencastFrameAckCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in resource content.\n\n# Command `Page.searchInResource`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SearchInResourceCommand`](struct.SearchInResourceCommand.html)  \n*Response Struct:* [`cdp::page::SearchInResourceResponse`](struct.SearchInResourceResponse.html)"]
    pub struct SearchInResourceCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id for resource to search in."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL of the resource to search in."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "query")]
        #[doc = "String to search for."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "caseSensitive", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, search is case sensitive."]
        pub case_sensitive: Option<bool>,
        #[serde(rename = "isRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, treats string parameter as regex."]
        pub is_regex: Option<bool>,
    }
    impl<'a> ::CdpCommand for SearchInResourceCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.searchInResource";
    }
    impl<'a> ::SerializeCdpCommand for SearchInResourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.searchInResource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SearchInResourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.searchInResource" {
                Ok ( < SearchInResourceCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Searches for given string in resource content.\n\n# Command `Page.searchInResource`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SearchInResourceCommand`](struct.SearchInResourceCommand.html)  \n*Response Struct:* [`cdp::page::SearchInResourceResponse`](struct.SearchInResourceResponse.html)"]
    pub struct SearchInResourceResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "List of search matches."]
        pub result: Vec<::debugger::SearchMatch<'a>>,
    }
    impl<'a> ::CdpCommand for SearchInResourceResponse<'a> {
        const COMMAND_NAME: &'static str = "Page.searchInResource";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SearchInResourceCommand<'a> {
        type Response = SearchInResourceResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SearchInResourceResponse<'b> {
        type Command = SearchInResourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable Chrome's experimental ad filter on all sites.\n\n# Command `Page.setAdBlockingEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetAdBlockingEnabledCommand`](struct.SetAdBlockingEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetAdBlockingEnabledResponse`](struct.SetAdBlockingEnabledResponse.html)"]
    pub struct SetAdBlockingEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether to block ads."]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetAdBlockingEnabledCommand {
        const COMMAND_NAME: &'static str = "Page.setAdBlockingEnabled";
    }
    impl ::SerializeCdpCommand for SetAdBlockingEnabledCommand {
        fn command_name(&self) -> &str {
            "Page.setAdBlockingEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetAdBlockingEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setAdBlockingEnabled" {
                Ok ( < SetAdBlockingEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable Chrome's experimental ad filter on all sites.\n\n# Command `Page.setAdBlockingEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetAdBlockingEnabledCommand`](struct.SetAdBlockingEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetAdBlockingEnabledResponse`](struct.SetAdBlockingEnabledResponse.html)"]
    pub struct SetAdBlockingEnabledResponse;
    impl ::serde::Serialize for SetAdBlockingEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAdBlockingEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAdBlockingEnabledResponse)
        }
    }
    impl ::CdpCommand for SetAdBlockingEnabledResponse {
        const COMMAND_NAME: &'static str = "Page.setAdBlockingEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetAdBlockingEnabledCommand {
        type Response = SetAdBlockingEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAdBlockingEnabledResponse {
        type Command = SetAdBlockingEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable page Content Security Policy by-passing.\n\n# Command `Page.setBypassCSP`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetBypassCspCommand`](struct.SetBypassCspCommand.html)  \n*Response Struct:* [`cdp::page::SetBypassCspResponse`](struct.SetBypassCspResponse.html)"]
    pub struct SetBypassCspCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether to bypass page CSP."]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetBypassCspCommand {
        const COMMAND_NAME: &'static str = "Page.setBypassCSP";
    }
    impl ::SerializeCdpCommand for SetBypassCspCommand {
        fn command_name(&self) -> &str {
            "Page.setBypassCSP"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetBypassCspCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setBypassCSP" {
                Ok(
                    <SetBypassCspCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable page Content Security Policy by-passing.\n\n# Command `Page.setBypassCSP`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetBypassCspCommand`](struct.SetBypassCspCommand.html)  \n*Response Struct:* [`cdp::page::SetBypassCspResponse`](struct.SetBypassCspResponse.html)"]
    pub struct SetBypassCspResponse;
    impl ::serde::Serialize for SetBypassCspResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBypassCspResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBypassCspResponse)
        }
    }
    impl ::CdpCommand for SetBypassCspResponse {
        const COMMAND_NAME: &'static str = "Page.setBypassCSP";
    }
    impl<'b> ::HasCdpResponse<'b> for SetBypassCspCommand {
        type Response = SetBypassCspResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBypassCspResponse {
        type Command = SetBypassCspCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results\\).\n\n# Command `Page.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    #[deprecated]
    pub struct SetDeviceMetricsOverrideCommand {
        #[serde(rename = "width")]
        #[doc = "Overriding width value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub width: i32,
        #[serde(rename = "height")]
        #[doc = "Overriding height value in pixels \\(minimum 0, maximum 10000000\\). 0 disables the override."]
        pub height: i32,
        #[serde(rename = "deviceScaleFactor")]
        #[doc = "Overriding device scale factor value. 0 disables the override."]
        pub device_scale_factor: f64,
        #[serde(rename = "mobile")]
        #[doc = "Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text\nautosizing and more."]
        pub mobile: bool,
        #[serde(rename = "scale", skip_serializing_if = "Option::is_none")]
        #[doc = "Scale to apply to resulting view image."]
        pub scale: Option<f64>,
        #[serde(rename = "screenWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding screen width value in pixels \\(minimum 0, maximum 10000000\\)."]
        pub screen_width: Option<i32>,
        #[serde(rename = "screenHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding screen height value in pixels \\(minimum 0, maximum 10000000\\)."]
        pub screen_height: Option<i32>,
        #[serde(rename = "positionX", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding view X position on screen in pixels \\(minimum 0, maximum 10000000\\)."]
        pub position_x: Option<i32>,
        #[serde(rename = "positionY", skip_serializing_if = "Option::is_none")]
        #[doc = "Overriding view Y position on screen in pixels \\(minimum 0, maximum 10000000\\)."]
        pub position_y: Option<i32>,
        #[serde(rename = "dontSetVisibleSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Do not set visible view size, rely upon explicit setVisibleSize call."]
        pub dont_set_visible_size: Option<bool>,
        #[serde(rename = "screenOrientation", skip_serializing_if = "Option::is_none")]
        #[doc = "Screen orientation override."]
        pub screen_orientation: Option<::emulation::ScreenOrientation>,
        #[serde(rename = "viewport", skip_serializing_if = "Option::is_none")]
        #[doc = "The viewport dimensions and scale. If not set, the override is cleared."]
        pub viewport: Option<::page::Viewport>,
    }
    impl ::CdpCommand for SetDeviceMetricsOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.setDeviceMetricsOverride";
    }
    impl ::SerializeCdpCommand for SetDeviceMetricsOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setDeviceMetricsOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDeviceMetricsOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDeviceMetricsOverride" {
                Ok ( < SetDeviceMetricsOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the values of device screen dimensions \\(window.screen.width, window.screen.height,\nwindow.innerWidth, window.innerHeight, and \"device-width\"/\"device-height\"-related CSS media\nquery results\\).\n\n# Command `Page.setDeviceMetricsOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDeviceMetricsOverrideCommand`](struct.SetDeviceMetricsOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetDeviceMetricsOverrideResponse`](struct.SetDeviceMetricsOverrideResponse.html)"]
    #[deprecated]
    pub struct SetDeviceMetricsOverrideResponse;
    impl ::serde::Serialize for SetDeviceMetricsOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceMetricsOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceMetricsOverrideResponse)
        }
    }
    impl ::CdpCommand for SetDeviceMetricsOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.setDeviceMetricsOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDeviceMetricsOverrideCommand {
        type Response = SetDeviceMetricsOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDeviceMetricsOverrideResponse {
        type Command = SetDeviceMetricsOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `Page.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    #[deprecated]
    pub struct SetDeviceOrientationOverrideCommand {
        #[serde(rename = "alpha")]
        #[doc = "Mock alpha"]
        pub alpha: f64,
        #[serde(rename = "beta")]
        #[doc = "Mock beta"]
        pub beta: f64,
        #[serde(rename = "gamma")]
        #[doc = "Mock gamma"]
        pub gamma: f64,
    }
    impl ::CdpCommand for SetDeviceOrientationOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.setDeviceOrientationOverride";
    }
    impl ::SerializeCdpCommand for SetDeviceOrientationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setDeviceOrientationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDeviceOrientationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDeviceOrientationOverride" {
                Ok ( < SetDeviceOrientationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Overrides the Device Orientation.\n\n# Command `Page.setDeviceOrientationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDeviceOrientationOverrideCommand`](struct.SetDeviceOrientationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetDeviceOrientationOverrideResponse`](struct.SetDeviceOrientationOverrideResponse.html)"]
    #[deprecated]
    pub struct SetDeviceOrientationOverrideResponse;
    impl ::serde::Serialize for SetDeviceOrientationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDeviceOrientationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDeviceOrientationOverrideResponse)
        }
    }
    impl ::CdpCommand for SetDeviceOrientationOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.setDeviceOrientationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDeviceOrientationOverrideCommand {
        type Response = SetDeviceOrientationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDeviceOrientationOverrideResponse {
        type Command = SetDeviceOrientationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set generic font families.\n\n# Command `Page.setFontFamilies`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetFontFamiliesCommand`](struct.SetFontFamiliesCommand.html)  \n*Response Struct:* [`cdp::page::SetFontFamiliesResponse`](struct.SetFontFamiliesResponse.html)"]
    pub struct SetFontFamiliesCommand<'a> {
        #[serde(rename = "fontFamilies")]
        #[doc = "Specifies font families to set. If a font family is not specified, it won't be changed."]
        pub font_families: ::page::FontFamilies<'a>,
    }
    impl<'a> ::CdpCommand for SetFontFamiliesCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.setFontFamilies";
    }
    impl<'a> ::SerializeCdpCommand for SetFontFamiliesCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.setFontFamilies"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetFontFamiliesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setFontFamilies" {
                Ok(
                    <SetFontFamiliesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set generic font families.\n\n# Command `Page.setFontFamilies`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetFontFamiliesCommand`](struct.SetFontFamiliesCommand.html)  \n*Response Struct:* [`cdp::page::SetFontFamiliesResponse`](struct.SetFontFamiliesResponse.html)"]
    pub struct SetFontFamiliesResponse;
    impl ::serde::Serialize for SetFontFamiliesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetFontFamiliesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetFontFamiliesResponse)
        }
    }
    impl ::CdpCommand for SetFontFamiliesResponse {
        const COMMAND_NAME: &'static str = "Page.setFontFamilies";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetFontFamiliesCommand<'a> {
        type Response = SetFontFamiliesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetFontFamiliesResponse {
        type Command = SetFontFamiliesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set default font sizes.\n\n# Command `Page.setFontSizes`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetFontSizesCommand`](struct.SetFontSizesCommand.html)  \n*Response Struct:* [`cdp::page::SetFontSizesResponse`](struct.SetFontSizesResponse.html)"]
    pub struct SetFontSizesCommand {
        #[serde(rename = "fontSizes")]
        #[doc = "Specifies font sizes to set. If a font size is not specified, it won't be changed."]
        pub font_sizes: ::page::FontSizes,
    }
    impl ::CdpCommand for SetFontSizesCommand {
        const COMMAND_NAME: &'static str = "Page.setFontSizes";
    }
    impl ::SerializeCdpCommand for SetFontSizesCommand {
        fn command_name(&self) -> &str {
            "Page.setFontSizes"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetFontSizesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setFontSizes" {
                Ok(
                    <SetFontSizesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set default font sizes.\n\n# Command `Page.setFontSizes`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetFontSizesCommand`](struct.SetFontSizesCommand.html)  \n*Response Struct:* [`cdp::page::SetFontSizesResponse`](struct.SetFontSizesResponse.html)"]
    pub struct SetFontSizesResponse;
    impl ::serde::Serialize for SetFontSizesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetFontSizesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetFontSizesResponse)
        }
    }
    impl ::CdpCommand for SetFontSizesResponse {
        const COMMAND_NAME: &'static str = "Page.setFontSizes";
    }
    impl<'b> ::HasCdpResponse<'b> for SetFontSizesCommand {
        type Response = SetFontSizesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetFontSizesResponse {
        type Command = SetFontSizesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets given markup as the document's HTML.\n\n# Command `Page.setDocumentContent`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDocumentContentCommand`](struct.SetDocumentContentCommand.html)  \n*Response Struct:* [`cdp::page::SetDocumentContentResponse`](struct.SetDocumentContentResponse.html)"]
    pub struct SetDocumentContentCommand<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Frame id to set HTML for."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "html")]
        #[doc = "HTML content to set."]
        pub html: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SetDocumentContentCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.setDocumentContent";
    }
    impl<'a> ::SerializeCdpCommand for SetDocumentContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.setDocumentContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetDocumentContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDocumentContent" {
                Ok ( < SetDocumentContentCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sets given markup as the document's HTML.\n\n# Command `Page.setDocumentContent`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDocumentContentCommand`](struct.SetDocumentContentCommand.html)  \n*Response Struct:* [`cdp::page::SetDocumentContentResponse`](struct.SetDocumentContentResponse.html)"]
    pub struct SetDocumentContentResponse;
    impl ::serde::Serialize for SetDocumentContentResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDocumentContentResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDocumentContentResponse)
        }
    }
    impl ::CdpCommand for SetDocumentContentResponse {
        const COMMAND_NAME: &'static str = "Page.setDocumentContent";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetDocumentContentCommand<'a> {
        type Response = SetDocumentContentResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDocumentContentResponse {
        type Command = SetDocumentContentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::page::SetDownloadBehaviorCommand::behavior`](struct.SetDownloadBehaviorCommand.html#structfield.behavior)."]
    pub enum SetDownloadBehaviorCommandBehavior {
        #[serde(rename = "deny")]
        #[doc = "Represented as `\"deny\"`."]
        Deny,
        #[serde(rename = "allow")]
        #[doc = "Represented as `\"allow\"`."]
        Allow,
        #[serde(rename = "default")]
        #[doc = "Represented as `\"default\"`."]
        Default,
    }
    impl SetDownloadBehaviorCommandBehavior {
        pub const ENUM_VALUES: &'static [SetDownloadBehaviorCommandBehavior] =
            &[
                SetDownloadBehaviorCommandBehavior::Deny,
                SetDownloadBehaviorCommandBehavior::Allow,
                SetDownloadBehaviorCommandBehavior::Default,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["deny", "allow", "default"];
    }
    impl ::std::str::FromStr for SetDownloadBehaviorCommandBehavior {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "deny" => Ok(SetDownloadBehaviorCommandBehavior::Deny),
                "allow" => Ok(SetDownloadBehaviorCommandBehavior::Allow),
                "default" => Ok(SetDownloadBehaviorCommandBehavior::Default),
                _ => Err(::ParseEnumError {
                    expected: SetDownloadBehaviorCommandBehavior::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetDownloadBehaviorCommandBehavior {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetDownloadBehaviorCommandBehavior::Deny => "deny",
                    SetDownloadBehaviorCommandBehavior::Allow => "allow",
                    SetDownloadBehaviorCommandBehavior::Default => "default",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set the behavior when downloading a file.\n\n# Command `Page.setDownloadBehavior`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDownloadBehaviorCommand`](struct.SetDownloadBehaviorCommand.html)  \n*Response Struct:* [`cdp::page::SetDownloadBehaviorResponse`](struct.SetDownloadBehaviorResponse.html)"]
    pub struct SetDownloadBehaviorCommand<'a> {
        #[serde(rename = "behavior")]
        #[doc = "Whether to allow all or deny all download requests, or use default Chrome behavior if\navailable \\(otherwise deny\\)."]
        pub behavior: ::page::SetDownloadBehaviorCommandBehavior,
        #[serde(rename = "downloadPath", skip_serializing_if = "Option::is_none")]
        #[doc = "The default path to save downloaded files to. This is requred if behavior is set to 'allow'"]
        pub download_path: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetDownloadBehaviorCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.setDownloadBehavior";
    }
    impl<'a> ::SerializeCdpCommand for SetDownloadBehaviorCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.setDownloadBehavior"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetDownloadBehaviorCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setDownloadBehavior" {
                Ok ( < SetDownloadBehaviorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Set the behavior when downloading a file.\n\n# Command `Page.setDownloadBehavior`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetDownloadBehaviorCommand`](struct.SetDownloadBehaviorCommand.html)  \n*Response Struct:* [`cdp::page::SetDownloadBehaviorResponse`](struct.SetDownloadBehaviorResponse.html)"]
    pub struct SetDownloadBehaviorResponse;
    impl ::serde::Serialize for SetDownloadBehaviorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDownloadBehaviorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDownloadBehaviorResponse)
        }
    }
    impl ::CdpCommand for SetDownloadBehaviorResponse {
        const COMMAND_NAME: &'static str = "Page.setDownloadBehavior";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetDownloadBehaviorCommand<'a> {
        type Response = SetDownloadBehaviorResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDownloadBehaviorResponse {
        type Command = SetDownloadBehaviorCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n\n# Command `Page.setGeolocationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    #[deprecated]
    pub struct SetGeolocationOverrideCommand {
        #[serde(rename = "latitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock latitude"]
        pub latitude: Option<f64>,
        #[serde(rename = "longitude", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock longitude"]
        pub longitude: Option<f64>,
        #[serde(rename = "accuracy", skip_serializing_if = "Option::is_none")]
        #[doc = "Mock accuracy"]
        pub accuracy: Option<f64>,
    }
    impl ::CdpCommand for SetGeolocationOverrideCommand {
        const COMMAND_NAME: &'static str = "Page.setGeolocationOverride";
    }
    impl ::SerializeCdpCommand for SetGeolocationOverrideCommand {
        fn command_name(&self) -> &str {
            "Page.setGeolocationOverride"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetGeolocationOverrideCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setGeolocationOverride" {
                Ok ( < SetGeolocationOverrideCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position\nunavailable.\n\n# Command `Page.setGeolocationOverride`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetGeolocationOverrideCommand`](struct.SetGeolocationOverrideCommand.html)  \n*Response Struct:* [`cdp::page::SetGeolocationOverrideResponse`](struct.SetGeolocationOverrideResponse.html)"]
    #[deprecated]
    pub struct SetGeolocationOverrideResponse;
    impl ::serde::Serialize for SetGeolocationOverrideResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetGeolocationOverrideResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetGeolocationOverrideResponse)
        }
    }
    impl ::CdpCommand for SetGeolocationOverrideResponse {
        const COMMAND_NAME: &'static str = "Page.setGeolocationOverride";
    }
    impl<'b> ::HasCdpResponse<'b> for SetGeolocationOverrideCommand {
        type Response = SetGeolocationOverrideResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetGeolocationOverrideResponse {
        type Command = SetGeolocationOverrideCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether page will emit lifecycle events.\n\n# Command `Page.setLifecycleEventsEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetLifecycleEventsEnabledCommand`](struct.SetLifecycleEventsEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetLifecycleEventsEnabledResponse`](struct.SetLifecycleEventsEnabledResponse.html)"]
    pub struct SetLifecycleEventsEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "If true, starts emitting lifecycle events."]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetLifecycleEventsEnabledCommand {
        const COMMAND_NAME: &'static str = "Page.setLifecycleEventsEnabled";
    }
    impl ::SerializeCdpCommand for SetLifecycleEventsEnabledCommand {
        fn command_name(&self) -> &str {
            "Page.setLifecycleEventsEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetLifecycleEventsEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setLifecycleEventsEnabled" {
                Ok ( < SetLifecycleEventsEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether page will emit lifecycle events.\n\n# Command `Page.setLifecycleEventsEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetLifecycleEventsEnabledCommand`](struct.SetLifecycleEventsEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetLifecycleEventsEnabledResponse`](struct.SetLifecycleEventsEnabledResponse.html)"]
    pub struct SetLifecycleEventsEnabledResponse;
    impl ::serde::Serialize for SetLifecycleEventsEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetLifecycleEventsEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetLifecycleEventsEnabledResponse)
        }
    }
    impl ::CdpCommand for SetLifecycleEventsEnabledResponse {
        const COMMAND_NAME: &'static str = "Page.setLifecycleEventsEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetLifecycleEventsEnabledCommand {
        type Response = SetLifecycleEventsEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetLifecycleEventsEnabledResponse {
        type Command = SetLifecycleEventsEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::page::SetTouchEmulationEnabledCommand::configuration`](struct.SetTouchEmulationEnabledCommand.html#structfield.configuration)."]
    #[deprecated]
    pub enum SetTouchEmulationEnabledCommandConfiguration {
        #[serde(rename = "mobile")]
        #[doc = "Represented as `\"mobile\"`."]
        Mobile,
        #[serde(rename = "desktop")]
        #[doc = "Represented as `\"desktop\"`."]
        Desktop,
    }
    impl SetTouchEmulationEnabledCommandConfiguration {
        pub const ENUM_VALUES: &'static [SetTouchEmulationEnabledCommandConfiguration] =
            &[
                SetTouchEmulationEnabledCommandConfiguration::Mobile,
                SetTouchEmulationEnabledCommandConfiguration::Desktop,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["mobile", "desktop"];
    }
    impl ::std::str::FromStr for SetTouchEmulationEnabledCommandConfiguration {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "mobile" => Ok(SetTouchEmulationEnabledCommandConfiguration::Mobile),
                "desktop" => Ok(SetTouchEmulationEnabledCommandConfiguration::Desktop),
                _ => Err(::ParseEnumError {
                    expected: SetTouchEmulationEnabledCommandConfiguration::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetTouchEmulationEnabledCommandConfiguration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetTouchEmulationEnabledCommandConfiguration::Mobile => "mobile",
                    SetTouchEmulationEnabledCommandConfiguration::Desktop => "desktop",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles mouse event-based touch event emulation.\n\n# Command `Page.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    #[deprecated]
    pub struct SetTouchEmulationEnabledCommand {
        #[serde(rename = "enabled")]
        #[doc = "Whether the touch event emulation should be enabled."]
        pub enabled: bool,
        #[serde(rename = "configuration", skip_serializing_if = "Option::is_none")]
        #[doc = "Touch/gesture events configuration. Default: current platform."]
        pub configuration: Option<::page::SetTouchEmulationEnabledCommandConfiguration>,
    }
    impl ::CdpCommand for SetTouchEmulationEnabledCommand {
        const COMMAND_NAME: &'static str = "Page.setTouchEmulationEnabled";
    }
    impl ::SerializeCdpCommand for SetTouchEmulationEnabledCommand {
        fn command_name(&self) -> &str {
            "Page.setTouchEmulationEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetTouchEmulationEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setTouchEmulationEnabled" {
                Ok ( < SetTouchEmulationEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Toggles mouse event-based touch event emulation.\n\n# Command `Page.setTouchEmulationEnabled`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetTouchEmulationEnabledCommand`](struct.SetTouchEmulationEnabledCommand.html)  \n*Response Struct:* [`cdp::page::SetTouchEmulationEnabledResponse`](struct.SetTouchEmulationEnabledResponse.html)"]
    #[deprecated]
    pub struct SetTouchEmulationEnabledResponse;
    impl ::serde::Serialize for SetTouchEmulationEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetTouchEmulationEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetTouchEmulationEnabledResponse)
        }
    }
    impl ::CdpCommand for SetTouchEmulationEnabledResponse {
        const COMMAND_NAME: &'static str = "Page.setTouchEmulationEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetTouchEmulationEnabledCommand {
        type Response = SetTouchEmulationEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetTouchEmulationEnabledResponse {
        type Command = SetTouchEmulationEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::page::StartScreencastCommand::format`](struct.StartScreencastCommand.html#structfield.format)."]
    pub enum StartScreencastCommandFormat {
        #[serde(rename = "jpeg")]
        #[doc = "Represented as `\"jpeg\"`."]
        Jpeg,
        #[serde(rename = "png")]
        #[doc = "Represented as `\"png\"`."]
        Png,
    }
    impl StartScreencastCommandFormat {
        pub const ENUM_VALUES: &'static [StartScreencastCommandFormat] =
            &[
                StartScreencastCommandFormat::Jpeg,
                StartScreencastCommandFormat::Png,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["jpeg", "png"];
    }
    impl ::std::str::FromStr for StartScreencastCommandFormat {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "jpeg" => Ok(StartScreencastCommandFormat::Jpeg),
                "png" => Ok(StartScreencastCommandFormat::Png),
                _ => Err(::ParseEnumError {
                    expected: StartScreencastCommandFormat::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StartScreencastCommandFormat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StartScreencastCommandFormat::Jpeg => "jpeg",
                    StartScreencastCommandFormat::Png => "png",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Starts sending each frame using the `screencastFrame` event.\n\n# Command `Page.startScreencast`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StartScreencastCommand`](struct.StartScreencastCommand.html)  \n*Response Struct:* [`cdp::page::StartScreencastResponse`](struct.StartScreencastResponse.html)"]
    pub struct StartScreencastCommand {
        #[serde(rename = "format", skip_serializing_if = "Option::is_none")]
        #[doc = "Image compression format."]
        pub format: Option<::page::StartScreencastCommandFormat>,
        #[serde(rename = "quality", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression quality from range \\[0..100\\]."]
        pub quality: Option<i32>,
        #[serde(rename = "maxWidth", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum screenshot width."]
        pub max_width: Option<i32>,
        #[serde(rename = "maxHeight", skip_serializing_if = "Option::is_none")]
        #[doc = "Maximum screenshot height."]
        pub max_height: Option<i32>,
        #[serde(rename = "everyNthFrame", skip_serializing_if = "Option::is_none")]
        #[doc = "Send every n-th frame."]
        pub every_nth_frame: Option<i32>,
    }
    impl ::CdpCommand for StartScreencastCommand {
        const COMMAND_NAME: &'static str = "Page.startScreencast";
    }
    impl ::SerializeCdpCommand for StartScreencastCommand {
        fn command_name(&self) -> &str {
            "Page.startScreencast"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartScreencastCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.startScreencast" {
                Ok(
                    <StartScreencastCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Starts sending each frame using the `screencastFrame` event.\n\n# Command `Page.startScreencast`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StartScreencastCommand`](struct.StartScreencastCommand.html)  \n*Response Struct:* [`cdp::page::StartScreencastResponse`](struct.StartScreencastResponse.html)"]
    pub struct StartScreencastResponse;
    impl ::serde::Serialize for StartScreencastResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartScreencastResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartScreencastResponse)
        }
    }
    impl ::CdpCommand for StartScreencastResponse {
        const COMMAND_NAME: &'static str = "Page.startScreencast";
    }
    impl<'b> ::HasCdpResponse<'b> for StartScreencastCommand {
        type Response = StartScreencastResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartScreencastResponse {
        type Command = StartScreencastCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Force the page stop all navigations and pending resource fetches.\n\n# Command `Page.stopLoading`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StopLoadingCommand`](struct.StopLoadingCommand.html)  \n*Response Struct:* [`cdp::page::StopLoadingResponse`](struct.StopLoadingResponse.html)"]
    pub struct StopLoadingCommand;
    impl ::serde::Serialize for StopLoadingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopLoadingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopLoadingCommand)
        }
    }
    impl ::CdpCommand for StopLoadingCommand {
        const COMMAND_NAME: &'static str = "Page.stopLoading";
    }
    impl ::SerializeCdpCommand for StopLoadingCommand {
        fn command_name(&self) -> &str {
            "Page.stopLoading"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopLoadingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.stopLoading" {
                Ok(
                    <StopLoadingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Force the page stop all navigations and pending resource fetches.\n\n# Command `Page.stopLoading`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StopLoadingCommand`](struct.StopLoadingCommand.html)  \n*Response Struct:* [`cdp::page::StopLoadingResponse`](struct.StopLoadingResponse.html)"]
    pub struct StopLoadingResponse;
    impl ::serde::Serialize for StopLoadingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopLoadingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopLoadingResponse)
        }
    }
    impl ::CdpCommand for StopLoadingResponse {
        const COMMAND_NAME: &'static str = "Page.stopLoading";
    }
    impl<'b> ::HasCdpResponse<'b> for StopLoadingCommand {
        type Response = StopLoadingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopLoadingResponse {
        type Command = StopLoadingCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Crashes renderer on the IO thread, generates minidumps.\n\n# Command `Page.crash`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CrashCommand`](struct.CrashCommand.html)  \n*Response Struct:* [`cdp::page::CrashResponse`](struct.CrashResponse.html)"]
    pub struct CrashCommand;
    impl ::serde::Serialize for CrashCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CrashCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CrashCommand)
        }
    }
    impl ::CdpCommand for CrashCommand {
        const COMMAND_NAME: &'static str = "Page.crash";
    }
    impl ::SerializeCdpCommand for CrashCommand {
        fn command_name(&self) -> &str {
            "Page.crash"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CrashCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.crash" {
                Ok(
                    <CrashCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Crashes renderer on the IO thread, generates minidumps.\n\n# Command `Page.crash`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CrashCommand`](struct.CrashCommand.html)  \n*Response Struct:* [`cdp::page::CrashResponse`](struct.CrashResponse.html)"]
    pub struct CrashResponse;
    impl ::serde::Serialize for CrashResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CrashResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CrashResponse)
        }
    }
    impl ::CdpCommand for CrashResponse {
        const COMMAND_NAME: &'static str = "Page.crash";
    }
    impl<'b> ::HasCdpResponse<'b> for CrashCommand {
        type Response = CrashResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CrashResponse {
        type Command = CrashCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tries to close page, running its beforeunload hooks, if any.\n\n# Command `Page.close`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::page::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseCommand;
    impl ::serde::Serialize for CloseCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CloseCommand)
        }
    }
    impl ::CdpCommand for CloseCommand {
        const COMMAND_NAME: &'static str = "Page.close";
    }
    impl ::SerializeCdpCommand for CloseCommand {
        fn command_name(&self) -> &str {
            "Page.close"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CloseCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.close" {
                Ok(
                    <CloseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tries to close page, running its beforeunload hooks, if any.\n\n# Command `Page.close`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::CloseCommand`](struct.CloseCommand.html)  \n*Response Struct:* [`cdp::page::CloseResponse`](struct.CloseResponse.html)"]
    pub struct CloseResponse;
    impl ::serde::Serialize for CloseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CloseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| CloseResponse)
        }
    }
    impl ::CdpCommand for CloseResponse {
        const COMMAND_NAME: &'static str = "Page.close";
    }
    impl<'b> ::HasCdpResponse<'b> for CloseCommand {
        type Response = CloseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CloseResponse {
        type Command = CloseCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::page::SetWebLifecycleStateCommand::state`](struct.SetWebLifecycleStateCommand.html#structfield.state)."]
    pub enum SetWebLifecycleStateCommandState {
        #[serde(rename = "frozen")]
        #[doc = "Represented as `\"frozen\"`."]
        Frozen,
        #[serde(rename = "active")]
        #[doc = "Represented as `\"active\"`."]
        Active,
    }
    impl SetWebLifecycleStateCommandState {
        pub const ENUM_VALUES: &'static [SetWebLifecycleStateCommandState] =
            &[
                SetWebLifecycleStateCommandState::Frozen,
                SetWebLifecycleStateCommandState::Active,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["frozen", "active"];
    }
    impl ::std::str::FromStr for SetWebLifecycleStateCommandState {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "frozen" => Ok(SetWebLifecycleStateCommandState::Frozen),
                "active" => Ok(SetWebLifecycleStateCommandState::Active),
                _ => Err(::ParseEnumError {
                    expected: SetWebLifecycleStateCommandState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetWebLifecycleStateCommandState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetWebLifecycleStateCommandState::Frozen => "frozen",
                    SetWebLifecycleStateCommandState::Active => "active",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tries to update the web lifecycle state of the page.\nIt will transition the page to the given state according to:\nhttps://github.com/WICG/web-lifecycle/\n\n# Command `Page.setWebLifecycleState`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetWebLifecycleStateCommand`](struct.SetWebLifecycleStateCommand.html)  \n*Response Struct:* [`cdp::page::SetWebLifecycleStateResponse`](struct.SetWebLifecycleStateResponse.html)"]
    pub struct SetWebLifecycleStateCommand {
        #[serde(rename = "state")]
        #[doc = "Target lifecycle state"]
        pub state: ::page::SetWebLifecycleStateCommandState,
    }
    impl ::CdpCommand for SetWebLifecycleStateCommand {
        const COMMAND_NAME: &'static str = "Page.setWebLifecycleState";
    }
    impl ::SerializeCdpCommand for SetWebLifecycleStateCommand {
        fn command_name(&self) -> &str {
            "Page.setWebLifecycleState"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetWebLifecycleStateCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setWebLifecycleState" {
                Ok ( < SetWebLifecycleStateCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Tries to update the web lifecycle state of the page.\nIt will transition the page to the given state according to:\nhttps://github.com/WICG/web-lifecycle/\n\n# Command `Page.setWebLifecycleState`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetWebLifecycleStateCommand`](struct.SetWebLifecycleStateCommand.html)  \n*Response Struct:* [`cdp::page::SetWebLifecycleStateResponse`](struct.SetWebLifecycleStateResponse.html)"]
    pub struct SetWebLifecycleStateResponse;
    impl ::serde::Serialize for SetWebLifecycleStateResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetWebLifecycleStateResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetWebLifecycleStateResponse)
        }
    }
    impl ::CdpCommand for SetWebLifecycleStateResponse {
        const COMMAND_NAME: &'static str = "Page.setWebLifecycleState";
    }
    impl<'b> ::HasCdpResponse<'b> for SetWebLifecycleStateCommand {
        type Response = SetWebLifecycleStateResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetWebLifecycleStateResponse {
        type Command = SetWebLifecycleStateCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stops sending each frame in the `screencastFrame`.\n\n# Command `Page.stopScreencast`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StopScreencastCommand`](struct.StopScreencastCommand.html)  \n*Response Struct:* [`cdp::page::StopScreencastResponse`](struct.StopScreencastResponse.html)"]
    pub struct StopScreencastCommand;
    impl ::serde::Serialize for StopScreencastCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopScreencastCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopScreencastCommand)
        }
    }
    impl ::CdpCommand for StopScreencastCommand {
        const COMMAND_NAME: &'static str = "Page.stopScreencast";
    }
    impl ::SerializeCdpCommand for StopScreencastCommand {
        fn command_name(&self) -> &str {
            "Page.stopScreencast"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopScreencastCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.stopScreencast" {
                Ok(
                    <StopScreencastCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stops sending each frame in the `screencastFrame`.\n\n# Command `Page.stopScreencast`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::StopScreencastCommand`](struct.StopScreencastCommand.html)  \n*Response Struct:* [`cdp::page::StopScreencastResponse`](struct.StopScreencastResponse.html)"]
    pub struct StopScreencastResponse;
    impl ::serde::Serialize for StopScreencastResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopScreencastResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopScreencastResponse)
        }
    }
    impl ::CdpCommand for StopScreencastResponse {
        const COMMAND_NAME: &'static str = "Page.stopScreencast";
    }
    impl<'b> ::HasCdpResponse<'b> for StopScreencastCommand {
        type Response = StopScreencastResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopScreencastResponse {
        type Command = StopScreencastCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Forces compilation cache to be generated for every subresource script.\n\n# Command `Page.setProduceCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetProduceCompilationCacheCommand`](struct.SetProduceCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::SetProduceCompilationCacheResponse`](struct.SetProduceCompilationCacheResponse.html)"]
    pub struct SetProduceCompilationCacheCommand {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetProduceCompilationCacheCommand {
        const COMMAND_NAME: &'static str = "Page.setProduceCompilationCache";
    }
    impl ::SerializeCdpCommand for SetProduceCompilationCacheCommand {
        fn command_name(&self) -> &str {
            "Page.setProduceCompilationCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetProduceCompilationCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.setProduceCompilationCache" {
                Ok ( < SetProduceCompilationCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Forces compilation cache to be generated for every subresource script.\n\n# Command `Page.setProduceCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::SetProduceCompilationCacheCommand`](struct.SetProduceCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::SetProduceCompilationCacheResponse`](struct.SetProduceCompilationCacheResponse.html)"]
    pub struct SetProduceCompilationCacheResponse;
    impl ::serde::Serialize for SetProduceCompilationCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetProduceCompilationCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetProduceCompilationCacheResponse)
        }
    }
    impl ::CdpCommand for SetProduceCompilationCacheResponse {
        const COMMAND_NAME: &'static str = "Page.setProduceCompilationCache";
    }
    impl<'b> ::HasCdpResponse<'b> for SetProduceCompilationCacheCommand {
        type Response = SetProduceCompilationCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetProduceCompilationCacheResponse {
        type Command = SetProduceCompilationCacheCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seeds compilation cache for given url. Compilation cache does not survive\ncross-process navigation.\n\n# Command `Page.addCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddCompilationCacheCommand`](struct.AddCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::AddCompilationCacheResponse`](struct.AddCompilationCacheResponse.html)"]
    pub struct AddCompilationCacheCommand<'a> {
        #[serde(rename = "url")]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        #[doc = "Base64-encoded data"]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for AddCompilationCacheCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.addCompilationCache";
    }
    impl<'a> ::SerializeCdpCommand for AddCompilationCacheCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.addCompilationCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddCompilationCacheCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.addCompilationCache" {
                Ok ( < AddCompilationCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Seeds compilation cache for given url. Compilation cache does not survive\ncross-process navigation.\n\n# Command `Page.addCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::AddCompilationCacheCommand`](struct.AddCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::AddCompilationCacheResponse`](struct.AddCompilationCacheResponse.html)"]
    pub struct AddCompilationCacheResponse;
    impl ::serde::Serialize for AddCompilationCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AddCompilationCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| AddCompilationCacheResponse)
        }
    }
    impl ::CdpCommand for AddCompilationCacheResponse {
        const COMMAND_NAME: &'static str = "Page.addCompilationCache";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddCompilationCacheCommand<'a> {
        type Response = AddCompilationCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for AddCompilationCacheResponse {
        type Command = AddCompilationCacheCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears seeded compilation cache.\n\n# Command `Page.clearCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearCompilationCacheCommand`](struct.ClearCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::ClearCompilationCacheResponse`](struct.ClearCompilationCacheResponse.html)"]
    pub struct ClearCompilationCacheCommand;
    impl ::serde::Serialize for ClearCompilationCacheCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearCompilationCacheCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearCompilationCacheCommand)
        }
    }
    impl ::CdpCommand for ClearCompilationCacheCommand {
        const COMMAND_NAME: &'static str = "Page.clearCompilationCache";
    }
    impl ::SerializeCdpCommand for ClearCompilationCacheCommand {
        fn command_name(&self) -> &str {
            "Page.clearCompilationCache"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearCompilationCacheCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.clearCompilationCache" {
                Ok ( < ClearCompilationCacheCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears seeded compilation cache.\n\n# Command `Page.clearCompilationCache`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::ClearCompilationCacheCommand`](struct.ClearCompilationCacheCommand.html)  \n*Response Struct:* [`cdp::page::ClearCompilationCacheResponse`](struct.ClearCompilationCacheResponse.html)"]
    pub struct ClearCompilationCacheResponse;
    impl ::serde::Serialize for ClearCompilationCacheResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearCompilationCacheResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearCompilationCacheResponse)
        }
    }
    impl ::CdpCommand for ClearCompilationCacheResponse {
        const COMMAND_NAME: &'static str = "Page.clearCompilationCache";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearCompilationCacheCommand {
        type Response = ClearCompilationCacheResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearCompilationCacheResponse {
        type Command = ClearCompilationCacheCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Generates a report for testing.\n\n# Command `Page.generateTestReport`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GenerateTestReportCommand`](struct.GenerateTestReportCommand.html)  \n*Response Struct:* [`cdp::page::GenerateTestReportResponse`](struct.GenerateTestReportResponse.html)"]
    pub struct GenerateTestReportCommand<'a> {
        #[serde(rename = "message")]
        #[doc = "Message to be displayed in the report."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "group", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies the endpoint group to deliver the report to."]
        pub group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GenerateTestReportCommand<'a> {
        const COMMAND_NAME: &'static str = "Page.generateTestReport";
    }
    impl<'a> ::SerializeCdpCommand for GenerateTestReportCommand<'a> {
        fn command_name(&self) -> &str {
            "Page.generateTestReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GenerateTestReportCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.generateTestReport" {
                Ok ( < GenerateTestReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Generates a report for testing.\n\n# Command `Page.generateTestReport`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Command Struct:* [`cdp::page::GenerateTestReportCommand`](struct.GenerateTestReportCommand.html)  \n*Response Struct:* [`cdp::page::GenerateTestReportResponse`](struct.GenerateTestReportResponse.html)"]
    pub struct GenerateTestReportResponse;
    impl ::serde::Serialize for GenerateTestReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GenerateTestReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GenerateTestReportResponse)
        }
    }
    impl ::CdpCommand for GenerateTestReportResponse {
        const COMMAND_NAME: &'static str = "Page.generateTestReport";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GenerateTestReportCommand<'a> {
        type Response = GenerateTestReportResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GenerateTestReportResponse {
        type Command = GenerateTestReportCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Page.domContentEventFired`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::DomContentEventFiredEvent`](struct.DomContentEventFiredEvent.html)"]
    pub struct DomContentEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: ::network::MonotonicTime,
    }
    impl ::CdpEvent for DomContentEventFiredEvent {
        const EVENT_NAME: &'static str = "Page.domContentEventFired";
    }
    impl ::SerializeCdpEvent for DomContentEventFiredEvent {
        fn event_name(&self) -> &str {
            "Page.domContentEventFired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for DomContentEventFiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.domContentEventFired" {
                Ok ( < DomContentEventFiredEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when frame has been attached to its parent.\n\n# Event `Page.frameAttached`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameAttachedEvent`](struct.FrameAttachedEvent.html)"]
    pub struct FrameAttachedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has been attached."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "parentFrameId")]
        #[doc = "Parent frame identifier."]
        pub parent_frame_id: ::page::FrameId<'a>,
        #[serde(rename = "stack", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript stack trace of when frame was attached, only set if frame initiated from script."]
        pub stack: Option<::runtime::StackTrace<'a>>,
    }
    impl<'a> ::CdpEvent for FrameAttachedEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameAttached";
    }
    impl<'a> ::SerializeCdpEvent for FrameAttachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameAttached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameAttachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameAttached" {
                Ok(
                    <FrameAttachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame no longer has a scheduled navigation.\n\n# Event `Page.frameClearedScheduledNavigation`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameClearedScheduledNavigationEvent`](struct.FrameClearedScheduledNavigationEvent.html)"]
    pub struct FrameClearedScheduledNavigationEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has cleared its scheduled navigation."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpEvent for FrameClearedScheduledNavigationEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameClearedScheduledNavigation";
    }
    impl<'a> ::SerializeCdpEvent for FrameClearedScheduledNavigationEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameClearedScheduledNavigation"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameClearedScheduledNavigationEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameClearedScheduledNavigation" {
                Ok ( < FrameClearedScheduledNavigationEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when frame has been detached from its parent.\n\n# Event `Page.frameDetached`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameDetachedEvent`](struct.FrameDetachedEvent.html)"]
    pub struct FrameDetachedEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has been detached."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpEvent for FrameDetachedEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameDetached";
    }
    impl<'a> ::SerializeCdpEvent for FrameDetachedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameDetached"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameDetachedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameDetached" {
                Ok(
                    <FrameDetachedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired once navigation of the frame has completed. Frame is now associated with the new loader.\n\n# Event `Page.frameNavigated`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameNavigatedEvent`](struct.FrameNavigatedEvent.html)"]
    pub struct FrameNavigatedEvent<'a> {
        #[serde(rename = "frame")]
        #[doc = "Frame object."]
        pub frame: ::page::Frame<'a>,
    }
    impl<'a> ::CdpEvent for FrameNavigatedEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameNavigated";
    }
    impl<'a> ::SerializeCdpEvent for FrameNavigatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameNavigated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameNavigatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameNavigated" {
                Ok(
                    <FrameNavigatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Page.frameResized`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameResizedEvent`](struct.FrameResizedEvent.html)"]
    pub struct FrameResizedEvent;
    impl ::serde::Serialize for FrameResizedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for FrameResizedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| FrameResizedEvent)
        }
    }
    impl ::CdpEvent for FrameResizedEvent {
        const EVENT_NAME: &'static str = "Page.frameResized";
    }
    impl ::SerializeCdpEvent for FrameResizedEvent {
        fn event_name(&self) -> &str {
            "Page.frameResized"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for FrameResizedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameResized" {
                Ok(
                    <FrameResizedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::page::FrameScheduledNavigationEvent::reason`](struct.FrameScheduledNavigationEvent.html#structfield.reason)."]
    pub enum FrameScheduledNavigationEventReason {
        #[serde(rename = "formSubmissionGet")]
        #[doc = "Represented as `\"formSubmissionGet\"`."]
        FormSubmissionGet,
        #[serde(rename = "formSubmissionPost")]
        #[doc = "Represented as `\"formSubmissionPost\"`."]
        FormSubmissionPost,
        #[serde(rename = "httpHeaderRefresh")]
        #[doc = "Represented as `\"httpHeaderRefresh\"`."]
        HttpHeaderRefresh,
        #[serde(rename = "scriptInitiated")]
        #[doc = "Represented as `\"scriptInitiated\"`."]
        ScriptInitiated,
        #[serde(rename = "metaTagRefresh")]
        #[doc = "Represented as `\"metaTagRefresh\"`."]
        MetaTagRefresh,
        #[serde(rename = "pageBlockInterstitial")]
        #[doc = "Represented as `\"pageBlockInterstitial\"`."]
        PageBlockInterstitial,
        #[serde(rename = "reload")]
        #[doc = "Represented as `\"reload\"`."]
        Reload,
    }
    impl FrameScheduledNavigationEventReason {
        pub const ENUM_VALUES: &'static [FrameScheduledNavigationEventReason] =
            &[
                FrameScheduledNavigationEventReason::FormSubmissionGet,
                FrameScheduledNavigationEventReason::FormSubmissionPost,
                FrameScheduledNavigationEventReason::HttpHeaderRefresh,
                FrameScheduledNavigationEventReason::ScriptInitiated,
                FrameScheduledNavigationEventReason::MetaTagRefresh,
                FrameScheduledNavigationEventReason::PageBlockInterstitial,
                FrameScheduledNavigationEventReason::Reload,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "formSubmissionGet",
            "formSubmissionPost",
            "httpHeaderRefresh",
            "scriptInitiated",
            "metaTagRefresh",
            "pageBlockInterstitial",
            "reload",
        ];
    }
    impl ::std::str::FromStr for FrameScheduledNavigationEventReason {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "formSubmissionGet" => Ok(FrameScheduledNavigationEventReason::FormSubmissionGet),
                "formSubmissionPost" => Ok(FrameScheduledNavigationEventReason::FormSubmissionPost),
                "httpHeaderRefresh" => Ok(FrameScheduledNavigationEventReason::HttpHeaderRefresh),
                "scriptInitiated" => Ok(FrameScheduledNavigationEventReason::ScriptInitiated),
                "metaTagRefresh" => Ok(FrameScheduledNavigationEventReason::MetaTagRefresh),
                "pageBlockInterstitial" => {
                    Ok(FrameScheduledNavigationEventReason::PageBlockInterstitial)
                }
                "reload" => Ok(FrameScheduledNavigationEventReason::Reload),
                _ => Err(::ParseEnumError {
                    expected: FrameScheduledNavigationEventReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for FrameScheduledNavigationEventReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    FrameScheduledNavigationEventReason::FormSubmissionGet => "formSubmissionGet",
                    FrameScheduledNavigationEventReason::FormSubmissionPost => "formSubmissionPost",
                    FrameScheduledNavigationEventReason::HttpHeaderRefresh => "httpHeaderRefresh",
                    FrameScheduledNavigationEventReason::ScriptInitiated => "scriptInitiated",
                    FrameScheduledNavigationEventReason::MetaTagRefresh => "metaTagRefresh",
                    FrameScheduledNavigationEventReason::PageBlockInterstitial => {
                        "pageBlockInterstitial"
                    }
                    FrameScheduledNavigationEventReason::Reload => "reload",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame schedules a potential navigation.\n\n# Event `Page.frameScheduledNavigation`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameScheduledNavigationEvent`](struct.FrameScheduledNavigationEvent.html)"]
    pub struct FrameScheduledNavigationEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has scheduled a navigation."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "delay")]
        #[doc = "Delay \\(in seconds\\) until the navigation is scheduled to begin. The navigation is not\nguaranteed to start."]
        pub delay: f64,
        #[serde(rename = "reason")]
        #[doc = "The reason for the navigation."]
        pub reason: ::page::FrameScheduledNavigationEventReason,
        #[serde(rename = "url")]
        #[doc = "The destination URL for the scheduled navigation."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for FrameScheduledNavigationEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameScheduledNavigation";
    }
    impl<'a> ::SerializeCdpEvent for FrameScheduledNavigationEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameScheduledNavigation"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameScheduledNavigationEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameScheduledNavigation" {
                Ok ( < FrameScheduledNavigationEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame has started loading.\n\n# Event `Page.frameStartedLoading`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameStartedLoadingEvent`](struct.FrameStartedLoadingEvent.html)"]
    pub struct FrameStartedLoadingEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has started loading."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpEvent for FrameStartedLoadingEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameStartedLoading";
    }
    impl<'a> ::SerializeCdpEvent for FrameStartedLoadingEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameStartedLoading"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameStartedLoadingEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameStartedLoading" {
                Ok ( < FrameStartedLoadingEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when frame has stopped loading.\n\n# Event `Page.frameStoppedLoading`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::FrameStoppedLoadingEvent`](struct.FrameStoppedLoadingEvent.html)"]
    pub struct FrameStoppedLoadingEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame that has stopped loading."]
        pub frame_id: ::page::FrameId<'a>,
    }
    impl<'a> ::CdpEvent for FrameStoppedLoadingEvent<'a> {
        const EVENT_NAME: &'static str = "Page.frameStoppedLoading";
    }
    impl<'a> ::SerializeCdpEvent for FrameStoppedLoadingEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.frameStoppedLoading"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for FrameStoppedLoadingEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.frameStoppedLoading" {
                Ok ( < FrameStoppedLoadingEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when interstitial page was hidden\n\n# Event `Page.interstitialHidden`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::InterstitialHiddenEvent`](struct.InterstitialHiddenEvent.html)"]
    pub struct InterstitialHiddenEvent;
    impl ::serde::Serialize for InterstitialHiddenEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InterstitialHiddenEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InterstitialHiddenEvent)
        }
    }
    impl ::CdpEvent for InterstitialHiddenEvent {
        const EVENT_NAME: &'static str = "Page.interstitialHidden";
    }
    impl ::SerializeCdpEvent for InterstitialHiddenEvent {
        fn event_name(&self) -> &str {
            "Page.interstitialHidden"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for InterstitialHiddenEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.interstitialHidden" {
                Ok ( < InterstitialHiddenEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when interstitial page was shown\n\n# Event `Page.interstitialShown`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::InterstitialShownEvent`](struct.InterstitialShownEvent.html)"]
    pub struct InterstitialShownEvent;
    impl ::serde::Serialize for InterstitialShownEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InterstitialShownEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InterstitialShownEvent)
        }
    }
    impl ::CdpEvent for InterstitialShownEvent {
        const EVENT_NAME: &'static str = "Page.interstitialShown";
    }
    impl ::SerializeCdpEvent for InterstitialShownEvent {
        fn event_name(&self) -> &str {
            "Page.interstitialShown"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for InterstitialShownEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.interstitialShown" {
                Ok(
                    <InterstitialShownEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) has been\nclosed.\n\n# Event `Page.javascriptDialogClosed`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::JavascriptDialogClosedEvent`](struct.JavascriptDialogClosedEvent.html)"]
    pub struct JavascriptDialogClosedEvent<'a> {
        #[serde(rename = "result")]
        #[doc = "Whether dialog was confirmed."]
        pub result: bool,
        #[serde(rename = "userInput")]
        #[doc = "User input in case of prompt."]
        pub user_input: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for JavascriptDialogClosedEvent<'a> {
        const EVENT_NAME: &'static str = "Page.javascriptDialogClosed";
    }
    impl<'a> ::SerializeCdpEvent for JavascriptDialogClosedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.javascriptDialogClosed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for JavascriptDialogClosedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.javascriptDialogClosed" {
                Ok ( < JavascriptDialogClosedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a JavaScript initiated dialog \\(alert, confirm, prompt, or onbeforeunload\\) is about to\nopen.\n\n# Event `Page.javascriptDialogOpening`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::JavascriptDialogOpeningEvent`](struct.JavascriptDialogOpeningEvent.html)"]
    pub struct JavascriptDialogOpeningEvent<'a> {
        #[serde(rename = "url")]
        #[doc = "Frame url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "message")]
        #[doc = "Message that will be displayed by the dialog."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Dialog type."]
        pub ty: ::page::DialogType,
        #[serde(rename = "hasBrowserHandler")]
        #[doc = "True iff browser is capable showing or acting on the given dialog. When browser has no\ndialog handler for given target, calling alert while Page domain is engaged will stall\nthe page execution. Execution can be resumed via calling Page.handleJavaScriptDialog."]
        pub has_browser_handler: bool,
        #[serde(rename = "defaultPrompt", skip_serializing_if = "Option::is_none")]
        #[doc = "Default dialog prompt."]
        pub default_prompt: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpEvent for JavascriptDialogOpeningEvent<'a> {
        const EVENT_NAME: &'static str = "Page.javascriptDialogOpening";
    }
    impl<'a> ::SerializeCdpEvent for JavascriptDialogOpeningEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.javascriptDialogOpening"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for JavascriptDialogOpeningEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.javascriptDialogOpening" {
                Ok ( < JavascriptDialogOpeningEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired for top level page lifecycle events such as navigation, load, paint, etc.\n\n# Event `Page.lifecycleEvent`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::LifecycleEventEvent`](struct.LifecycleEventEvent.html)"]
    pub struct LifecycleEventEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "loaderId")]
        #[doc = "Loader identifier. Empty string if the request is fetched from worker."]
        pub loader_id: ::network::LoaderId<'a>,
        #[serde(rename = "name")]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "timestamp")]
        pub timestamp: ::network::MonotonicTime,
    }
    impl<'a> ::CdpEvent for LifecycleEventEvent<'a> {
        const EVENT_NAME: &'static str = "Page.lifecycleEvent";
    }
    impl<'a> ::SerializeCdpEvent for LifecycleEventEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.lifecycleEvent"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for LifecycleEventEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.lifecycleEvent" {
                Ok(
                    <LifecycleEventEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Page.loadEventFired`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::LoadEventFiredEvent`](struct.LoadEventFiredEvent.html)"]
    pub struct LoadEventFiredEvent {
        #[serde(rename = "timestamp")]
        pub timestamp: ::network::MonotonicTime,
    }
    impl ::CdpEvent for LoadEventFiredEvent {
        const EVENT_NAME: &'static str = "Page.loadEventFired";
    }
    impl ::SerializeCdpEvent for LoadEventFiredEvent {
        fn event_name(&self) -> &str {
            "Page.loadEventFired"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for LoadEventFiredEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.loadEventFired" {
                Ok(
                    <LoadEventFiredEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.\n\n# Event `Page.navigatedWithinDocument`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::NavigatedWithinDocumentEvent`](struct.NavigatedWithinDocumentEvent.html)"]
    pub struct NavigatedWithinDocumentEvent<'a> {
        #[serde(rename = "frameId")]
        #[doc = "Id of the frame."]
        pub frame_id: ::page::FrameId<'a>,
        #[serde(rename = "url")]
        #[doc = "Frame's new url."]
        pub url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for NavigatedWithinDocumentEvent<'a> {
        const EVENT_NAME: &'static str = "Page.navigatedWithinDocument";
    }
    impl<'a> ::SerializeCdpEvent for NavigatedWithinDocumentEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.navigatedWithinDocument"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for NavigatedWithinDocumentEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.navigatedWithinDocument" {
                Ok ( < NavigatedWithinDocumentEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Compressed image data requested by the `startScreencast`.\n\n# Event `Page.screencastFrame`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::ScreencastFrameEvent`](struct.ScreencastFrameEvent.html)"]
    pub struct ScreencastFrameEvent<'a> {
        #[serde(rename = "data")]
        #[doc = "Base64-encoded compressed image."]
        pub data: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "metadata")]
        #[doc = "Screencast frame metadata."]
        pub metadata: ::page::ScreencastFrameMetadata,
        #[serde(rename = "sessionId")]
        #[doc = "Frame number."]
        pub session_id: i32,
    }
    impl<'a> ::CdpEvent for ScreencastFrameEvent<'a> {
        const EVENT_NAME: &'static str = "Page.screencastFrame";
    }
    impl<'a> ::SerializeCdpEvent for ScreencastFrameEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.screencastFrame"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ScreencastFrameEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastFrame" {
                Ok(
                    <ScreencastFrameEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Fired when the page with currently enabled screencast was shown or hidden `.\n\n# Event `Page.screencastVisibilityChanged`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::ScreencastVisibilityChangedEvent`](struct.ScreencastVisibilityChangedEvent.html)"]
    pub struct ScreencastVisibilityChangedEvent {
        #[serde(rename = "visible")]
        #[doc = "True if the page is visible."]
        pub visible: bool,
    }
    impl ::CdpEvent for ScreencastVisibilityChangedEvent {
        const EVENT_NAME: &'static str = "Page.screencastVisibilityChanged";
    }
    impl ::SerializeCdpEvent for ScreencastVisibilityChangedEvent {
        fn event_name(&self) -> &str {
            "Page.screencastVisibilityChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ScreencastVisibilityChangedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.screencastVisibilityChanged" {
                Ok ( < ScreencastVisibilityChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when a new window is going to be opened, via window.open\\(\\), link click, form submission,\netc.\n\n# Event `Page.windowOpen`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::WindowOpenEvent`](struct.WindowOpenEvent.html)"]
    pub struct WindowOpenEvent<'a> {
        #[serde(rename = "url")]
        #[doc = "The URL for the new window."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "windowName")]
        #[doc = "Window name."]
        pub window_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "windowFeatures")]
        #[doc = "An array of enabled window features."]
        pub window_features: Vec<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "userGesture")]
        #[doc = "Whether or not it was triggered by user gesture."]
        pub user_gesture: bool,
    }
    impl<'a> ::CdpEvent for WindowOpenEvent<'a> {
        const EVENT_NAME: &'static str = "Page.windowOpen";
    }
    impl<'a> ::SerializeCdpEvent for WindowOpenEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.windowOpen"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WindowOpenEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.windowOpen" {
                Ok(
                    <WindowOpenEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued for every compilation cache generated. Is only available\nif Page.setGenerateCompilationCache is enabled.\n\n# Event `Page.compilationCacheProduced`\n\n*Domain Module:* [`cdp::page`](index.html)  \n*Event Struct:* [`cdp::page::CompilationCacheProducedEvent`](struct.CompilationCacheProducedEvent.html)"]
    pub struct CompilationCacheProducedEvent<'a> {
        #[serde(rename = "url")]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        #[doc = "Base64-encoded data"]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for CompilationCacheProducedEvent<'a> {
        const EVENT_NAME: &'static str = "Page.compilationCacheProduced";
    }
    impl<'a> ::SerializeCdpEvent for CompilationCacheProducedEvent<'a> {
        fn event_name(&self) -> &str {
            "Page.compilationCacheProduced"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for CompilationCacheProducedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Page.compilationCacheProduced" {
                Ok ( < CompilationCacheProducedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique frame identifier."]
    pub type FrameId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the Frame on the page."]
    pub struct Frame<'a> {
        #[serde(rename = "id")]
        #[doc = "Frame unique identifier."]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "parentId", skip_serializing_if = "Option::is_none")]
        #[doc = "Parent frame identifier."]
        pub parent_id: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "loaderId")]
        #[doc = "Identifier of the loader associated with this frame."]
        pub loader_id: ::network::LoaderId<'a>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame's name as specified in the tag."]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "url")]
        #[doc = "Frame document's URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "securityOrigin")]
        #[doc = "Frame document's security origin."]
        pub security_origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "mimeType")]
        #[doc = "Frame document's mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "unreachableUrl", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> If the frame failed to load, this contains the URL that could not be loaded."]
        pub unreachable_url: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about the Resource on the page."]
    pub struct FrameResource<'a> {
        #[serde(rename = "url")]
        #[doc = "Resource URL."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Type of this resource."]
        pub ty: ::network::ResourceType,
        #[serde(rename = "mimeType")]
        #[doc = "Resource mimeType as determined by the browser."]
        pub mime_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lastModified", skip_serializing_if = "Option::is_none")]
        #[doc = "last-modified timestamp as reported by server."]
        pub last_modified: Option<::network::TimeSinceEpoch>,
        #[serde(rename = "contentSize", skip_serializing_if = "Option::is_none")]
        #[doc = "Resource content size."]
        pub content_size: Option<f64>,
        #[serde(rename = "failed", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the resource failed to load."]
        pub failed: Option<bool>,
        #[serde(rename = "canceled", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the resource was canceled during loading."]
        pub canceled: Option<bool>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Information about the Frame hierarchy along with their cached resources."]
    pub struct FrameResourceTree<'a> {
        #[serde(rename = "frame")]
        #[doc = "Frame information for this tree item."]
        pub frame: ::page::Frame<'a>,
        #[serde(rename = "childFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "Child frames."]
        pub child_frames: Option<Vec<Box<::page::FrameResourceTree<'a>>>>,
        #[serde(rename = "resources")]
        #[doc = "Information about frame resources."]
        pub resources: Vec<::page::FrameResource<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about the Frame hierarchy."]
    pub struct FrameTree<'a> {
        #[serde(rename = "frame")]
        #[doc = "Frame information for this tree item."]
        pub frame: ::page::Frame<'a>,
        #[serde(rename = "childFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "Child frames."]
        pub child_frames: Option<Vec<Box<::page::FrameTree<'a>>>>,
    }
    #[doc = "Unique script identifier."]
    pub type ScriptIdentifier<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Transition type."]
    pub enum TransitionType {
        #[serde(rename = "link")]
        #[doc = "Represented as `\"link\"`."]
        Link,
        #[serde(rename = "typed")]
        #[doc = "Represented as `\"typed\"`."]
        Typed,
        #[serde(rename = "address_bar")]
        #[doc = "Represented as `\"address_bar\"`."]
        AddressBar,
        #[serde(rename = "auto_bookmark")]
        #[doc = "Represented as `\"auto_bookmark\"`."]
        AutoBookmark,
        #[serde(rename = "auto_subframe")]
        #[doc = "Represented as `\"auto_subframe\"`."]
        AutoSubframe,
        #[serde(rename = "manual_subframe")]
        #[doc = "Represented as `\"manual_subframe\"`."]
        ManualSubframe,
        #[serde(rename = "generated")]
        #[doc = "Represented as `\"generated\"`."]
        Generated,
        #[serde(rename = "auto_toplevel")]
        #[doc = "Represented as `\"auto_toplevel\"`."]
        AutoToplevel,
        #[serde(rename = "form_submit")]
        #[doc = "Represented as `\"form_submit\"`."]
        FormSubmit,
        #[serde(rename = "reload")]
        #[doc = "Represented as `\"reload\"`."]
        Reload,
        #[serde(rename = "keyword")]
        #[doc = "Represented as `\"keyword\"`."]
        Keyword,
        #[serde(rename = "keyword_generated")]
        #[doc = "Represented as `\"keyword_generated\"`."]
        KeywordGenerated,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl TransitionType {
        pub const ENUM_VALUES: &'static [TransitionType] = &[
            TransitionType::Link,
            TransitionType::Typed,
            TransitionType::AddressBar,
            TransitionType::AutoBookmark,
            TransitionType::AutoSubframe,
            TransitionType::ManualSubframe,
            TransitionType::Generated,
            TransitionType::AutoToplevel,
            TransitionType::FormSubmit,
            TransitionType::Reload,
            TransitionType::Keyword,
            TransitionType::KeywordGenerated,
            TransitionType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "link",
            "typed",
            "address_bar",
            "auto_bookmark",
            "auto_subframe",
            "manual_subframe",
            "generated",
            "auto_toplevel",
            "form_submit",
            "reload",
            "keyword",
            "keyword_generated",
            "other",
        ];
    }
    impl ::std::str::FromStr for TransitionType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "link" => Ok(TransitionType::Link),
                "typed" => Ok(TransitionType::Typed),
                "address_bar" => Ok(TransitionType::AddressBar),
                "auto_bookmark" => Ok(TransitionType::AutoBookmark),
                "auto_subframe" => Ok(TransitionType::AutoSubframe),
                "manual_subframe" => Ok(TransitionType::ManualSubframe),
                "generated" => Ok(TransitionType::Generated),
                "auto_toplevel" => Ok(TransitionType::AutoToplevel),
                "form_submit" => Ok(TransitionType::FormSubmit),
                "reload" => Ok(TransitionType::Reload),
                "keyword" => Ok(TransitionType::Keyword),
                "keyword_generated" => Ok(TransitionType::KeywordGenerated),
                "other" => Ok(TransitionType::Other),
                _ => Err(::ParseEnumError {
                    expected: TransitionType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for TransitionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    TransitionType::Link => "link",
                    TransitionType::Typed => "typed",
                    TransitionType::AddressBar => "address_bar",
                    TransitionType::AutoBookmark => "auto_bookmark",
                    TransitionType::AutoSubframe => "auto_subframe",
                    TransitionType::ManualSubframe => "manual_subframe",
                    TransitionType::Generated => "generated",
                    TransitionType::AutoToplevel => "auto_toplevel",
                    TransitionType::FormSubmit => "form_submit",
                    TransitionType::Reload => "reload",
                    TransitionType::Keyword => "keyword",
                    TransitionType::KeywordGenerated => "keyword_generated",
                    TransitionType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Navigation history entry."]
    pub struct NavigationEntry<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the navigation history entry."]
        pub id: i32,
        #[serde(rename = "url")]
        #[doc = "URL of the navigation history entry."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "userTypedURL")]
        #[doc = "URL that the user typed in the url bar."]
        pub user_typed_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "title")]
        #[doc = "Title of the navigation history entry."]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "transitionType")]
        #[doc = "Transition type."]
        pub transition_type: ::page::TransitionType,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Screencast frame metadata."]
    pub struct ScreencastFrameMetadata {
        #[serde(rename = "offsetTop")]
        #[doc = "Top offset in DIP."]
        pub offset_top: f64,
        #[serde(rename = "pageScaleFactor")]
        #[doc = "Page scale factor."]
        pub page_scale_factor: f64,
        #[serde(rename = "deviceWidth")]
        #[doc = "Device screen width in DIP."]
        pub device_width: f64,
        #[serde(rename = "deviceHeight")]
        #[doc = "Device screen height in DIP."]
        pub device_height: f64,
        #[serde(rename = "scrollOffsetX")]
        #[doc = "Position of horizontal scroll in CSS pixels."]
        pub scroll_offset_x: f64,
        #[serde(rename = "scrollOffsetY")]
        #[doc = "Position of vertical scroll in CSS pixels."]
        pub scroll_offset_y: f64,
        #[serde(rename = "timestamp", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame swap timestamp."]
        pub timestamp: Option<::network::TimeSinceEpoch>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Javascript dialog type."]
    pub enum DialogType {
        #[serde(rename = "alert")]
        #[doc = "Represented as `\"alert\"`."]
        Alert,
        #[serde(rename = "confirm")]
        #[doc = "Represented as `\"confirm\"`."]
        Confirm,
        #[serde(rename = "prompt")]
        #[doc = "Represented as `\"prompt\"`."]
        Prompt,
        #[serde(rename = "beforeunload")]
        #[doc = "Represented as `\"beforeunload\"`."]
        Beforeunload,
    }
    impl DialogType {
        pub const ENUM_VALUES: &'static [DialogType] = &[
            DialogType::Alert,
            DialogType::Confirm,
            DialogType::Prompt,
            DialogType::Beforeunload,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["alert", "confirm", "prompt", "beforeunload"];
    }
    impl ::std::str::FromStr for DialogType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "alert" => Ok(DialogType::Alert),
                "confirm" => Ok(DialogType::Confirm),
                "prompt" => Ok(DialogType::Prompt),
                "beforeunload" => Ok(DialogType::Beforeunload),
                _ => Err(::ParseEnumError {
                    expected: DialogType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for DialogType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    DialogType::Alert => "alert",
                    DialogType::Confirm => "confirm",
                    DialogType::Prompt => "prompt",
                    DialogType::Beforeunload => "beforeunload",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Error while paring app manifest."]
    pub struct AppManifestError<'a> {
        #[serde(rename = "message")]
        #[doc = "Error message."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "critical")]
        #[doc = "If criticial, this is a non-recoverable parse error."]
        pub critical: i32,
        #[serde(rename = "line")]
        #[doc = "Error line."]
        pub line: i32,
        #[serde(rename = "column")]
        #[doc = "Error column."]
        pub column: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Layout viewport position and dimensions."]
    pub struct LayoutViewport {
        #[serde(rename = "pageX")]
        #[doc = "Horizontal offset relative to the document \\(CSS pixels\\)."]
        pub page_x: i32,
        #[serde(rename = "pageY")]
        #[doc = "Vertical offset relative to the document \\(CSS pixels\\)."]
        pub page_y: i32,
        #[serde(rename = "clientWidth")]
        #[doc = "Width \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_width: i32,
        #[serde(rename = "clientHeight")]
        #[doc = "Height \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_height: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Visual viewport position, dimensions, and scale."]
    pub struct VisualViewport {
        #[serde(rename = "offsetX")]
        #[doc = "Horizontal offset relative to the layout viewport \\(CSS pixels\\)."]
        pub offset_x: f64,
        #[serde(rename = "offsetY")]
        #[doc = "Vertical offset relative to the layout viewport \\(CSS pixels\\)."]
        pub offset_y: f64,
        #[serde(rename = "pageX")]
        #[doc = "Horizontal offset relative to the document \\(CSS pixels\\)."]
        pub page_x: f64,
        #[serde(rename = "pageY")]
        #[doc = "Vertical offset relative to the document \\(CSS pixels\\)."]
        pub page_y: f64,
        #[serde(rename = "clientWidth")]
        #[doc = "Width \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_width: f64,
        #[serde(rename = "clientHeight")]
        #[doc = "Height \\(CSS pixels\\), excludes scrollbar if present."]
        pub client_height: f64,
        #[serde(rename = "scale")]
        #[doc = "Scale relative to the ideal viewport \\(size at width=device-width\\)."]
        pub scale: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Viewport for capturing screenshot."]
    pub struct Viewport {
        #[serde(rename = "x")]
        #[doc = "X offset in CSS pixels."]
        pub x: f64,
        #[serde(rename = "y")]
        #[doc = "Y offset in CSS pixels"]
        pub y: f64,
        #[serde(rename = "width")]
        #[doc = "Rectangle width in CSS pixels"]
        pub width: f64,
        #[serde(rename = "height")]
        #[doc = "Rectangle height in CSS pixels"]
        pub height: f64,
        #[serde(rename = "scale")]
        #[doc = "Page scale factor."]
        pub scale: f64,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Generic font families collection."]
    pub struct FontFamilies<'a> {
        #[serde(rename = "standard", skip_serializing_if = "Option::is_none")]
        #[doc = "The standard font-family."]
        pub standard: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "fixed", skip_serializing_if = "Option::is_none")]
        #[doc = "The fixed font-family."]
        pub fixed: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "serif", skip_serializing_if = "Option::is_none")]
        #[doc = "The serif font-family."]
        pub serif: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "sansSerif", skip_serializing_if = "Option::is_none")]
        #[doc = "The sansSerif font-family."]
        pub sans_serif: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "cursive", skip_serializing_if = "Option::is_none")]
        #[doc = "The cursive font-family."]
        pub cursive: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "fantasy", skip_serializing_if = "Option::is_none")]
        #[doc = "The fantasy font-family."]
        pub fantasy: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "pictograph", skip_serializing_if = "Option::is_none")]
        #[doc = "The pictograph font-family."]
        pub pictograph: Option<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Default font sizes."]
    pub struct FontSizes {
        #[serde(rename = "standard", skip_serializing_if = "Option::is_none")]
        #[doc = "Default standard font size."]
        pub standard: Option<i32>,
        #[serde(rename = "fixed", skip_serializing_if = "Option::is_none")]
        #[doc = "Default fixed font size."]
        pub fixed: Option<i32>,
    }
}
#[doc = "# Performance\n\n## Commands\n\n- [`Performance.disable`](struct.DisableCommand.html)\n\n  Disable collecting and reporting metrics.\n- [`Performance.enable`](struct.EnableCommand.html)\n\n  Enable collecting and reporting metrics.\n- [`Performance.getMetrics`](struct.GetMetricsCommand.html)\n\n  Retrieve current values of run-time metrics.\n\n## Events\n\n- [`Performance.metrics`](struct.MetricsEvent.html)\n\n  Current values of the metrics.\n\n##Types\n\n- [`Metric`](struct.Metric.html)\n\n  Run-time execution metric.\n"]
pub mod performance {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disable collecting and reporting metrics.\n\n# Command `Performance.disable`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::performance::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Performance.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Performance.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Performance.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disable collecting and reporting metrics.\n\n# Command `Performance.disable`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::performance::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Performance.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enable collecting and reporting metrics.\n\n# Command `Performance.enable`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::performance::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Performance.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Performance.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Performance.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enable collecting and reporting metrics.\n\n# Command `Performance.enable`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::performance::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Performance.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Retrieve current values of run-time metrics.\n\n# Command `Performance.getMetrics`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::GetMetricsCommand`](struct.GetMetricsCommand.html)  \n*Response Struct:* [`cdp::performance::GetMetricsResponse`](struct.GetMetricsResponse.html)"]
    pub struct GetMetricsCommand;
    impl ::serde::Serialize for GetMetricsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetMetricsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetMetricsCommand)
        }
    }
    impl ::CdpCommand for GetMetricsCommand {
        const COMMAND_NAME: &'static str = "Performance.getMetrics";
    }
    impl ::SerializeCdpCommand for GetMetricsCommand {
        fn command_name(&self) -> &str {
            "Performance.getMetrics"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetMetricsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Performance.getMetrics" {
                Ok(
                    <GetMetricsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Retrieve current values of run-time metrics.\n\n# Command `Performance.getMetrics`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Command Struct:* [`cdp::performance::GetMetricsCommand`](struct.GetMetricsCommand.html)  \n*Response Struct:* [`cdp::performance::GetMetricsResponse`](struct.GetMetricsResponse.html)"]
    pub struct GetMetricsResponse<'a> {
        #[serde(rename = "metrics")]
        #[doc = "Current values for run-time metrics."]
        pub metrics: Vec<::performance::Metric<'a>>,
    }
    impl<'a> ::CdpCommand for GetMetricsResponse<'a> {
        const COMMAND_NAME: &'static str = "Performance.getMetrics";
    }
    impl<'b> ::HasCdpResponse<'b> for GetMetricsCommand {
        type Response = GetMetricsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetMetricsResponse<'b> {
        type Command = GetMetricsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Current values of the metrics.\n\n# Event `Performance.metrics`\n\n*Domain Module:* [`cdp::performance`](index.html)  \n*Event Struct:* [`cdp::performance::MetricsEvent`](struct.MetricsEvent.html)"]
    pub struct MetricsEvent<'a> {
        #[serde(rename = "metrics")]
        #[doc = "Current values of the metrics."]
        pub metrics: Vec<::performance::Metric<'a>>,
        #[serde(rename = "title")]
        #[doc = "Timestamp title."]
        pub title: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for MetricsEvent<'a> {
        const EVENT_NAME: &'static str = "Performance.metrics";
    }
    impl<'a> ::SerializeCdpEvent for MetricsEvent<'a> {
        fn event_name(&self) -> &str {
            "Performance.metrics"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for MetricsEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Performance.metrics" {
                Ok(
                    <MetricsEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Run-time execution metric."]
    pub struct Metric<'a> {
        #[serde(rename = "name")]
        #[doc = "Metric name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value")]
        #[doc = "Metric value."]
        pub value: f64,
    }
}
#[doc = "Security\n\n# Security\n\n## Commands\n\n- [`Security.disable`](struct.DisableCommand.html)\n\n  Disables tracking security state changes.\n- [`Security.enable`](struct.EnableCommand.html)\n\n  Enables tracking security state changes.\n- [`Security.setIgnoreCertificateErrors`](struct.SetIgnoreCertificateErrorsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable/disable whether all certificate errors should be ignored.\n- [`Security.handleCertificateError`](struct.HandleCertificateErrorCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Handles a certificate error that fired a certificateError event.\n- [`Security.setOverrideCertificateErrors`](struct.SetOverrideCertificateErrorsCommand.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  Enable/disable overriding certificate errors. If enabled, all certificate error events need to\n  be handled by the DevTools client and should be answered with `handleCertificateError` commands.\n\n## Events\n\n- [`Security.certificateError`](struct.CertificateErrorEvent.html) <span class=\"stab deprecated\" style=\"display: inline-block\">[Deprecated]</span>\n\n  There is a certificate error. If overriding certificate errors is enabled, then it should be\n  handled with the `handleCertificateError` command. Note: this event does not fire if the\n  certificate error has been allowed internally. Only one client per target should override\n  certificate errors at the same time.\n- [`Security.securityStateChanged`](struct.SecurityStateChangedEvent.html)\n\n  The security state of the page changed.\n\n##Types\n\n- [`CertificateId`](type.CertificateId.html)\n\n  An internal certificate ID value.\n- [`MixedContentType`](enum.MixedContentType.html)\n\n  A description of mixed content \\(HTTP resources on HTTPS pages\\), as defined by\n  https://www.w3.org/TR/mixed-content/#categories\n- [`SecurityState`](enum.SecurityState.html)\n\n  The security level of a page or resource.\n- [`SecurityStateExplanation`](struct.SecurityStateExplanation.html)\n\n  An explanation of an factor contributing to the security state.\n- [`InsecureContentStatus`](struct.InsecureContentStatus.html)\n\n  Information about insecure content on the page.\n- [`CertificateErrorAction`](enum.CertificateErrorAction.html)\n\n  The action to take when a certificate error occurs. continue will continue processing the\n  request and cancel will cancel the request.\n"]
pub mod security {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables tracking security state changes.\n\n# Command `Security.disable`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::security::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Security.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Security.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables tracking security state changes.\n\n# Command `Security.disable`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::security::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Security.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables tracking security state changes.\n\n# Command `Security.enable`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::security::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Security.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Security.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables tracking security state changes.\n\n# Command `Security.enable`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::security::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Security.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable whether all certificate errors should be ignored.\n\n# Command `Security.setIgnoreCertificateErrors`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::SetIgnoreCertificateErrorsCommand`](struct.SetIgnoreCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::security::SetIgnoreCertificateErrorsResponse`](struct.SetIgnoreCertificateErrorsResponse.html)"]
    pub struct SetIgnoreCertificateErrorsCommand {
        #[serde(rename = "ignore")]
        #[doc = "If true, all certificate errors will be ignored."]
        pub ignore: bool,
    }
    impl ::CdpCommand for SetIgnoreCertificateErrorsCommand {
        const COMMAND_NAME: &'static str = "Security.setIgnoreCertificateErrors";
    }
    impl ::SerializeCdpCommand for SetIgnoreCertificateErrorsCommand {
        fn command_name(&self) -> &str {
            "Security.setIgnoreCertificateErrors"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetIgnoreCertificateErrorsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.setIgnoreCertificateErrors" {
                Ok ( < SetIgnoreCertificateErrorsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable/disable whether all certificate errors should be ignored.\n\n# Command `Security.setIgnoreCertificateErrors`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::SetIgnoreCertificateErrorsCommand`](struct.SetIgnoreCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::security::SetIgnoreCertificateErrorsResponse`](struct.SetIgnoreCertificateErrorsResponse.html)"]
    pub struct SetIgnoreCertificateErrorsResponse;
    impl ::serde::Serialize for SetIgnoreCertificateErrorsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetIgnoreCertificateErrorsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetIgnoreCertificateErrorsResponse)
        }
    }
    impl ::CdpCommand for SetIgnoreCertificateErrorsResponse {
        const COMMAND_NAME: &'static str = "Security.setIgnoreCertificateErrors";
    }
    impl<'b> ::HasCdpResponse<'b> for SetIgnoreCertificateErrorsCommand {
        type Response = SetIgnoreCertificateErrorsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetIgnoreCertificateErrorsResponse {
        type Command = SetIgnoreCertificateErrorsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Handles a certificate error that fired a certificateError event.\n\n# Command `Security.handleCertificateError`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::HandleCertificateErrorCommand`](struct.HandleCertificateErrorCommand.html)  \n*Response Struct:* [`cdp::security::HandleCertificateErrorResponse`](struct.HandleCertificateErrorResponse.html)"]
    #[deprecated]
    pub struct HandleCertificateErrorCommand {
        #[serde(rename = "eventId")]
        #[doc = "The ID of the event."]
        pub event_id: i32,
        #[serde(rename = "action")]
        #[doc = "The action to take on the certificate error."]
        pub action: ::security::CertificateErrorAction,
    }
    impl ::CdpCommand for HandleCertificateErrorCommand {
        const COMMAND_NAME: &'static str = "Security.handleCertificateError";
    }
    impl ::SerializeCdpCommand for HandleCertificateErrorCommand {
        fn command_name(&self) -> &str {
            "Security.handleCertificateError"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for HandleCertificateErrorCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.handleCertificateError" {
                Ok ( < HandleCertificateErrorCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Handles a certificate error that fired a certificateError event.\n\n# Command `Security.handleCertificateError`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::HandleCertificateErrorCommand`](struct.HandleCertificateErrorCommand.html)  \n*Response Struct:* [`cdp::security::HandleCertificateErrorResponse`](struct.HandleCertificateErrorResponse.html)"]
    #[deprecated]
    pub struct HandleCertificateErrorResponse;
    impl ::serde::Serialize for HandleCertificateErrorResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for HandleCertificateErrorResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| HandleCertificateErrorResponse)
        }
    }
    impl ::CdpCommand for HandleCertificateErrorResponse {
        const COMMAND_NAME: &'static str = "Security.handleCertificateError";
    }
    impl<'b> ::HasCdpResponse<'b> for HandleCertificateErrorCommand {
        type Response = HandleCertificateErrorResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for HandleCertificateErrorResponse {
        type Command = HandleCertificateErrorCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enable/disable overriding certificate errors. If enabled, all certificate error events need to\nbe handled by the DevTools client and should be answered with `handleCertificateError` commands.\n\n# Command `Security.setOverrideCertificateErrors`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::SetOverrideCertificateErrorsCommand`](struct.SetOverrideCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::security::SetOverrideCertificateErrorsResponse`](struct.SetOverrideCertificateErrorsResponse.html)"]
    #[deprecated]
    pub struct SetOverrideCertificateErrorsCommand {
        #[serde(rename = "override")]
        #[doc = "If true, certificate errors will be overridden."]
        pub overridden: bool,
    }
    impl ::CdpCommand for SetOverrideCertificateErrorsCommand {
        const COMMAND_NAME: &'static str = "Security.setOverrideCertificateErrors";
    }
    impl ::SerializeCdpCommand for SetOverrideCertificateErrorsCommand {
        fn command_name(&self) -> &str {
            "Security.setOverrideCertificateErrors"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetOverrideCertificateErrorsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.setOverrideCertificateErrors" {
                Ok ( < SetOverrideCertificateErrorsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enable/disable overriding certificate errors. If enabled, all certificate error events need to\nbe handled by the DevTools client and should be answered with `handleCertificateError` commands.\n\n# Command `Security.setOverrideCertificateErrors`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Command Struct:* [`cdp::security::SetOverrideCertificateErrorsCommand`](struct.SetOverrideCertificateErrorsCommand.html)  \n*Response Struct:* [`cdp::security::SetOverrideCertificateErrorsResponse`](struct.SetOverrideCertificateErrorsResponse.html)"]
    #[deprecated]
    pub struct SetOverrideCertificateErrorsResponse;
    impl ::serde::Serialize for SetOverrideCertificateErrorsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetOverrideCertificateErrorsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetOverrideCertificateErrorsResponse)
        }
    }
    impl ::CdpCommand for SetOverrideCertificateErrorsResponse {
        const COMMAND_NAME: &'static str = "Security.setOverrideCertificateErrors";
    }
    impl<'b> ::HasCdpResponse<'b> for SetOverrideCertificateErrorsCommand {
        type Response = SetOverrideCertificateErrorsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetOverrideCertificateErrorsResponse {
        type Command = SetOverrideCertificateErrorsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "There is a certificate error. If overriding certificate errors is enabled, then it should be\nhandled with the `handleCertificateError` command. Note: this event does not fire if the\ncertificate error has been allowed internally. Only one client per target should override\ncertificate errors at the same time.\n\n# Event `Security.certificateError`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Event Struct:* [`cdp::security::CertificateErrorEvent`](struct.CertificateErrorEvent.html)"]
    #[deprecated]
    pub struct CertificateErrorEvent<'a> {
        #[serde(rename = "eventId")]
        #[doc = "The ID of the event."]
        pub event_id: i32,
        #[serde(rename = "errorType")]
        #[doc = "The type of the error."]
        pub error_type: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "requestURL")]
        #[doc = "The url that was requested."]
        pub request_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for CertificateErrorEvent<'a> {
        const EVENT_NAME: &'static str = "Security.certificateError";
    }
    impl<'a> ::SerializeCdpEvent for CertificateErrorEvent<'a> {
        fn event_name(&self) -> &str {
            "Security.certificateError"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for CertificateErrorEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.certificateError" {
                Ok(
                    <CertificateErrorEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "The security state of the page changed.\n\n# Event `Security.securityStateChanged`\n\n*Domain Module:* [`cdp::security`](index.html)  \n*Event Struct:* [`cdp::security::SecurityStateChangedEvent`](struct.SecurityStateChangedEvent.html)"]
    pub struct SecurityStateChangedEvent<'a> {
        #[serde(rename = "securityState")]
        #[doc = "Security state."]
        pub security_state: ::security::SecurityState,
        #[serde(rename = "schemeIsCryptographic")]
        #[doc = "True if the page was loaded over cryptographic transport such as HTTPS."]
        pub scheme_is_cryptographic: bool,
        #[serde(rename = "explanations")]
        #[doc = "List of explanations for the security state. If the overall security state is `insecure` or\n`warning`, at least one corresponding explanation should be included."]
        pub explanations: Vec<::security::SecurityStateExplanation<'a>>,
        #[serde(rename = "insecureContentStatus")]
        #[doc = "Information about insecure content on the page."]
        pub insecure_content_status: ::security::InsecureContentStatus,
        #[serde(rename = "summary", skip_serializing_if = "Option::is_none")]
        #[doc = "Overrides user-visible description of the state."]
        pub summary: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpEvent for SecurityStateChangedEvent<'a> {
        const EVENT_NAME: &'static str = "Security.securityStateChanged";
    }
    impl<'a> ::SerializeCdpEvent for SecurityStateChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "Security.securityStateChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for SecurityStateChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Security.securityStateChanged" {
                Ok ( < SecurityStateChangedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "An internal certificate ID value."]
    pub type CertificateId = i32;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "A description of mixed content \\(HTTP resources on HTTPS pages\\), as defined by\nhttps://www.w3.org/TR/mixed-content/#categories"]
    pub enum MixedContentType {
        #[serde(rename = "blockable")]
        #[doc = "Represented as `\"blockable\"`."]
        Blockable,
        #[serde(rename = "optionally-blockable")]
        #[doc = "Represented as `\"optionally-blockable\"`."]
        OptionallyBlockable,
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
    }
    impl MixedContentType {
        pub const ENUM_VALUES: &'static [MixedContentType] = &[
            MixedContentType::Blockable,
            MixedContentType::OptionallyBlockable,
            MixedContentType::None,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["blockable", "optionally-blockable", "none"];
    }
    impl ::std::str::FromStr for MixedContentType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "blockable" => Ok(MixedContentType::Blockable),
                "optionally-blockable" => Ok(MixedContentType::OptionallyBlockable),
                "none" => Ok(MixedContentType::None),
                _ => Err(::ParseEnumError {
                    expected: MixedContentType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for MixedContentType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    MixedContentType::Blockable => "blockable",
                    MixedContentType::OptionallyBlockable => "optionally-blockable",
                    MixedContentType::None => "none",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "The security level of a page or resource."]
    pub enum SecurityState {
        #[serde(rename = "unknown")]
        #[doc = "Represented as `\"unknown\"`."]
        Unknown,
        #[serde(rename = "neutral")]
        #[doc = "Represented as `\"neutral\"`."]
        Neutral,
        #[serde(rename = "insecure")]
        #[doc = "Represented as `\"insecure\"`."]
        Insecure,
        #[serde(rename = "secure")]
        #[doc = "Represented as `\"secure\"`."]
        Secure,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
    }
    impl SecurityState {
        pub const ENUM_VALUES: &'static [SecurityState] = &[
            SecurityState::Unknown,
            SecurityState::Neutral,
            SecurityState::Insecure,
            SecurityState::Secure,
            SecurityState::Info,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["unknown", "neutral", "insecure", "secure", "info"];
    }
    impl ::std::str::FromStr for SecurityState {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "unknown" => Ok(SecurityState::Unknown),
                "neutral" => Ok(SecurityState::Neutral),
                "insecure" => Ok(SecurityState::Insecure),
                "secure" => Ok(SecurityState::Secure),
                "info" => Ok(SecurityState::Info),
                _ => Err(::ParseEnumError {
                    expected: SecurityState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SecurityState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SecurityState::Unknown => "unknown",
                    SecurityState::Neutral => "neutral",
                    SecurityState::Insecure => "insecure",
                    SecurityState::Secure => "secure",
                    SecurityState::Info => "info",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "An explanation of an factor contributing to the security state."]
    pub struct SecurityStateExplanation<'a> {
        #[serde(rename = "securityState")]
        #[doc = "Security state representing the severity of the factor being explained."]
        pub security_state: ::security::SecurityState,
        #[serde(rename = "title")]
        #[doc = "Title describing the type of factor."]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "summary")]
        #[doc = "Short phrase describing the type of factor."]
        pub summary: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "description")]
        #[doc = "Full text explanation of the factor."]
        pub description: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "mixedContentType")]
        #[doc = "The type of mixed content described by the explanation."]
        pub mixed_content_type: ::security::MixedContentType,
        #[serde(rename = "certificate")]
        #[doc = "Page certificate."]
        pub certificate: Vec<::std::borrow::Cow<'a, str>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Information about insecure content on the page."]
    pub struct InsecureContentStatus {
        #[serde(rename = "ranMixedContent")]
        #[doc = "True if the page was loaded over HTTPS and ran mixed \\(HTTP\\) content such as scripts."]
        pub ran_mixed_content: bool,
        #[serde(rename = "displayedMixedContent")]
        #[doc = "True if the page was loaded over HTTPS and displayed mixed \\(HTTP\\) content such as images."]
        pub displayed_mixed_content: bool,
        #[serde(rename = "containedMixedForm")]
        #[doc = "True if the page was loaded over HTTPS and contained a form targeting an insecure url."]
        pub contained_mixed_form: bool,
        #[serde(rename = "ranContentWithCertErrors")]
        #[doc = "True if the page was loaded over HTTPS without certificate errors, and ran content such as\nscripts that were loaded with certificate errors."]
        pub ran_content_with_cert_errors: bool,
        #[serde(rename = "displayedContentWithCertErrors")]
        #[doc = "True if the page was loaded over HTTPS without certificate errors, and displayed content\nsuch as images that were loaded with certificate errors."]
        pub displayed_content_with_cert_errors: bool,
        #[serde(rename = "ranInsecureContentStyle")]
        #[doc = "Security state representing a page that ran insecure content."]
        pub ran_insecure_content_style: ::security::SecurityState,
        #[serde(rename = "displayedInsecureContentStyle")]
        #[doc = "Security state representing a page that displayed insecure content."]
        pub displayed_insecure_content_style: ::security::SecurityState,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "The action to take when a certificate error occurs. continue will continue processing the\nrequest and cancel will cancel the request."]
    pub enum CertificateErrorAction {
        #[serde(rename = "continue")]
        #[doc = "Represented as `\"continue\"`."]
        Continue,
        #[serde(rename = "cancel")]
        #[doc = "Represented as `\"cancel\"`."]
        Cancel,
    }
    impl CertificateErrorAction {
        pub const ENUM_VALUES: &'static [CertificateErrorAction] =
            &[
                CertificateErrorAction::Continue,
                CertificateErrorAction::Cancel,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["continue", "cancel"];
    }
    impl ::std::str::FromStr for CertificateErrorAction {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "continue" => Ok(CertificateErrorAction::Continue),
                "cancel" => Ok(CertificateErrorAction::Cancel),
                _ => Err(::ParseEnumError {
                    expected: CertificateErrorAction::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for CertificateErrorAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    CertificateErrorAction::Continue => "continue",
                    CertificateErrorAction::Cancel => "cancel",
                }
            )
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# ServiceWorker\n\n## Commands\n\n- [`ServiceWorker.deliverPushMessage`](struct.DeliverPushMessageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.dispatchSyncEvent`](struct.DispatchSyncEventCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.inspectWorker`](struct.InspectWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.setForceUpdateOnPageLoad`](struct.SetForceUpdateOnPageLoadCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.skipWaiting`](struct.SkipWaitingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.startWorker`](struct.StartWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.stopAllWorkers`](struct.StopAllWorkersCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.stopWorker`](struct.StopWorkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.unregister`](struct.UnregisterCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.updateRegistration`](struct.UpdateRegistrationCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`ServiceWorker.workerErrorReported`](struct.WorkerErrorReportedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.workerRegistrationUpdated`](struct.WorkerRegistrationUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorker.workerVersionUpdated`](struct.WorkerVersionUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`ServiceWorkerRegistration`](struct.ServiceWorkerRegistration.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker registration.\n- [`ServiceWorkerVersionRunningStatus`](enum.ServiceWorkerVersionRunningStatus.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorkerVersionStatus`](enum.ServiceWorkerVersionStatus.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ServiceWorkerVersion`](struct.ServiceWorkerVersion.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker version.\n- [`ServiceWorkerErrorMessage`](struct.ServiceWorkerErrorMessage.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  ServiceWorker error message.\n"]
pub mod service_worker {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.deliverPushMessage`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DeliverPushMessageCommand`](struct.DeliverPushMessageCommand.html)  \n*Response Struct:* [`cdp::service_worker::DeliverPushMessageResponse`](struct.DeliverPushMessageResponse.html)"]
    pub struct DeliverPushMessageCommand<'a> {
        #[serde(rename = "origin")]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "data")]
        pub data: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for DeliverPushMessageCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.deliverPushMessage";
    }
    impl<'a> ::SerializeCdpCommand for DeliverPushMessageCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.deliverPushMessage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DeliverPushMessageCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.deliverPushMessage" {
                Ok ( < DeliverPushMessageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.deliverPushMessage`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DeliverPushMessageCommand`](struct.DeliverPushMessageCommand.html)  \n*Response Struct:* [`cdp::service_worker::DeliverPushMessageResponse`](struct.DeliverPushMessageResponse.html)"]
    pub struct DeliverPushMessageResponse;
    impl ::serde::Serialize for DeliverPushMessageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DeliverPushMessageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DeliverPushMessageResponse)
        }
    }
    impl ::CdpCommand for DeliverPushMessageResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.deliverPushMessage";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DeliverPushMessageCommand<'a> {
        type Response = DeliverPushMessageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DeliverPushMessageResponse {
        type Command = DeliverPushMessageCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.disable`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::service_worker::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "ServiceWorker.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.disable`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::service_worker::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.dispatchSyncEvent`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DispatchSyncEventCommand`](struct.DispatchSyncEventCommand.html)  \n*Response Struct:* [`cdp::service_worker::DispatchSyncEventResponse`](struct.DispatchSyncEventResponse.html)"]
    pub struct DispatchSyncEventCommand<'a> {
        #[serde(rename = "origin")]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "tag")]
        pub tag: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lastChance")]
        pub last_chance: bool,
    }
    impl<'a> ::CdpCommand for DispatchSyncEventCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.dispatchSyncEvent";
    }
    impl<'a> ::SerializeCdpCommand for DispatchSyncEventCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.dispatchSyncEvent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DispatchSyncEventCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.dispatchSyncEvent" {
                Ok ( < DispatchSyncEventCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.dispatchSyncEvent`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::DispatchSyncEventCommand`](struct.DispatchSyncEventCommand.html)  \n*Response Struct:* [`cdp::service_worker::DispatchSyncEventResponse`](struct.DispatchSyncEventResponse.html)"]
    pub struct DispatchSyncEventResponse;
    impl ::serde::Serialize for DispatchSyncEventResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DispatchSyncEventResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DispatchSyncEventResponse)
        }
    }
    impl ::CdpCommand for DispatchSyncEventResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.dispatchSyncEvent";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DispatchSyncEventCommand<'a> {
        type Response = DispatchSyncEventResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DispatchSyncEventResponse {
        type Command = DispatchSyncEventCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.enable`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::service_worker::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "ServiceWorker.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.enable`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::service_worker::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.inspectWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::InspectWorkerCommand`](struct.InspectWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::InspectWorkerResponse`](struct.InspectWorkerResponse.html)"]
    pub struct InspectWorkerCommand<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for InspectWorkerCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.inspectWorker";
    }
    impl<'a> ::SerializeCdpCommand for InspectWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.inspectWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for InspectWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.inspectWorker" {
                Ok(
                    <InspectWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.inspectWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::InspectWorkerCommand`](struct.InspectWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::InspectWorkerResponse`](struct.InspectWorkerResponse.html)"]
    pub struct InspectWorkerResponse;
    impl ::serde::Serialize for InspectWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for InspectWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| InspectWorkerResponse)
        }
    }
    impl ::CdpCommand for InspectWorkerResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.inspectWorker";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for InspectWorkerCommand<'a> {
        type Response = InspectWorkerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for InspectWorkerResponse {
        type Command = InspectWorkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.setForceUpdateOnPageLoad`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::SetForceUpdateOnPageLoadCommand`](struct.SetForceUpdateOnPageLoadCommand.html)  \n*Response Struct:* [`cdp::service_worker::SetForceUpdateOnPageLoadResponse`](struct.SetForceUpdateOnPageLoadResponse.html)"]
    pub struct SetForceUpdateOnPageLoadCommand {
        #[serde(rename = "forceUpdateOnPageLoad")]
        pub force_update_on_page_load: bool,
    }
    impl ::CdpCommand for SetForceUpdateOnPageLoadCommand {
        const COMMAND_NAME: &'static str = "ServiceWorker.setForceUpdateOnPageLoad";
    }
    impl ::SerializeCdpCommand for SetForceUpdateOnPageLoadCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.setForceUpdateOnPageLoad"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetForceUpdateOnPageLoadCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.setForceUpdateOnPageLoad" {
                Ok ( < SetForceUpdateOnPageLoadCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.setForceUpdateOnPageLoad`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::SetForceUpdateOnPageLoadCommand`](struct.SetForceUpdateOnPageLoadCommand.html)  \n*Response Struct:* [`cdp::service_worker::SetForceUpdateOnPageLoadResponse`](struct.SetForceUpdateOnPageLoadResponse.html)"]
    pub struct SetForceUpdateOnPageLoadResponse;
    impl ::serde::Serialize for SetForceUpdateOnPageLoadResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetForceUpdateOnPageLoadResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetForceUpdateOnPageLoadResponse)
        }
    }
    impl ::CdpCommand for SetForceUpdateOnPageLoadResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.setForceUpdateOnPageLoad";
    }
    impl<'b> ::HasCdpResponse<'b> for SetForceUpdateOnPageLoadCommand {
        type Response = SetForceUpdateOnPageLoadResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetForceUpdateOnPageLoadResponse {
        type Command = SetForceUpdateOnPageLoadCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.skipWaiting`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::SkipWaitingCommand`](struct.SkipWaitingCommand.html)  \n*Response Struct:* [`cdp::service_worker::SkipWaitingResponse`](struct.SkipWaitingResponse.html)"]
    pub struct SkipWaitingCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for SkipWaitingCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.skipWaiting";
    }
    impl<'a> ::SerializeCdpCommand for SkipWaitingCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.skipWaiting"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SkipWaitingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.skipWaiting" {
                Ok(
                    <SkipWaitingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.skipWaiting`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::SkipWaitingCommand`](struct.SkipWaitingCommand.html)  \n*Response Struct:* [`cdp::service_worker::SkipWaitingResponse`](struct.SkipWaitingResponse.html)"]
    pub struct SkipWaitingResponse;
    impl ::serde::Serialize for SkipWaitingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SkipWaitingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SkipWaitingResponse)
        }
    }
    impl ::CdpCommand for SkipWaitingResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.skipWaiting";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SkipWaitingCommand<'a> {
        type Response = SkipWaitingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SkipWaitingResponse {
        type Command = SkipWaitingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.startWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StartWorkerCommand`](struct.StartWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::StartWorkerResponse`](struct.StartWorkerResponse.html)"]
    pub struct StartWorkerCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for StartWorkerCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.startWorker";
    }
    impl<'a> ::SerializeCdpCommand for StartWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.startWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for StartWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.startWorker" {
                Ok(
                    <StartWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.startWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StartWorkerCommand`](struct.StartWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::StartWorkerResponse`](struct.StartWorkerResponse.html)"]
    pub struct StartWorkerResponse;
    impl ::serde::Serialize for StartWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartWorkerResponse)
        }
    }
    impl ::CdpCommand for StartWorkerResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.startWorker";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for StartWorkerCommand<'a> {
        type Response = StartWorkerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartWorkerResponse {
        type Command = StartWorkerCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopAllWorkers`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StopAllWorkersCommand`](struct.StopAllWorkersCommand.html)  \n*Response Struct:* [`cdp::service_worker::StopAllWorkersResponse`](struct.StopAllWorkersResponse.html)"]
    pub struct StopAllWorkersCommand;
    impl ::serde::Serialize for StopAllWorkersCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopAllWorkersCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopAllWorkersCommand)
        }
    }
    impl ::CdpCommand for StopAllWorkersCommand {
        const COMMAND_NAME: &'static str = "ServiceWorker.stopAllWorkers";
    }
    impl ::SerializeCdpCommand for StopAllWorkersCommand {
        fn command_name(&self) -> &str {
            "ServiceWorker.stopAllWorkers"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopAllWorkersCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.stopAllWorkers" {
                Ok(
                    <StopAllWorkersCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopAllWorkers`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StopAllWorkersCommand`](struct.StopAllWorkersCommand.html)  \n*Response Struct:* [`cdp::service_worker::StopAllWorkersResponse`](struct.StopAllWorkersResponse.html)"]
    pub struct StopAllWorkersResponse;
    impl ::serde::Serialize for StopAllWorkersResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopAllWorkersResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopAllWorkersResponse)
        }
    }
    impl ::CdpCommand for StopAllWorkersResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.stopAllWorkers";
    }
    impl<'b> ::HasCdpResponse<'b> for StopAllWorkersCommand {
        type Response = StopAllWorkersResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopAllWorkersResponse {
        type Command = StopAllWorkersCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StopWorkerCommand`](struct.StopWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::StopWorkerResponse`](struct.StopWorkerResponse.html)"]
    pub struct StopWorkerCommand<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for StopWorkerCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.stopWorker";
    }
    impl<'a> ::SerializeCdpCommand for StopWorkerCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.stopWorker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for StopWorkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.stopWorker" {
                Ok(
                    <StopWorkerCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.stopWorker`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::StopWorkerCommand`](struct.StopWorkerCommand.html)  \n*Response Struct:* [`cdp::service_worker::StopWorkerResponse`](struct.StopWorkerResponse.html)"]
    pub struct StopWorkerResponse;
    impl ::serde::Serialize for StopWorkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopWorkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopWorkerResponse)
        }
    }
    impl ::CdpCommand for StopWorkerResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.stopWorker";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for StopWorkerCommand<'a> {
        type Response = StopWorkerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopWorkerResponse {
        type Command = StopWorkerCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.unregister`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::UnregisterCommand`](struct.UnregisterCommand.html)  \n*Response Struct:* [`cdp::service_worker::UnregisterResponse`](struct.UnregisterResponse.html)"]
    pub struct UnregisterCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for UnregisterCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.unregister";
    }
    impl<'a> ::SerializeCdpCommand for UnregisterCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.unregister"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for UnregisterCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.unregister" {
                Ok(
                    <UnregisterCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.unregister`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::UnregisterCommand`](struct.UnregisterCommand.html)  \n*Response Struct:* [`cdp::service_worker::UnregisterResponse`](struct.UnregisterResponse.html)"]
    pub struct UnregisterResponse;
    impl ::serde::Serialize for UnregisterResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UnregisterResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UnregisterResponse)
        }
    }
    impl ::CdpCommand for UnregisterResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.unregister";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for UnregisterCommand<'a> {
        type Response = UnregisterResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UnregisterResponse {
        type Command = UnregisterCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.updateRegistration`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::UpdateRegistrationCommand`](struct.UpdateRegistrationCommand.html)  \n*Response Struct:* [`cdp::service_worker::UpdateRegistrationResponse`](struct.UpdateRegistrationResponse.html)"]
    pub struct UpdateRegistrationCommand<'a> {
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for UpdateRegistrationCommand<'a> {
        const COMMAND_NAME: &'static str = "ServiceWorker.updateRegistration";
    }
    impl<'a> ::SerializeCdpCommand for UpdateRegistrationCommand<'a> {
        fn command_name(&self) -> &str {
            "ServiceWorker.updateRegistration"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for UpdateRegistrationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.updateRegistration" {
                Ok ( < UpdateRegistrationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `ServiceWorker.updateRegistration`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Command Struct:* [`cdp::service_worker::UpdateRegistrationCommand`](struct.UpdateRegistrationCommand.html)  \n*Response Struct:* [`cdp::service_worker::UpdateRegistrationResponse`](struct.UpdateRegistrationResponse.html)"]
    pub struct UpdateRegistrationResponse;
    impl ::serde::Serialize for UpdateRegistrationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateRegistrationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UpdateRegistrationResponse)
        }
    }
    impl ::CdpCommand for UpdateRegistrationResponse {
        const COMMAND_NAME: &'static str = "ServiceWorker.updateRegistration";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for UpdateRegistrationCommand<'a> {
        type Response = UpdateRegistrationResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UpdateRegistrationResponse {
        type Command = UpdateRegistrationCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerErrorReported`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Event Struct:* [`cdp::service_worker::WorkerErrorReportedEvent`](struct.WorkerErrorReportedEvent.html)"]
    pub struct WorkerErrorReportedEvent<'a> {
        #[serde(rename = "errorMessage")]
        pub error_message: ::service_worker::ServiceWorkerErrorMessage<'a>,
    }
    impl<'a> ::CdpEvent for WorkerErrorReportedEvent<'a> {
        const EVENT_NAME: &'static str = "ServiceWorker.workerErrorReported";
    }
    impl<'a> ::SerializeCdpEvent for WorkerErrorReportedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerErrorReported"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WorkerErrorReportedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerErrorReported" {
                Ok ( < WorkerErrorReportedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerRegistrationUpdated`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Event Struct:* [`cdp::service_worker::WorkerRegistrationUpdatedEvent`](struct.WorkerRegistrationUpdatedEvent.html)"]
    pub struct WorkerRegistrationUpdatedEvent<'a> {
        #[serde(rename = "registrations")]
        pub registrations: Vec<::service_worker::ServiceWorkerRegistration<'a>>,
    }
    impl<'a> ::CdpEvent for WorkerRegistrationUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "ServiceWorker.workerRegistrationUpdated";
    }
    impl<'a> ::SerializeCdpEvent for WorkerRegistrationUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerRegistrationUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WorkerRegistrationUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerRegistrationUpdated" {
                Ok ( < WorkerRegistrationUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `ServiceWorker.workerVersionUpdated`\n\n*Domain Module:* [`cdp::service_worker`](index.html)  \n*Event Struct:* [`cdp::service_worker::WorkerVersionUpdatedEvent`](struct.WorkerVersionUpdatedEvent.html)"]
    pub struct WorkerVersionUpdatedEvent<'a> {
        #[serde(rename = "versions")]
        pub versions: Vec<::service_worker::ServiceWorkerVersion<'a>>,
    }
    impl<'a> ::CdpEvent for WorkerVersionUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "ServiceWorker.workerVersionUpdated";
    }
    impl<'a> ::SerializeCdpEvent for WorkerVersionUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "ServiceWorker.workerVersionUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for WorkerVersionUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "ServiceWorker.workerVersionUpdated" {
                Ok ( < WorkerVersionUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker registration."]
    pub struct ServiceWorkerRegistration<'a> {
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scopeURL")]
        pub scope_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "isDeleted")]
        pub is_deleted: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum ServiceWorkerVersionRunningStatus {
        #[serde(rename = "stopped")]
        #[doc = "Represented as `\"stopped\"`."]
        Stopped,
        #[serde(rename = "starting")]
        #[doc = "Represented as `\"starting\"`."]
        Starting,
        #[serde(rename = "running")]
        #[doc = "Represented as `\"running\"`."]
        Running,
        #[serde(rename = "stopping")]
        #[doc = "Represented as `\"stopping\"`."]
        Stopping,
    }
    impl ServiceWorkerVersionRunningStatus {
        pub const ENUM_VALUES: &'static [ServiceWorkerVersionRunningStatus] =
            &[
                ServiceWorkerVersionRunningStatus::Stopped,
                ServiceWorkerVersionRunningStatus::Starting,
                ServiceWorkerVersionRunningStatus::Running,
                ServiceWorkerVersionRunningStatus::Stopping,
            ];
        pub const STR_VALUES: &'static [&'static str] =
            &["stopped", "starting", "running", "stopping"];
    }
    impl ::std::str::FromStr for ServiceWorkerVersionRunningStatus {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "stopped" => Ok(ServiceWorkerVersionRunningStatus::Stopped),
                "starting" => Ok(ServiceWorkerVersionRunningStatus::Starting),
                "running" => Ok(ServiceWorkerVersionRunningStatus::Running),
                "stopping" => Ok(ServiceWorkerVersionRunningStatus::Stopping),
                _ => Err(::ParseEnumError {
                    expected: ServiceWorkerVersionRunningStatus::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ServiceWorkerVersionRunningStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ServiceWorkerVersionRunningStatus::Stopped => "stopped",
                    ServiceWorkerVersionRunningStatus::Starting => "starting",
                    ServiceWorkerVersionRunningStatus::Running => "running",
                    ServiceWorkerVersionRunningStatus::Stopping => "stopping",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub enum ServiceWorkerVersionStatus {
        #[serde(rename = "new")]
        #[doc = "Represented as `\"new\"`."]
        New,
        #[serde(rename = "installing")]
        #[doc = "Represented as `\"installing\"`."]
        Installing,
        #[serde(rename = "installed")]
        #[doc = "Represented as `\"installed\"`."]
        Installed,
        #[serde(rename = "activating")]
        #[doc = "Represented as `\"activating\"`."]
        Activating,
        #[serde(rename = "activated")]
        #[doc = "Represented as `\"activated\"`."]
        Activated,
        #[serde(rename = "redundant")]
        #[doc = "Represented as `\"redundant\"`."]
        Redundant,
    }
    impl ServiceWorkerVersionStatus {
        pub const ENUM_VALUES: &'static [ServiceWorkerVersionStatus] =
            &[
                ServiceWorkerVersionStatus::New,
                ServiceWorkerVersionStatus::Installing,
                ServiceWorkerVersionStatus::Installed,
                ServiceWorkerVersionStatus::Activating,
                ServiceWorkerVersionStatus::Activated,
                ServiceWorkerVersionStatus::Redundant,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "new",
            "installing",
            "installed",
            "activating",
            "activated",
            "redundant",
        ];
    }
    impl ::std::str::FromStr for ServiceWorkerVersionStatus {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "new" => Ok(ServiceWorkerVersionStatus::New),
                "installing" => Ok(ServiceWorkerVersionStatus::Installing),
                "installed" => Ok(ServiceWorkerVersionStatus::Installed),
                "activating" => Ok(ServiceWorkerVersionStatus::Activating),
                "activated" => Ok(ServiceWorkerVersionStatus::Activated),
                "redundant" => Ok(ServiceWorkerVersionStatus::Redundant),
                _ => Err(::ParseEnumError {
                    expected: ServiceWorkerVersionStatus::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ServiceWorkerVersionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ServiceWorkerVersionStatus::New => "new",
                    ServiceWorkerVersionStatus::Installing => "installing",
                    ServiceWorkerVersionStatus::Installed => "installed",
                    ServiceWorkerVersionStatus::Activating => "activating",
                    ServiceWorkerVersionStatus::Activated => "activated",
                    ServiceWorkerVersionStatus::Redundant => "redundant",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker version."]
    pub struct ServiceWorkerVersion<'a> {
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scriptURL")]
        pub script_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "runningStatus")]
        pub running_status: ::service_worker::ServiceWorkerVersionRunningStatus,
        #[serde(rename = "status")]
        pub status: ::service_worker::ServiceWorkerVersionStatus,
        #[serde(rename = "scriptLastModified", skip_serializing_if = "Option::is_none")]
        #[doc = "The Last-Modified header value of the main script."]
        pub script_last_modified: Option<f64>,
        #[serde(rename = "scriptResponseTime", skip_serializing_if = "Option::is_none")]
        #[doc = "The time at which the response headers of the main script were received from the server.\nFor cached script it is the last time the cache entry was validated."]
        pub script_response_time: Option<f64>,
        #[serde(rename = "controlledClients", skip_serializing_if = "Option::is_none")]
        pub controlled_clients: Option<Vec<::target::TargetId<'a>>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> ServiceWorker error message."]
    pub struct ServiceWorkerErrorMessage<'a> {
        #[serde(rename = "errorMessage")]
        pub error_message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "registrationId")]
        pub registration_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "versionId")]
        pub version_id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceURL")]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        pub column_number: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Storage\n\n## Commands\n\n- [`Storage.clearDataForOrigin`](struct.ClearDataForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Clears storage for origin.\n- [`Storage.getUsageAndQuota`](struct.GetUsageAndQuotaCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns usage and quota in bytes.\n- [`Storage.trackCacheStorageForOrigin`](struct.TrackCacheStorageForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Registers origin to be notified when an update occurs to its cache storage list.\n- [`Storage.trackIndexedDBForOrigin`](struct.TrackIndexedDbForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Registers origin to be notified when an update occurs to its IndexedDB.\n- [`Storage.untrackCacheStorageForOrigin`](struct.UntrackCacheStorageForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unregisters origin from receiving notifications for cache storage.\n- [`Storage.untrackIndexedDBForOrigin`](struct.UntrackIndexedDbForOriginCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unregisters origin from receiving notifications for IndexedDB.\n\n## Events\n\n- [`Storage.cacheStorageContentUpdated`](struct.CacheStorageContentUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A cache's contents have been modified.\n- [`Storage.cacheStorageListUpdated`](struct.CacheStorageListUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  A cache has been added/deleted.\n- [`Storage.indexedDBContentUpdated`](struct.IndexedDbContentUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The origin's IndexedDB object store has been modified.\n- [`Storage.indexedDBListUpdated`](struct.IndexedDbListUpdatedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  The origin's IndexedDB database list has been modified.\n\n##Types\n\n- [`StorageType`](enum.StorageType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enum of possible storage types.\n- [`UsageForType`](struct.UsageForType.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Usage for a storage type.\n"]
pub mod storage {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears storage for origin.\n\n# Command `Storage.clearDataForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::ClearDataForOriginCommand`](struct.ClearDataForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::ClearDataForOriginResponse`](struct.ClearDataForOriginResponse.html)"]
    pub struct ClearDataForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "storageTypes")]
        #[doc = "Comma separated origin names."]
        pub storage_types: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ClearDataForOriginCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.clearDataForOrigin";
    }
    impl<'a> ::SerializeCdpCommand for ClearDataForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.clearDataForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ClearDataForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.clearDataForOrigin" {
                Ok ( < ClearDataForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Clears storage for origin.\n\n# Command `Storage.clearDataForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::ClearDataForOriginCommand`](struct.ClearDataForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::ClearDataForOriginResponse`](struct.ClearDataForOriginResponse.html)"]
    pub struct ClearDataForOriginResponse;
    impl ::serde::Serialize for ClearDataForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearDataForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearDataForOriginResponse)
        }
    }
    impl ::CdpCommand for ClearDataForOriginResponse {
        const COMMAND_NAME: &'static str = "Storage.clearDataForOrigin";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ClearDataForOriginCommand<'a> {
        type Response = ClearDataForOriginResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearDataForOriginResponse {
        type Command = ClearDataForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns usage and quota in bytes.\n\n# Command `Storage.getUsageAndQuota`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::GetUsageAndQuotaCommand`](struct.GetUsageAndQuotaCommand.html)  \n*Response Struct:* [`cdp::storage::GetUsageAndQuotaResponse`](struct.GetUsageAndQuotaResponse.html)"]
    pub struct GetUsageAndQuotaCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetUsageAndQuotaCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.getUsageAndQuota";
    }
    impl<'a> ::SerializeCdpCommand for GetUsageAndQuotaCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.getUsageAndQuota"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetUsageAndQuotaCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.getUsageAndQuota" {
                Ok ( < GetUsageAndQuotaCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns usage and quota in bytes.\n\n# Command `Storage.getUsageAndQuota`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::GetUsageAndQuotaCommand`](struct.GetUsageAndQuotaCommand.html)  \n*Response Struct:* [`cdp::storage::GetUsageAndQuotaResponse`](struct.GetUsageAndQuotaResponse.html)"]
    pub struct GetUsageAndQuotaResponse {
        #[serde(rename = "usage")]
        #[doc = "Storage usage \\(bytes\\)."]
        pub usage: f64,
        #[serde(rename = "quota")]
        #[doc = "Storage quota \\(bytes\\)."]
        pub quota: f64,
        #[serde(rename = "usageBreakdown")]
        #[doc = "Storage usage per type \\(bytes\\)."]
        pub usage_breakdown: Vec<::storage::UsageForType>,
    }
    impl ::CdpCommand for GetUsageAndQuotaResponse {
        const COMMAND_NAME: &'static str = "Storage.getUsageAndQuota";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetUsageAndQuotaCommand<'a> {
        type Response = GetUsageAndQuotaResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetUsageAndQuotaResponse {
        type Command = GetUsageAndQuotaCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Registers origin to be notified when an update occurs to its cache storage list.\n\n# Command `Storage.trackCacheStorageForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::TrackCacheStorageForOriginCommand`](struct.TrackCacheStorageForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::TrackCacheStorageForOriginResponse`](struct.TrackCacheStorageForOriginResponse.html)"]
    pub struct TrackCacheStorageForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for TrackCacheStorageForOriginCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.trackCacheStorageForOrigin";
    }
    impl<'a> ::SerializeCdpCommand for TrackCacheStorageForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.trackCacheStorageForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for TrackCacheStorageForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.trackCacheStorageForOrigin" {
                Ok ( < TrackCacheStorageForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Registers origin to be notified when an update occurs to its cache storage list.\n\n# Command `Storage.trackCacheStorageForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::TrackCacheStorageForOriginCommand`](struct.TrackCacheStorageForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::TrackCacheStorageForOriginResponse`](struct.TrackCacheStorageForOriginResponse.html)"]
    pub struct TrackCacheStorageForOriginResponse;
    impl ::serde::Serialize for TrackCacheStorageForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TrackCacheStorageForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TrackCacheStorageForOriginResponse)
        }
    }
    impl ::CdpCommand for TrackCacheStorageForOriginResponse {
        const COMMAND_NAME: &'static str = "Storage.trackCacheStorageForOrigin";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for TrackCacheStorageForOriginCommand<'a> {
        type Response = TrackCacheStorageForOriginResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for TrackCacheStorageForOriginResponse {
        type Command = TrackCacheStorageForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Registers origin to be notified when an update occurs to its IndexedDB.\n\n# Command `Storage.trackIndexedDBForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::TrackIndexedDbForOriginCommand`](struct.TrackIndexedDbForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::TrackIndexedDbForOriginResponse`](struct.TrackIndexedDbForOriginResponse.html)"]
    pub struct TrackIndexedDbForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for TrackIndexedDbForOriginCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.trackIndexedDBForOrigin";
    }
    impl<'a> ::SerializeCdpCommand for TrackIndexedDbForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.trackIndexedDBForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for TrackIndexedDbForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.trackIndexedDBForOrigin" {
                Ok ( < TrackIndexedDbForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Registers origin to be notified when an update occurs to its IndexedDB.\n\n# Command `Storage.trackIndexedDBForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::TrackIndexedDbForOriginCommand`](struct.TrackIndexedDbForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::TrackIndexedDbForOriginResponse`](struct.TrackIndexedDbForOriginResponse.html)"]
    pub struct TrackIndexedDbForOriginResponse;
    impl ::serde::Serialize for TrackIndexedDbForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TrackIndexedDbForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TrackIndexedDbForOriginResponse)
        }
    }
    impl ::CdpCommand for TrackIndexedDbForOriginResponse {
        const COMMAND_NAME: &'static str = "Storage.trackIndexedDBForOrigin";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for TrackIndexedDbForOriginCommand<'a> {
        type Response = TrackIndexedDbForOriginResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for TrackIndexedDbForOriginResponse {
        type Command = TrackIndexedDbForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unregisters origin from receiving notifications for cache storage.\n\n# Command `Storage.untrackCacheStorageForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::UntrackCacheStorageForOriginCommand`](struct.UntrackCacheStorageForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::UntrackCacheStorageForOriginResponse`](struct.UntrackCacheStorageForOriginResponse.html)"]
    pub struct UntrackCacheStorageForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for UntrackCacheStorageForOriginCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.untrackCacheStorageForOrigin";
    }
    impl<'a> ::SerializeCdpCommand for UntrackCacheStorageForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.untrackCacheStorageForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for UntrackCacheStorageForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.untrackCacheStorageForOrigin" {
                Ok ( < UntrackCacheStorageForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unregisters origin from receiving notifications for cache storage.\n\n# Command `Storage.untrackCacheStorageForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::UntrackCacheStorageForOriginCommand`](struct.UntrackCacheStorageForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::UntrackCacheStorageForOriginResponse`](struct.UntrackCacheStorageForOriginResponse.html)"]
    pub struct UntrackCacheStorageForOriginResponse;
    impl ::serde::Serialize for UntrackCacheStorageForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UntrackCacheStorageForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UntrackCacheStorageForOriginResponse)
        }
    }
    impl ::CdpCommand for UntrackCacheStorageForOriginResponse {
        const COMMAND_NAME: &'static str = "Storage.untrackCacheStorageForOrigin";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for UntrackCacheStorageForOriginCommand<'a> {
        type Response = UntrackCacheStorageForOriginResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UntrackCacheStorageForOriginResponse {
        type Command = UntrackCacheStorageForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unregisters origin from receiving notifications for IndexedDB.\n\n# Command `Storage.untrackIndexedDBForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::UntrackIndexedDbForOriginCommand`](struct.UntrackIndexedDbForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::UntrackIndexedDbForOriginResponse`](struct.UntrackIndexedDbForOriginResponse.html)"]
    pub struct UntrackIndexedDbForOriginCommand<'a> {
        #[serde(rename = "origin")]
        #[doc = "Security origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for UntrackIndexedDbForOriginCommand<'a> {
        const COMMAND_NAME: &'static str = "Storage.untrackIndexedDBForOrigin";
    }
    impl<'a> ::SerializeCdpCommand for UntrackIndexedDbForOriginCommand<'a> {
        fn command_name(&self) -> &str {
            "Storage.untrackIndexedDBForOrigin"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for UntrackIndexedDbForOriginCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.untrackIndexedDBForOrigin" {
                Ok ( < UntrackIndexedDbForOriginCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unregisters origin from receiving notifications for IndexedDB.\n\n# Command `Storage.untrackIndexedDBForOrigin`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Command Struct:* [`cdp::storage::UntrackIndexedDbForOriginCommand`](struct.UntrackIndexedDbForOriginCommand.html)  \n*Response Struct:* [`cdp::storage::UntrackIndexedDbForOriginResponse`](struct.UntrackIndexedDbForOriginResponse.html)"]
    pub struct UntrackIndexedDbForOriginResponse;
    impl ::serde::Serialize for UntrackIndexedDbForOriginResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UntrackIndexedDbForOriginResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UntrackIndexedDbForOriginResponse)
        }
    }
    impl ::CdpCommand for UntrackIndexedDbForOriginResponse {
        const COMMAND_NAME: &'static str = "Storage.untrackIndexedDBForOrigin";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for UntrackIndexedDbForOriginCommand<'a> {
        type Response = UntrackIndexedDbForOriginResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UntrackIndexedDbForOriginResponse {
        type Command = UntrackIndexedDbForOriginCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A cache's contents have been modified.\n\n# Event `Storage.cacheStorageContentUpdated`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Event Struct:* [`cdp::storage::CacheStorageContentUpdatedEvent`](struct.CacheStorageContentUpdatedEvent.html)"]
    pub struct CacheStorageContentUpdatedEvent<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to update."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "cacheName")]
        #[doc = "Name of cache in origin."]
        pub cache_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for CacheStorageContentUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "Storage.cacheStorageContentUpdated";
    }
    impl<'a> ::SerializeCdpEvent for CacheStorageContentUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Storage.cacheStorageContentUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for CacheStorageContentUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.cacheStorageContentUpdated" {
                Ok ( < CacheStorageContentUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> A cache has been added/deleted.\n\n# Event `Storage.cacheStorageListUpdated`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Event Struct:* [`cdp::storage::CacheStorageListUpdatedEvent`](struct.CacheStorageListUpdatedEvent.html)"]
    pub struct CacheStorageListUpdatedEvent<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to update."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for CacheStorageListUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "Storage.cacheStorageListUpdated";
    }
    impl<'a> ::SerializeCdpEvent for CacheStorageListUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Storage.cacheStorageListUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for CacheStorageListUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.cacheStorageListUpdated" {
                Ok ( < CacheStorageListUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The origin's IndexedDB object store has been modified.\n\n# Event `Storage.indexedDBContentUpdated`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Event Struct:* [`cdp::storage::IndexedDbContentUpdatedEvent`](struct.IndexedDbContentUpdatedEvent.html)"]
    pub struct IndexedDbContentUpdatedEvent<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to update."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "databaseName")]
        #[doc = "Database to update."]
        pub database_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectStoreName")]
        #[doc = "ObjectStore to update."]
        pub object_store_name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for IndexedDbContentUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "Storage.indexedDBContentUpdated";
    }
    impl<'a> ::SerializeCdpEvent for IndexedDbContentUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Storage.indexedDBContentUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for IndexedDbContentUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.indexedDBContentUpdated" {
                Ok ( < IndexedDbContentUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> The origin's IndexedDB database list has been modified.\n\n# Event `Storage.indexedDBListUpdated`\n\n*Domain Module:* [`cdp::storage`](index.html)  \n*Event Struct:* [`cdp::storage::IndexedDbListUpdatedEvent`](struct.IndexedDbListUpdatedEvent.html)"]
    pub struct IndexedDbListUpdatedEvent<'a> {
        #[serde(rename = "origin")]
        #[doc = "Origin to update."]
        pub origin: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for IndexedDbListUpdatedEvent<'a> {
        const EVENT_NAME: &'static str = "Storage.indexedDBListUpdated";
    }
    impl<'a> ::SerializeCdpEvent for IndexedDbListUpdatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Storage.indexedDBListUpdated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for IndexedDbListUpdatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Storage.indexedDBListUpdated" {
                Ok ( < IndexedDbListUpdatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enum of possible storage types."]
    pub enum StorageType {
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "cookies")]
        #[doc = "Represented as `\"cookies\"`."]
        Cookies,
        #[serde(rename = "file_systems")]
        #[doc = "Represented as `\"file_systems\"`."]
        FileSystems,
        #[serde(rename = "indexeddb")]
        #[doc = "Represented as `\"indexeddb\"`."]
        Indexeddb,
        #[serde(rename = "local_storage")]
        #[doc = "Represented as `\"local_storage\"`."]
        LocalStorage,
        #[serde(rename = "shader_cache")]
        #[doc = "Represented as `\"shader_cache\"`."]
        ShaderCache,
        #[serde(rename = "websql")]
        #[doc = "Represented as `\"websql\"`."]
        Websql,
        #[serde(rename = "service_workers")]
        #[doc = "Represented as `\"service_workers\"`."]
        ServiceWorkers,
        #[serde(rename = "cache_storage")]
        #[doc = "Represented as `\"cache_storage\"`."]
        CacheStorage,
        #[serde(rename = "all")]
        #[doc = "Represented as `\"all\"`."]
        All,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
    }
    impl StorageType {
        pub const ENUM_VALUES: &'static [StorageType] = &[
            StorageType::Appcache,
            StorageType::Cookies,
            StorageType::FileSystems,
            StorageType::Indexeddb,
            StorageType::LocalStorage,
            StorageType::ShaderCache,
            StorageType::Websql,
            StorageType::ServiceWorkers,
            StorageType::CacheStorage,
            StorageType::All,
            StorageType::Other,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "appcache",
            "cookies",
            "file_systems",
            "indexeddb",
            "local_storage",
            "shader_cache",
            "websql",
            "service_workers",
            "cache_storage",
            "all",
            "other",
        ];
    }
    impl ::std::str::FromStr for StorageType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "appcache" => Ok(StorageType::Appcache),
                "cookies" => Ok(StorageType::Cookies),
                "file_systems" => Ok(StorageType::FileSystems),
                "indexeddb" => Ok(StorageType::Indexeddb),
                "local_storage" => Ok(StorageType::LocalStorage),
                "shader_cache" => Ok(StorageType::ShaderCache),
                "websql" => Ok(StorageType::Websql),
                "service_workers" => Ok(StorageType::ServiceWorkers),
                "cache_storage" => Ok(StorageType::CacheStorage),
                "all" => Ok(StorageType::All),
                "other" => Ok(StorageType::Other),
                _ => Err(::ParseEnumError {
                    expected: StorageType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StorageType::Appcache => "appcache",
                    StorageType::Cookies => "cookies",
                    StorageType::FileSystems => "file_systems",
                    StorageType::Indexeddb => "indexeddb",
                    StorageType::LocalStorage => "local_storage",
                    StorageType::ShaderCache => "shader_cache",
                    StorageType::Websql => "websql",
                    StorageType::ServiceWorkers => "service_workers",
                    StorageType::CacheStorage => "cache_storage",
                    StorageType::All => "all",
                    StorageType::Other => "other",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Usage for a storage type."]
    pub struct UsageForType {
        #[serde(rename = "storageType")]
        #[doc = "Name of storage type."]
        pub storage_type: ::storage::StorageType,
        #[serde(rename = "usage")]
        #[doc = "Storage usage \\(bytes\\)."]
        pub usage: f64,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> The SystemInfo domain defines methods and events for querying low-level system information.\n\n# SystemInfo\n\n## Commands\n\n- [`SystemInfo.getInfo`](struct.GetInfoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns information about the system.\n\n##Types\n\n- [`GPUDevice`](struct.GpuDevice.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Describes a single graphics processor \\(GPU\\).\n- [`GPUInfo`](struct.GpuInfo.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Provides information about the GPU\\(s\\) on the system.\n"]
pub mod system_info {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about the system.\n\n# Command `SystemInfo.getInfo`\n\n*Domain Module:* [`cdp::system_info`](index.html)  \n*Command Struct:* [`cdp::system_info::GetInfoCommand`](struct.GetInfoCommand.html)  \n*Response Struct:* [`cdp::system_info::GetInfoResponse`](struct.GetInfoResponse.html)"]
    pub struct GetInfoCommand;
    impl ::serde::Serialize for GetInfoCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetInfoCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetInfoCommand)
        }
    }
    impl ::CdpCommand for GetInfoCommand {
        const COMMAND_NAME: &'static str = "SystemInfo.getInfo";
    }
    impl ::SerializeCdpCommand for GetInfoCommand {
        fn command_name(&self) -> &str {
            "SystemInfo.getInfo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetInfoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "SystemInfo.getInfo" {
                Ok(
                    <GetInfoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about the system.\n\n# Command `SystemInfo.getInfo`\n\n*Domain Module:* [`cdp::system_info`](index.html)  \n*Command Struct:* [`cdp::system_info::GetInfoCommand`](struct.GetInfoCommand.html)  \n*Response Struct:* [`cdp::system_info::GetInfoResponse`](struct.GetInfoResponse.html)"]
    pub struct GetInfoResponse<'a> {
        #[serde(rename = "gpu")]
        #[doc = "Information about the GPUs on the system."]
        pub gpu: ::system_info::GpuInfo<'a>,
        #[serde(rename = "modelName")]
        #[doc = "A platform-dependent description of the model of the machine. On Mac OS, this is, for\nexample, 'MacBookPro'. Will be the empty string if not supported."]
        pub model_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "modelVersion")]
        #[doc = "A platform-dependent description of the version of the machine. On Mac OS, this is, for\nexample, '10.1'. Will be the empty string if not supported."]
        pub model_version: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "commandLine")]
        #[doc = "The command line string used to launch the browser. Will be the empty string if not\nsupported."]
        pub command_line: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetInfoResponse<'a> {
        const COMMAND_NAME: &'static str = "SystemInfo.getInfo";
    }
    impl<'b> ::HasCdpResponse<'b> for GetInfoCommand {
        type Response = GetInfoResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetInfoResponse<'b> {
        type Command = GetInfoCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Describes a single graphics processor \\(GPU\\)."]
    pub struct GpuDevice<'a> {
        #[serde(rename = "vendorId")]
        #[doc = "PCI ID of the GPU vendor, if available; 0 otherwise."]
        pub vendor_id: f64,
        #[serde(rename = "deviceId")]
        #[doc = "PCI ID of the GPU device, if available; 0 otherwise."]
        pub device_id: f64,
        #[serde(rename = "vendorString")]
        #[doc = "String description of the GPU vendor, if the PCI ID is not available."]
        pub vendor_string: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "deviceString")]
        #[doc = "String description of the GPU device, if the PCI ID is not available."]
        pub device_string: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Provides information about the GPU\\(s\\) on the system."]
    pub struct GpuInfo<'a> {
        #[serde(rename = "devices")]
        #[doc = "The graphics devices on the system. Element 0 is the primary GPU."]
        pub devices: Vec<::system_info::GpuDevice<'a>>,
        #[serde(rename = "auxAttributes", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional dictionary of additional GPU related attributes."]
        pub aux_attributes: Option<::Empty>,
        #[serde(rename = "featureStatus", skip_serializing_if = "Option::is_none")]
        #[doc = "An optional dictionary of graphics features and their status."]
        pub feature_status: Option<::Empty>,
        #[serde(rename = "driverBugWorkarounds")]
        #[doc = "An optional array of GPU driver bug workarounds."]
        pub driver_bug_workarounds: Vec<::std::borrow::Cow<'a, str>>,
    }
}
#[doc = "Supports additional targets discovery and allows to attach to them.\n\n# Target\n\n## Commands\n\n- [`Target.activateTarget`](struct.ActivateTargetCommand.html)\n\n  Activates \\(focuses\\) the target.\n- [`Target.attachToTarget`](struct.AttachToTargetCommand.html)\n\n  Attaches to the target with given id.\n- [`Target.attachToBrowserTarget`](struct.AttachToBrowserTargetCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Attaches to the browser target, only uses flat sessionId mode.\n- [`Target.closeTarget`](struct.CloseTargetCommand.html)\n\n  Closes the target. If the target is a page that gets closed too.\n- [`Target.exposeDevToolsProtocol`](struct.ExposeDevToolsProtocolCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Inject object to the target's main frame that provides a communication\n  channel with browser target.\n  \n  Injected object will be available as `window\\[bindingName\\]`.\n  \n  The object has the follwing API:\n  - `binding.send\\(json\\)` - a method to send messages over the remote debugging protocol\n  - `binding.onmessage = json => handleMessage\\(json\\)` - a callback that will be called for the protocol notifications and command responses.\n- [`Target.createBrowserContext`](struct.CreateBrowserContextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than\n  one.\n- [`Target.getBrowserContexts`](struct.GetBrowserContextsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns all browser contexts created with `Target.createBrowserContext` method.\n- [`Target.createTarget`](struct.CreateTargetCommand.html)\n\n  Creates a new page.\n- [`Target.detachFromTarget`](struct.DetachFromTargetCommand.html)\n\n  Detaches session with given id.\n- [`Target.disposeBrowserContext`](struct.DisposeBrowserContextCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Deletes a BrowserContext. All the belonging pages will be closed without calling their\n  beforeunload hooks.\n- [`Target.getTargetInfo`](struct.GetTargetInfoCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns information about a target.\n- [`Target.getTargets`](struct.GetTargetsCommand.html)\n\n  Retrieves a list of available targets.\n- [`Target.sendMessageToTarget`](struct.SendMessageToTargetCommand.html)\n\n  Sends protocol message over session with given id.\n- [`Target.setAutoAttach`](struct.SetAutoAttachCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Controls whether to automatically attach to new targets which are considered to be related to\n  this one. When turned on, attaches to all existing related targets as well. When turned off,\n  automatically detaches from all currently attached targets.\n- [`Target.setDiscoverTargets`](struct.SetDiscoverTargetsCommand.html)\n\n  Controls whether to discover available targets and notify via\n  `targetCreated/targetInfoChanged/targetDestroyed` events.\n- [`Target.setRemoteLocations`](struct.SetRemoteLocationsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables target discovery for the specified locations, when `setDiscoverTargets` was set to\n  `true`.\n\n## Events\n\n- [`Target.attachedToTarget`](struct.AttachedToTargetEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when attached to target because of auto-attach or `attachToTarget` command.\n- [`Target.detachedFromTarget`](struct.DetachedFromTargetEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Issued when detached from target for any reason \\(including `detachFromTarget` command\\). Can be\n  issued multiple times per target if multiple sessions have been attached to it.\n- [`Target.receivedMessageFromTarget`](struct.ReceivedMessageFromTargetEvent.html)\n\n  Notifies about a new protocol message received from the session \\(as reported in\n  `attachedToTarget` event\\).\n- [`Target.targetCreated`](struct.TargetCreatedEvent.html)\n\n  Issued when a possible inspection target is created.\n- [`Target.targetDestroyed`](struct.TargetDestroyedEvent.html)\n\n  Issued when a target is destroyed.\n- [`Target.targetCrashed`](struct.TargetCrashedEvent.html)\n\n  Issued when a target has crashed.\n- [`Target.targetInfoChanged`](struct.TargetInfoChangedEvent.html)\n\n  Issued when some information about a target has changed. This only happens between\n  `targetCreated` and `targetDestroyed`.\n\n##Types\n\n- [`TargetID`](type.TargetId.html)\n- [`SessionID`](type.SessionId.html)\n\n  Unique identifier of attached debugging session.\n- [`BrowserContextID`](type.BrowserContextId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`TargetInfo`](struct.TargetInfo.html)\n- [`RemoteLocation`](struct.RemoteLocation.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n"]
pub mod target {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Activates \\(focuses\\) the target.\n\n# Command `Target.activateTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::ActivateTargetCommand`](struct.ActivateTargetCommand.html)  \n*Response Struct:* [`cdp::target::ActivateTargetResponse`](struct.ActivateTargetResponse.html)"]
    pub struct ActivateTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
    }
    impl<'a> ::CdpCommand for ActivateTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.activateTarget";
    }
    impl<'a> ::SerializeCdpCommand for ActivateTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.activateTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ActivateTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.activateTarget" {
                Ok(
                    <ActivateTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Activates \\(focuses\\) the target.\n\n# Command `Target.activateTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::ActivateTargetCommand`](struct.ActivateTargetCommand.html)  \n*Response Struct:* [`cdp::target::ActivateTargetResponse`](struct.ActivateTargetResponse.html)"]
    pub struct ActivateTargetResponse;
    impl ::serde::Serialize for ActivateTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ActivateTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ActivateTargetResponse)
        }
    }
    impl ::CdpCommand for ActivateTargetResponse {
        const COMMAND_NAME: &'static str = "Target.activateTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ActivateTargetCommand<'a> {
        type Response = ActivateTargetResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ActivateTargetResponse {
        type Command = ActivateTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Attaches to the target with given id.\n\n# Command `Target.attachToTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::AttachToTargetCommand`](struct.AttachToTargetCommand.html)  \n*Response Struct:* [`cdp::target::AttachToTargetResponse`](struct.AttachToTargetResponse.html)"]
    pub struct AttachToTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
        #[serde(rename = "flatten", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables \"flat\" access to the session via specifying sessionId attribute in the commands."]
        pub flatten: Option<bool>,
    }
    impl<'a> ::CdpCommand for AttachToTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.attachToTarget";
    }
    impl<'a> ::SerializeCdpCommand for AttachToTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.attachToTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AttachToTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.attachToTarget" {
                Ok(
                    <AttachToTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Attaches to the target with given id.\n\n# Command `Target.attachToTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::AttachToTargetCommand`](struct.AttachToTargetCommand.html)  \n*Response Struct:* [`cdp::target::AttachToTargetResponse`](struct.AttachToTargetResponse.html)"]
    pub struct AttachToTargetResponse<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Id assigned to the session."]
        pub session_id: ::target::SessionId<'a>,
    }
    impl<'a> ::CdpCommand for AttachToTargetResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.attachToTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AttachToTargetCommand<'a> {
        type Response = AttachToTargetResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AttachToTargetResponse<'b> {
        type Command = AttachToTargetCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attaches to the browser target, only uses flat sessionId mode.\n\n# Command `Target.attachToBrowserTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::AttachToBrowserTargetCommand`](struct.AttachToBrowserTargetCommand.html)  \n*Response Struct:* [`cdp::target::AttachToBrowserTargetResponse`](struct.AttachToBrowserTargetResponse.html)"]
    pub struct AttachToBrowserTargetCommand;
    impl ::serde::Serialize for AttachToBrowserTargetCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AttachToBrowserTargetCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| AttachToBrowserTargetCommand)
        }
    }
    impl ::CdpCommand for AttachToBrowserTargetCommand {
        const COMMAND_NAME: &'static str = "Target.attachToBrowserTarget";
    }
    impl ::SerializeCdpCommand for AttachToBrowserTargetCommand {
        fn command_name(&self) -> &str {
            "Target.attachToBrowserTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for AttachToBrowserTargetCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.attachToBrowserTarget" {
                Ok ( < AttachToBrowserTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Attaches to the browser target, only uses flat sessionId mode.\n\n# Command `Target.attachToBrowserTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::AttachToBrowserTargetCommand`](struct.AttachToBrowserTargetCommand.html)  \n*Response Struct:* [`cdp::target::AttachToBrowserTargetResponse`](struct.AttachToBrowserTargetResponse.html)"]
    pub struct AttachToBrowserTargetResponse<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Id assigned to the session."]
        pub session_id: ::target::SessionId<'a>,
    }
    impl<'a> ::CdpCommand for AttachToBrowserTargetResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.attachToBrowserTarget";
    }
    impl<'b> ::HasCdpResponse<'b> for AttachToBrowserTargetCommand {
        type Response = AttachToBrowserTargetResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AttachToBrowserTargetResponse<'b> {
        type Command = AttachToBrowserTargetCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Closes the target. If the target is a page that gets closed too.\n\n# Command `Target.closeTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CloseTargetCommand`](struct.CloseTargetCommand.html)  \n*Response Struct:* [`cdp::target::CloseTargetResponse`](struct.CloseTargetResponse.html)"]
    pub struct CloseTargetCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
    }
    impl<'a> ::CdpCommand for CloseTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.closeTarget";
    }
    impl<'a> ::SerializeCdpCommand for CloseTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.closeTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CloseTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.closeTarget" {
                Ok(
                    <CloseTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Closes the target. If the target is a page that gets closed too.\n\n# Command `Target.closeTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CloseTargetCommand`](struct.CloseTargetCommand.html)  \n*Response Struct:* [`cdp::target::CloseTargetResponse`](struct.CloseTargetResponse.html)"]
    pub struct CloseTargetResponse {
        #[serde(rename = "success")]
        pub success: bool,
    }
    impl ::CdpCommand for CloseTargetResponse {
        const COMMAND_NAME: &'static str = "Target.closeTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CloseTargetCommand<'a> {
        type Response = CloseTargetResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CloseTargetResponse {
        type Command = CloseTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inject object to the target's main frame that provides a communication\nchannel with browser target.\n\nInjected object will be available as `window\\[bindingName\\]`.\n\nThe object has the follwing API:\n- `binding.send\\(json\\)` - a method to send messages over the remote debugging protocol\n- `binding.onmessage = json => handleMessage\\(json\\)` - a callback that will be called for the protocol notifications and command responses.\n\n# Command `Target.exposeDevToolsProtocol`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::ExposeDevToolsProtocolCommand`](struct.ExposeDevToolsProtocolCommand.html)  \n*Response Struct:* [`cdp::target::ExposeDevToolsProtocolResponse`](struct.ExposeDevToolsProtocolResponse.html)"]
    pub struct ExposeDevToolsProtocolCommand<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
        #[serde(rename = "bindingName", skip_serializing_if = "Option::is_none")]
        #[doc = "Binding name, 'cdp' if not specified."]
        pub binding_name: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for ExposeDevToolsProtocolCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.exposeDevToolsProtocol";
    }
    impl<'a> ::SerializeCdpCommand for ExposeDevToolsProtocolCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.exposeDevToolsProtocol"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ExposeDevToolsProtocolCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.exposeDevToolsProtocol" {
                Ok ( < ExposeDevToolsProtocolCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Inject object to the target's main frame that provides a communication\nchannel with browser target.\n\nInjected object will be available as `window\\[bindingName\\]`.\n\nThe object has the follwing API:\n- `binding.send\\(json\\)` - a method to send messages over the remote debugging protocol\n- `binding.onmessage = json => handleMessage\\(json\\)` - a callback that will be called for the protocol notifications and command responses.\n\n# Command `Target.exposeDevToolsProtocol`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::ExposeDevToolsProtocolCommand`](struct.ExposeDevToolsProtocolCommand.html)  \n*Response Struct:* [`cdp::target::ExposeDevToolsProtocolResponse`](struct.ExposeDevToolsProtocolResponse.html)"]
    pub struct ExposeDevToolsProtocolResponse;
    impl ::serde::Serialize for ExposeDevToolsProtocolResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExposeDevToolsProtocolResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ExposeDevToolsProtocolResponse)
        }
    }
    impl ::CdpCommand for ExposeDevToolsProtocolResponse {
        const COMMAND_NAME: &'static str = "Target.exposeDevToolsProtocol";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ExposeDevToolsProtocolCommand<'a> {
        type Response = ExposeDevToolsProtocolResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ExposeDevToolsProtocolResponse {
        type Command = ExposeDevToolsProtocolCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than\none.\n\n# Command `Target.createBrowserContext`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CreateBrowserContextCommand`](struct.CreateBrowserContextCommand.html)  \n*Response Struct:* [`cdp::target::CreateBrowserContextResponse`](struct.CreateBrowserContextResponse.html)"]
    pub struct CreateBrowserContextCommand;
    impl ::serde::Serialize for CreateBrowserContextCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateBrowserContextCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CreateBrowserContextCommand)
        }
    }
    impl ::CdpCommand for CreateBrowserContextCommand {
        const COMMAND_NAME: &'static str = "Target.createBrowserContext";
    }
    impl ::SerializeCdpCommand for CreateBrowserContextCommand {
        fn command_name(&self) -> &str {
            "Target.createBrowserContext"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CreateBrowserContextCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.createBrowserContext" {
                Ok ( < CreateBrowserContextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than\none.\n\n# Command `Target.createBrowserContext`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CreateBrowserContextCommand`](struct.CreateBrowserContextCommand.html)  \n*Response Struct:* [`cdp::target::CreateBrowserContextResponse`](struct.CreateBrowserContextResponse.html)"]
    pub struct CreateBrowserContextResponse<'a> {
        #[serde(rename = "browserContextId")]
        #[doc = "The id of the context created."]
        pub browser_context_id: ::target::BrowserContextId<'a>,
    }
    impl<'a> ::CdpCommand for CreateBrowserContextResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.createBrowserContext";
    }
    impl<'b> ::HasCdpResponse<'b> for CreateBrowserContextCommand {
        type Response = CreateBrowserContextResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CreateBrowserContextResponse<'b> {
        type Command = CreateBrowserContextCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser contexts created with `Target.createBrowserContext` method.\n\n# Command `Target.getBrowserContexts`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetBrowserContextsCommand`](struct.GetBrowserContextsCommand.html)  \n*Response Struct:* [`cdp::target::GetBrowserContextsResponse`](struct.GetBrowserContextsResponse.html)"]
    pub struct GetBrowserContextsCommand;
    impl ::serde::Serialize for GetBrowserContextsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetBrowserContextsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetBrowserContextsCommand)
        }
    }
    impl ::CdpCommand for GetBrowserContextsCommand {
        const COMMAND_NAME: &'static str = "Target.getBrowserContexts";
    }
    impl ::SerializeCdpCommand for GetBrowserContextsCommand {
        fn command_name(&self) -> &str {
            "Target.getBrowserContexts"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetBrowserContextsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.getBrowserContexts" {
                Ok ( < GetBrowserContextsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns all browser contexts created with `Target.createBrowserContext` method.\n\n# Command `Target.getBrowserContexts`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetBrowserContextsCommand`](struct.GetBrowserContextsCommand.html)  \n*Response Struct:* [`cdp::target::GetBrowserContextsResponse`](struct.GetBrowserContextsResponse.html)"]
    pub struct GetBrowserContextsResponse<'a> {
        #[serde(rename = "browserContextIds")]
        #[doc = "An array of browser context ids."]
        pub browser_context_ids: Vec<::target::BrowserContextId<'a>>,
    }
    impl<'a> ::CdpCommand for GetBrowserContextsResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.getBrowserContexts";
    }
    impl<'b> ::HasCdpResponse<'b> for GetBrowserContextsCommand {
        type Response = GetBrowserContextsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetBrowserContextsResponse<'b> {
        type Command = GetBrowserContextsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Creates a new page.\n\n# Command `Target.createTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CreateTargetCommand`](struct.CreateTargetCommand.html)  \n*Response Struct:* [`cdp::target::CreateTargetResponse`](struct.CreateTargetResponse.html)"]
    pub struct CreateTargetCommand<'a> {
        #[serde(rename = "url")]
        #[doc = "The initial URL the page will be navigated to."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "width", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame width in DIP \\(headless chrome only\\)."]
        pub width: Option<i32>,
        #[serde(rename = "height", skip_serializing_if = "Option::is_none")]
        #[doc = "Frame height in DIP \\(headless chrome only\\)."]
        pub height: Option<i32>,
        #[serde(rename = "browserContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "The browser context to create the page in."]
        pub browser_context_id: Option<::target::BrowserContextId<'a>>,
        #[serde(rename = "enableBeginFrameControl", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether BeginFrames for this target will be controlled via DevTools \\(headless chrome only,\nnot supported on MacOS yet, false by default\\)."]
        pub enable_begin_frame_control: Option<bool>,
    }
    impl<'a> ::CdpCommand for CreateTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.createTarget";
    }
    impl<'a> ::SerializeCdpCommand for CreateTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.createTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CreateTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.createTarget" {
                Ok(
                    <CreateTargetCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Creates a new page.\n\n# Command `Target.createTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::CreateTargetCommand`](struct.CreateTargetCommand.html)  \n*Response Struct:* [`cdp::target::CreateTargetResponse`](struct.CreateTargetResponse.html)"]
    pub struct CreateTargetResponse<'a> {
        #[serde(rename = "targetId")]
        #[doc = "The id of the page opened."]
        pub target_id: ::target::TargetId<'a>,
    }
    impl<'a> ::CdpCommand for CreateTargetResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.createTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CreateTargetCommand<'a> {
        type Response = CreateTargetResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CreateTargetResponse<'b> {
        type Command = CreateTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Detaches session with given id.\n\n# Command `Target.detachFromTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::DetachFromTargetCommand`](struct.DetachFromTargetCommand.html)  \n*Response Struct:* [`cdp::target::DetachFromTargetResponse`](struct.DetachFromTargetResponse.html)"]
    pub struct DetachFromTargetCommand<'a> {
        #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
        #[doc = "Session to detach."]
        pub session_id: Option<::target::SessionId<'a>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    impl<'a> ::CdpCommand for DetachFromTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.detachFromTarget";
    }
    impl<'a> ::SerializeCdpCommand for DetachFromTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.detachFromTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DetachFromTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.detachFromTarget" {
                Ok ( < DetachFromTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Detaches session with given id.\n\n# Command `Target.detachFromTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::DetachFromTargetCommand`](struct.DetachFromTargetCommand.html)  \n*Response Struct:* [`cdp::target::DetachFromTargetResponse`](struct.DetachFromTargetResponse.html)"]
    pub struct DetachFromTargetResponse;
    impl ::serde::Serialize for DetachFromTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DetachFromTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DetachFromTargetResponse)
        }
    }
    impl ::CdpCommand for DetachFromTargetResponse {
        const COMMAND_NAME: &'static str = "Target.detachFromTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DetachFromTargetCommand<'a> {
        type Response = DetachFromTargetResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DetachFromTargetResponse {
        type Command = DetachFromTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a BrowserContext. All the belonging pages will be closed without calling their\nbeforeunload hooks.\n\n# Command `Target.disposeBrowserContext`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::DisposeBrowserContextCommand`](struct.DisposeBrowserContextCommand.html)  \n*Response Struct:* [`cdp::target::DisposeBrowserContextResponse`](struct.DisposeBrowserContextResponse.html)"]
    pub struct DisposeBrowserContextCommand<'a> {
        #[serde(rename = "browserContextId")]
        pub browser_context_id: ::target::BrowserContextId<'a>,
    }
    impl<'a> ::CdpCommand for DisposeBrowserContextCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.disposeBrowserContext";
    }
    impl<'a> ::SerializeCdpCommand for DisposeBrowserContextCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.disposeBrowserContext"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for DisposeBrowserContextCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.disposeBrowserContext" {
                Ok ( < DisposeBrowserContextCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Deletes a BrowserContext. All the belonging pages will be closed without calling their\nbeforeunload hooks.\n\n# Command `Target.disposeBrowserContext`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::DisposeBrowserContextCommand`](struct.DisposeBrowserContextCommand.html)  \n*Response Struct:* [`cdp::target::DisposeBrowserContextResponse`](struct.DisposeBrowserContextResponse.html)"]
    pub struct DisposeBrowserContextResponse;
    impl ::serde::Serialize for DisposeBrowserContextResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisposeBrowserContextResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisposeBrowserContextResponse)
        }
    }
    impl ::CdpCommand for DisposeBrowserContextResponse {
        const COMMAND_NAME: &'static str = "Target.disposeBrowserContext";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for DisposeBrowserContextCommand<'a> {
        type Response = DisposeBrowserContextResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisposeBrowserContextResponse {
        type Command = DisposeBrowserContextCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about a target.\n\n# Command `Target.getTargetInfo`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetTargetInfoCommand`](struct.GetTargetInfoCommand.html)  \n*Response Struct:* [`cdp::target::GetTargetInfoResponse`](struct.GetTargetInfoResponse.html)"]
    pub struct GetTargetInfoCommand<'a> {
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    impl<'a> ::CdpCommand for GetTargetInfoCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.getTargetInfo";
    }
    impl<'a> ::SerializeCdpCommand for GetTargetInfoCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.getTargetInfo"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetTargetInfoCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.getTargetInfo" {
                Ok(
                    <GetTargetInfoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns information about a target.\n\n# Command `Target.getTargetInfo`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetTargetInfoCommand`](struct.GetTargetInfoCommand.html)  \n*Response Struct:* [`cdp::target::GetTargetInfoResponse`](struct.GetTargetInfoResponse.html)"]
    pub struct GetTargetInfoResponse<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::target::TargetInfo<'a>,
    }
    impl<'a> ::CdpCommand for GetTargetInfoResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.getTargetInfo";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetTargetInfoCommand<'a> {
        type Response = GetTargetInfoResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetTargetInfoResponse<'b> {
        type Command = GetTargetInfoCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Retrieves a list of available targets.\n\n# Command `Target.getTargets`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetTargetsCommand`](struct.GetTargetsCommand.html)  \n*Response Struct:* [`cdp::target::GetTargetsResponse`](struct.GetTargetsResponse.html)"]
    pub struct GetTargetsCommand;
    impl ::serde::Serialize for GetTargetsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetTargetsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetTargetsCommand)
        }
    }
    impl ::CdpCommand for GetTargetsCommand {
        const COMMAND_NAME: &'static str = "Target.getTargets";
    }
    impl ::SerializeCdpCommand for GetTargetsCommand {
        fn command_name(&self) -> &str {
            "Target.getTargets"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetTargetsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.getTargets" {
                Ok(
                    <GetTargetsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Retrieves a list of available targets.\n\n# Command `Target.getTargets`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::GetTargetsCommand`](struct.GetTargetsCommand.html)  \n*Response Struct:* [`cdp::target::GetTargetsResponse`](struct.GetTargetsResponse.html)"]
    pub struct GetTargetsResponse<'a> {
        #[serde(rename = "targetInfos")]
        #[doc = "The list of targets."]
        pub target_infos: Vec<::target::TargetInfo<'a>>,
    }
    impl<'a> ::CdpCommand for GetTargetsResponse<'a> {
        const COMMAND_NAME: &'static str = "Target.getTargets";
    }
    impl<'b> ::HasCdpResponse<'b> for GetTargetsCommand {
        type Response = GetTargetsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetTargetsResponse<'b> {
        type Command = GetTargetsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sends protocol message over session with given id.\n\n# Command `Target.sendMessageToTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SendMessageToTargetCommand`](struct.SendMessageToTargetCommand.html)  \n*Response Struct:* [`cdp::target::SendMessageToTargetResponse`](struct.SendMessageToTargetResponse.html)"]
    pub struct SendMessageToTargetCommand<'a> {
        #[serde(rename = "message")]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the session."]
        pub session_id: Option<::target::SessionId<'a>>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    impl<'a> ::CdpCommand for SendMessageToTargetCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.sendMessageToTarget";
    }
    impl<'a> ::SerializeCdpCommand for SendMessageToTargetCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.sendMessageToTarget"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SendMessageToTargetCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.sendMessageToTarget" {
                Ok ( < SendMessageToTargetCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Sends protocol message over session with given id.\n\n# Command `Target.sendMessageToTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SendMessageToTargetCommand`](struct.SendMessageToTargetCommand.html)  \n*Response Struct:* [`cdp::target::SendMessageToTargetResponse`](struct.SendMessageToTargetResponse.html)"]
    pub struct SendMessageToTargetResponse;
    impl ::serde::Serialize for SendMessageToTargetResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SendMessageToTargetResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SendMessageToTargetResponse)
        }
    }
    impl ::CdpCommand for SendMessageToTargetResponse {
        const COMMAND_NAME: &'static str = "Target.sendMessageToTarget";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SendMessageToTargetCommand<'a> {
        type Response = SendMessageToTargetResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SendMessageToTargetResponse {
        type Command = SendMessageToTargetCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to automatically attach to new targets which are considered to be related to\nthis one. When turned on, attaches to all existing related targets as well. When turned off,\nautomatically detaches from all currently attached targets.\n\n# Command `Target.setAutoAttach`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetAutoAttachCommand`](struct.SetAutoAttachCommand.html)  \n*Response Struct:* [`cdp::target::SetAutoAttachResponse`](struct.SetAutoAttachResponse.html)"]
    pub struct SetAutoAttachCommand {
        #[serde(rename = "autoAttach")]
        #[doc = "Whether to auto-attach to related targets."]
        pub auto_attach: bool,
        #[serde(rename = "waitForDebuggerOnStart")]
        #[doc = "Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`\nto run paused targets."]
        pub wait_for_debugger_on_start: bool,
        #[serde(rename = "flatten", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables \"flat\" access to the session via specifying sessionId attribute in the commands."]
        pub flatten: Option<bool>,
    }
    impl ::CdpCommand for SetAutoAttachCommand {
        const COMMAND_NAME: &'static str = "Target.setAutoAttach";
    }
    impl ::SerializeCdpCommand for SetAutoAttachCommand {
        fn command_name(&self) -> &str {
            "Target.setAutoAttach"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetAutoAttachCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setAutoAttach" {
                Ok(
                    <SetAutoAttachCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Controls whether to automatically attach to new targets which are considered to be related to\nthis one. When turned on, attaches to all existing related targets as well. When turned off,\nautomatically detaches from all currently attached targets.\n\n# Command `Target.setAutoAttach`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetAutoAttachCommand`](struct.SetAutoAttachCommand.html)  \n*Response Struct:* [`cdp::target::SetAutoAttachResponse`](struct.SetAutoAttachResponse.html)"]
    pub struct SetAutoAttachResponse;
    impl ::serde::Serialize for SetAutoAttachResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAutoAttachResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAutoAttachResponse)
        }
    }
    impl ::CdpCommand for SetAutoAttachResponse {
        const COMMAND_NAME: &'static str = "Target.setAutoAttach";
    }
    impl<'b> ::HasCdpResponse<'b> for SetAutoAttachCommand {
        type Response = SetAutoAttachResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAutoAttachResponse {
        type Command = SetAutoAttachCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Controls whether to discover available targets and notify via\n`targetCreated/targetInfoChanged/targetDestroyed` events.\n\n# Command `Target.setDiscoverTargets`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetDiscoverTargetsCommand`](struct.SetDiscoverTargetsCommand.html)  \n*Response Struct:* [`cdp::target::SetDiscoverTargetsResponse`](struct.SetDiscoverTargetsResponse.html)"]
    pub struct SetDiscoverTargetsCommand {
        #[serde(rename = "discover")]
        #[doc = "Whether to discover available targets."]
        pub discover: bool,
    }
    impl ::CdpCommand for SetDiscoverTargetsCommand {
        const COMMAND_NAME: &'static str = "Target.setDiscoverTargets";
    }
    impl ::SerializeCdpCommand for SetDiscoverTargetsCommand {
        fn command_name(&self) -> &str {
            "Target.setDiscoverTargets"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetDiscoverTargetsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setDiscoverTargets" {
                Ok ( < SetDiscoverTargetsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Controls whether to discover available targets and notify via\n`targetCreated/targetInfoChanged/targetDestroyed` events.\n\n# Command `Target.setDiscoverTargets`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetDiscoverTargetsCommand`](struct.SetDiscoverTargetsCommand.html)  \n*Response Struct:* [`cdp::target::SetDiscoverTargetsResponse`](struct.SetDiscoverTargetsResponse.html)"]
    pub struct SetDiscoverTargetsResponse;
    impl ::serde::Serialize for SetDiscoverTargetsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetDiscoverTargetsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetDiscoverTargetsResponse)
        }
    }
    impl ::CdpCommand for SetDiscoverTargetsResponse {
        const COMMAND_NAME: &'static str = "Target.setDiscoverTargets";
    }
    impl<'b> ::HasCdpResponse<'b> for SetDiscoverTargetsCommand {
        type Response = SetDiscoverTargetsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetDiscoverTargetsResponse {
        type Command = SetDiscoverTargetsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables target discovery for the specified locations, when `setDiscoverTargets` was set to\n`true`.\n\n# Command `Target.setRemoteLocations`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetRemoteLocationsCommand`](struct.SetRemoteLocationsCommand.html)  \n*Response Struct:* [`cdp::target::SetRemoteLocationsResponse`](struct.SetRemoteLocationsResponse.html)"]
    pub struct SetRemoteLocationsCommand<'a> {
        #[serde(rename = "locations")]
        #[doc = "List of remote locations."]
        pub locations: Vec<::target::RemoteLocation<'a>>,
    }
    impl<'a> ::CdpCommand for SetRemoteLocationsCommand<'a> {
        const COMMAND_NAME: &'static str = "Target.setRemoteLocations";
    }
    impl<'a> ::SerializeCdpCommand for SetRemoteLocationsCommand<'a> {
        fn command_name(&self) -> &str {
            "Target.setRemoteLocations"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetRemoteLocationsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.setRemoteLocations" {
                Ok ( < SetRemoteLocationsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables target discovery for the specified locations, when `setDiscoverTargets` was set to\n`true`.\n\n# Command `Target.setRemoteLocations`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Command Struct:* [`cdp::target::SetRemoteLocationsCommand`](struct.SetRemoteLocationsCommand.html)  \n*Response Struct:* [`cdp::target::SetRemoteLocationsResponse`](struct.SetRemoteLocationsResponse.html)"]
    pub struct SetRemoteLocationsResponse;
    impl ::serde::Serialize for SetRemoteLocationsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetRemoteLocationsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetRemoteLocationsResponse)
        }
    }
    impl ::CdpCommand for SetRemoteLocationsResponse {
        const COMMAND_NAME: &'static str = "Target.setRemoteLocations";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetRemoteLocationsCommand<'a> {
        type Response = SetRemoteLocationsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetRemoteLocationsResponse {
        type Command = SetRemoteLocationsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when attached to target because of auto-attach or `attachToTarget` command.\n\n# Event `Target.attachedToTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::AttachedToTargetEvent`](struct.AttachedToTargetEvent.html)"]
    pub struct AttachedToTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Identifier assigned to the session used to send/receive messages."]
        pub session_id: ::target::SessionId<'a>,
        #[serde(rename = "targetInfo")]
        pub target_info: ::target::TargetInfo<'a>,
        #[serde(rename = "waitingForDebugger")]
        pub waiting_for_debugger: bool,
    }
    impl<'a> ::CdpEvent for AttachedToTargetEvent<'a> {
        const EVENT_NAME: &'static str = "Target.attachedToTarget";
    }
    impl<'a> ::SerializeCdpEvent for AttachedToTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.attachedToTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AttachedToTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.attachedToTarget" {
                Ok(
                    <AttachedToTargetEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Issued when detached from target for any reason \\(including `detachFromTarget` command\\). Can be\nissued multiple times per target if multiple sessions have been attached to it.\n\n# Event `Target.detachedFromTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::DetachedFromTargetEvent`](struct.DetachedFromTargetEvent.html)"]
    pub struct DetachedFromTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Detached session identifier."]
        pub session_id: ::target::SessionId<'a>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    impl<'a> ::CdpEvent for DetachedFromTargetEvent<'a> {
        const EVENT_NAME: &'static str = "Target.detachedFromTarget";
    }
    impl<'a> ::SerializeCdpEvent for DetachedFromTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.detachedFromTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for DetachedFromTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.detachedFromTarget" {
                Ok ( < DetachedFromTargetEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Notifies about a new protocol message received from the session \\(as reported in\n`attachedToTarget` event\\).\n\n# Event `Target.receivedMessageFromTarget`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::ReceivedMessageFromTargetEvent`](struct.ReceivedMessageFromTargetEvent.html)"]
    pub struct ReceivedMessageFromTargetEvent<'a> {
        #[serde(rename = "sessionId")]
        #[doc = "Identifier of a session which sends a message."]
        pub session_id: ::target::SessionId<'a>,
        #[serde(rename = "message")]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "targetId", skip_serializing_if = "Option::is_none")]
        #[doc = "Deprecated."]
        #[deprecated]
        pub target_id: Option<::target::TargetId<'a>>,
    }
    impl<'a> ::CdpEvent for ReceivedMessageFromTargetEvent<'a> {
        const EVENT_NAME: &'static str = "Target.receivedMessageFromTarget";
    }
    impl<'a> ::SerializeCdpEvent for ReceivedMessageFromTargetEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.receivedMessageFromTarget"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ReceivedMessageFromTargetEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.receivedMessageFromTarget" {
                Ok ( < ReceivedMessageFromTargetEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when a possible inspection target is created.\n\n# Event `Target.targetCreated`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::TargetCreatedEvent`](struct.TargetCreatedEvent.html)"]
    pub struct TargetCreatedEvent<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::target::TargetInfo<'a>,
    }
    impl<'a> ::CdpEvent for TargetCreatedEvent<'a> {
        const EVENT_NAME: &'static str = "Target.targetCreated";
    }
    impl<'a> ::SerializeCdpEvent for TargetCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for TargetCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetCreated" {
                Ok(
                    <TargetCreatedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when a target is destroyed.\n\n# Event `Target.targetDestroyed`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::TargetDestroyedEvent`](struct.TargetDestroyedEvent.html)"]
    pub struct TargetDestroyedEvent<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
    }
    impl<'a> ::CdpEvent for TargetDestroyedEvent<'a> {
        const EVENT_NAME: &'static str = "Target.targetDestroyed";
    }
    impl<'a> ::SerializeCdpEvent for TargetDestroyedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetDestroyed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for TargetDestroyedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetDestroyed" {
                Ok(
                    <TargetDestroyedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when a target has crashed.\n\n# Event `Target.targetCrashed`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::TargetCrashedEvent`](struct.TargetCrashedEvent.html)"]
    pub struct TargetCrashedEvent<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
        #[serde(rename = "status")]
        #[doc = "Termination status type."]
        pub status: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "errorCode")]
        #[doc = "Termination error code."]
        pub error_code: i32,
    }
    impl<'a> ::CdpEvent for TargetCrashedEvent<'a> {
        const EVENT_NAME: &'static str = "Target.targetCrashed";
    }
    impl<'a> ::SerializeCdpEvent for TargetCrashedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetCrashed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for TargetCrashedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetCrashed" {
                Ok(
                    <TargetCrashedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when some information about a target has changed. This only happens between\n`targetCreated` and `targetDestroyed`.\n\n# Event `Target.targetInfoChanged`\n\n*Domain Module:* [`cdp::target`](index.html)  \n*Event Struct:* [`cdp::target::TargetInfoChangedEvent`](struct.TargetInfoChangedEvent.html)"]
    pub struct TargetInfoChangedEvent<'a> {
        #[serde(rename = "targetInfo")]
        pub target_info: ::target::TargetInfo<'a>,
    }
    impl<'a> ::CdpEvent for TargetInfoChangedEvent<'a> {
        const EVENT_NAME: &'static str = "Target.targetInfoChanged";
    }
    impl<'a> ::SerializeCdpEvent for TargetInfoChangedEvent<'a> {
        fn event_name(&self) -> &str {
            "Target.targetInfoChanged"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for TargetInfoChangedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Target.targetInfoChanged" {
                Ok(
                    <TargetInfoChangedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    pub type TargetId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique identifier of attached debugging session."]
    pub type SessionId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub type BrowserContextId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    pub struct TargetInfo<'a> {
        #[serde(rename = "targetId")]
        pub target_id: ::target::TargetId<'a>,
        #[serde(rename = "type")]
        pub ty: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "title")]
        pub title: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url")]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "attached")]
        #[doc = "Whether the target has an attached client."]
        pub attached: bool,
        #[serde(rename = "openerId", skip_serializing_if = "Option::is_none")]
        #[doc = "Opener target Id"]
        pub opener_id: Option<::target::TargetId<'a>>,
        #[serde(rename = "browserContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
        pub browser_context_id: Option<::target::BrowserContextId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct RemoteLocation<'a> {
        #[serde(rename = "host")]
        pub host: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "port")]
        pub port: i32,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> The Tethering domain defines methods and events for browser port binding.\n\n# Tethering\n\n## Commands\n\n- [`Tethering.bind`](struct.BindCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request browser port binding.\n- [`Tethering.unbind`](struct.UnbindCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request browser port unbinding.\n\n## Events\n\n- [`Tethering.accepted`](struct.AcceptedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Informs that port was successfully bound and got a specified connection id.\n"]
pub mod tethering {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port binding.\n\n# Command `Tethering.bind`\n\n*Domain Module:* [`cdp::tethering`](index.html)  \n*Command Struct:* [`cdp::tethering::BindCommand`](struct.BindCommand.html)  \n*Response Struct:* [`cdp::tethering::BindResponse`](struct.BindResponse.html)"]
    pub struct BindCommand {
        #[serde(rename = "port")]
        #[doc = "Port number to bind."]
        pub port: i32,
    }
    impl ::CdpCommand for BindCommand {
        const COMMAND_NAME: &'static str = "Tethering.bind";
    }
    impl ::SerializeCdpCommand for BindCommand {
        fn command_name(&self) -> &str {
            "Tethering.bind"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for BindCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.bind" {
                Ok(
                    <BindCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port binding.\n\n# Command `Tethering.bind`\n\n*Domain Module:* [`cdp::tethering`](index.html)  \n*Command Struct:* [`cdp::tethering::BindCommand`](struct.BindCommand.html)  \n*Response Struct:* [`cdp::tethering::BindResponse`](struct.BindResponse.html)"]
    pub struct BindResponse;
    impl ::serde::Serialize for BindResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for BindResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| BindResponse)
        }
    }
    impl ::CdpCommand for BindResponse {
        const COMMAND_NAME: &'static str = "Tethering.bind";
    }
    impl<'b> ::HasCdpResponse<'b> for BindCommand {
        type Response = BindResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for BindResponse {
        type Command = BindCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port unbinding.\n\n# Command `Tethering.unbind`\n\n*Domain Module:* [`cdp::tethering`](index.html)  \n*Command Struct:* [`cdp::tethering::UnbindCommand`](struct.UnbindCommand.html)  \n*Response Struct:* [`cdp::tethering::UnbindResponse`](struct.UnbindResponse.html)"]
    pub struct UnbindCommand {
        #[serde(rename = "port")]
        #[doc = "Port number to unbind."]
        pub port: i32,
    }
    impl ::CdpCommand for UnbindCommand {
        const COMMAND_NAME: &'static str = "Tethering.unbind";
    }
    impl ::SerializeCdpCommand for UnbindCommand {
        fn command_name(&self) -> &str {
            "Tethering.unbind"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for UnbindCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.unbind" {
                Ok(
                    <UnbindCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request browser port unbinding.\n\n# Command `Tethering.unbind`\n\n*Domain Module:* [`cdp::tethering`](index.html)  \n*Command Struct:* [`cdp::tethering::UnbindCommand`](struct.UnbindCommand.html)  \n*Response Struct:* [`cdp::tethering::UnbindResponse`](struct.UnbindResponse.html)"]
    pub struct UnbindResponse;
    impl ::serde::Serialize for UnbindResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UnbindResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| UnbindResponse)
        }
    }
    impl ::CdpCommand for UnbindResponse {
        const COMMAND_NAME: &'static str = "Tethering.unbind";
    }
    impl<'b> ::HasCdpResponse<'b> for UnbindCommand {
        type Response = UnbindResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for UnbindResponse {
        type Command = UnbindCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Informs that port was successfully bound and got a specified connection id.\n\n# Event `Tethering.accepted`\n\n*Domain Module:* [`cdp::tethering`](index.html)  \n*Event Struct:* [`cdp::tethering::AcceptedEvent`](struct.AcceptedEvent.html)"]
    pub struct AcceptedEvent<'a> {
        #[serde(rename = "port")]
        #[doc = "Port number that was successfully bound."]
        pub port: i32,
        #[serde(rename = "connectionId")]
        #[doc = "Connection id to be used."]
        pub connection_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AcceptedEvent<'a> {
        const EVENT_NAME: &'static str = "Tethering.accepted";
    }
    impl<'a> ::SerializeCdpEvent for AcceptedEvent<'a> {
        fn event_name(&self) -> &str {
            "Tethering.accepted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AcceptedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tethering.accepted" {
                Ok(
                    <AcceptedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Tracing\n\n## Commands\n\n- [`Tracing.end`](struct.EndCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Stop trace events collection.\n- [`Tracing.getCategories`](struct.GetCategoriesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Gets supported tracing categories.\n- [`Tracing.recordClockSyncMarker`](struct.RecordClockSyncMarkerCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Record a clock sync marker in the trace.\n- [`Tracing.requestMemoryDump`](struct.RequestMemoryDumpCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Request a global memory dump.\n- [`Tracing.start`](struct.StartCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Start trace events collection.\n\n## Events\n\n- [`Tracing.bufferUsage`](struct.BufferUsageEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Tracing.dataCollected`](struct.DataCollectedEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Contains an bucket of collected trace events. When tracing is stopped collected events will be\n  send as a sequence of dataCollected events followed by tracingComplete event.\n- [`Tracing.tracingComplete`](struct.TracingCompleteEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n  delivered via dataCollected events.\n\n##Types\n\n- [`MemoryDumpConfig`](struct.MemoryDumpConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Configuration for memory dump. Used only when \"memory-infra\" category is enabled.\n- [`TraceConfig`](struct.TraceConfig.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`StreamCompression`](enum.StreamCompression.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Compression type to use for traces returned via streams.\n"]
pub mod tracing {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop trace events collection.\n\n# Command `Tracing.end`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::EndCommand`](struct.EndCommand.html)  \n*Response Struct:* [`cdp::tracing::EndResponse`](struct.EndResponse.html)"]
    pub struct EndCommand;
    impl ::serde::Serialize for EndCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EndCommand)
        }
    }
    impl ::CdpCommand for EndCommand {
        const COMMAND_NAME: &'static str = "Tracing.end";
    }
    impl ::SerializeCdpCommand for EndCommand {
        fn command_name(&self) -> &str {
            "Tracing.end"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EndCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.end" {
                Ok(<EndCommand as ::serde::Deserialize<'de>>::deserialize(
                    params,
                ))
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Stop trace events collection.\n\n# Command `Tracing.end`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::EndCommand`](struct.EndCommand.html)  \n*Response Struct:* [`cdp::tracing::EndResponse`](struct.EndResponse.html)"]
    pub struct EndResponse;
    impl ::serde::Serialize for EndResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EndResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EndResponse)
        }
    }
    impl ::CdpCommand for EndResponse {
        const COMMAND_NAME: &'static str = "Tracing.end";
    }
    impl<'b> ::HasCdpResponse<'b> for EndCommand {
        type Response = EndResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EndResponse {
        type Command = EndCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets supported tracing categories.\n\n# Command `Tracing.getCategories`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::GetCategoriesCommand`](struct.GetCategoriesCommand.html)  \n*Response Struct:* [`cdp::tracing::GetCategoriesResponse`](struct.GetCategoriesResponse.html)"]
    pub struct GetCategoriesCommand;
    impl ::serde::Serialize for GetCategoriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetCategoriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetCategoriesCommand)
        }
    }
    impl ::CdpCommand for GetCategoriesCommand {
        const COMMAND_NAME: &'static str = "Tracing.getCategories";
    }
    impl ::SerializeCdpCommand for GetCategoriesCommand {
        fn command_name(&self) -> &str {
            "Tracing.getCategories"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetCategoriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.getCategories" {
                Ok(
                    <GetCategoriesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Gets supported tracing categories.\n\n# Command `Tracing.getCategories`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::GetCategoriesCommand`](struct.GetCategoriesCommand.html)  \n*Response Struct:* [`cdp::tracing::GetCategoriesResponse`](struct.GetCategoriesResponse.html)"]
    pub struct GetCategoriesResponse<'a> {
        #[serde(rename = "categories")]
        #[doc = "A list of supported tracing categories."]
        pub categories: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetCategoriesResponse<'a> {
        const COMMAND_NAME: &'static str = "Tracing.getCategories";
    }
    impl<'b> ::HasCdpResponse<'b> for GetCategoriesCommand {
        type Response = GetCategoriesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetCategoriesResponse<'b> {
        type Command = GetCategoriesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Record a clock sync marker in the trace.\n\n# Command `Tracing.recordClockSyncMarker`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::RecordClockSyncMarkerCommand`](struct.RecordClockSyncMarkerCommand.html)  \n*Response Struct:* [`cdp::tracing::RecordClockSyncMarkerResponse`](struct.RecordClockSyncMarkerResponse.html)"]
    pub struct RecordClockSyncMarkerCommand<'a> {
        #[serde(rename = "syncId")]
        #[doc = "The ID of this clock sync marker"]
        pub sync_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RecordClockSyncMarkerCommand<'a> {
        const COMMAND_NAME: &'static str = "Tracing.recordClockSyncMarker";
    }
    impl<'a> ::SerializeCdpCommand for RecordClockSyncMarkerCommand<'a> {
        fn command_name(&self) -> &str {
            "Tracing.recordClockSyncMarker"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RecordClockSyncMarkerCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.recordClockSyncMarker" {
                Ok ( < RecordClockSyncMarkerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Record a clock sync marker in the trace.\n\n# Command `Tracing.recordClockSyncMarker`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::RecordClockSyncMarkerCommand`](struct.RecordClockSyncMarkerCommand.html)  \n*Response Struct:* [`cdp::tracing::RecordClockSyncMarkerResponse`](struct.RecordClockSyncMarkerResponse.html)"]
    pub struct RecordClockSyncMarkerResponse;
    impl ::serde::Serialize for RecordClockSyncMarkerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RecordClockSyncMarkerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RecordClockSyncMarkerResponse)
        }
    }
    impl ::CdpCommand for RecordClockSyncMarkerResponse {
        const COMMAND_NAME: &'static str = "Tracing.recordClockSyncMarker";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RecordClockSyncMarkerCommand<'a> {
        type Response = RecordClockSyncMarkerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RecordClockSyncMarkerResponse {
        type Command = RecordClockSyncMarkerCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request a global memory dump.\n\n# Command `Tracing.requestMemoryDump`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::RequestMemoryDumpCommand`](struct.RequestMemoryDumpCommand.html)  \n*Response Struct:* [`cdp::tracing::RequestMemoryDumpResponse`](struct.RequestMemoryDumpResponse.html)"]
    pub struct RequestMemoryDumpCommand;
    impl ::serde::Serialize for RequestMemoryDumpCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RequestMemoryDumpCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RequestMemoryDumpCommand)
        }
    }
    impl ::CdpCommand for RequestMemoryDumpCommand {
        const COMMAND_NAME: &'static str = "Tracing.requestMemoryDump";
    }
    impl ::SerializeCdpCommand for RequestMemoryDumpCommand {
        fn command_name(&self) -> &str {
            "Tracing.requestMemoryDump"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RequestMemoryDumpCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.requestMemoryDump" {
                Ok ( < RequestMemoryDumpCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Request a global memory dump.\n\n# Command `Tracing.requestMemoryDump`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::RequestMemoryDumpCommand`](struct.RequestMemoryDumpCommand.html)  \n*Response Struct:* [`cdp::tracing::RequestMemoryDumpResponse`](struct.RequestMemoryDumpResponse.html)"]
    pub struct RequestMemoryDumpResponse<'a> {
        #[serde(rename = "dumpGuid")]
        #[doc = "GUID of the resulting global memory dump."]
        pub dump_guid: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "success")]
        #[doc = "True iff the global memory dump succeeded."]
        pub success: bool,
    }
    impl<'a> ::CdpCommand for RequestMemoryDumpResponse<'a> {
        const COMMAND_NAME: &'static str = "Tracing.requestMemoryDump";
    }
    impl<'b> ::HasCdpResponse<'b> for RequestMemoryDumpCommand {
        type Response = RequestMemoryDumpResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RequestMemoryDumpResponse<'b> {
        type Command = RequestMemoryDumpCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::tracing::StartCommand::transfer_mode`](struct.StartCommand.html#structfield.transfer_mode)."]
    pub enum StartCommandTransferMode {
        #[serde(rename = "ReportEvents")]
        #[doc = "Represented as `\"ReportEvents\"`."]
        ReportEvents,
        #[serde(rename = "ReturnAsStream")]
        #[doc = "Represented as `\"ReturnAsStream\"`."]
        ReturnAsStream,
    }
    impl StartCommandTransferMode {
        pub const ENUM_VALUES: &'static [StartCommandTransferMode] =
            &[
                StartCommandTransferMode::ReportEvents,
                StartCommandTransferMode::ReturnAsStream,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["ReportEvents", "ReturnAsStream"];
    }
    impl ::std::str::FromStr for StartCommandTransferMode {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "ReportEvents" => Ok(StartCommandTransferMode::ReportEvents),
                "ReturnAsStream" => Ok(StartCommandTransferMode::ReturnAsStream),
                _ => Err(::ParseEnumError {
                    expected: StartCommandTransferMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StartCommandTransferMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StartCommandTransferMode::ReportEvents => "ReportEvents",
                    StartCommandTransferMode::ReturnAsStream => "ReturnAsStream",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start trace events collection.\n\n# Command `Tracing.start`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::tracing::StartResponse`](struct.StartResponse.html)"]
    pub struct StartCommand<'a> {
        #[serde(rename = "categories", skip_serializing_if = "Option::is_none")]
        #[doc = "Category/tag filter"]
        #[deprecated]
        pub categories: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "options", skip_serializing_if = "Option::is_none")]
        #[doc = "Tracing options"]
        #[deprecated]
        pub options: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "bufferUsageReportingInterval", skip_serializing_if = "Option::is_none")]
        #[doc = "If set, the agent will issue bufferUsage events at this interval, specified in milliseconds"]
        pub buffer_usage_reporting_interval: Option<f64>,
        #[serde(rename = "transferMode", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to report trace events as series of dataCollected events or to save trace to a\nstream \\(defaults to `ReportEvents`\\)."]
        pub transfer_mode: Option<::tracing::StartCommandTransferMode>,
        #[serde(rename = "streamCompression", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression format to use. This only applies when using `ReturnAsStream`\ntransfer mode \\(defaults to `none`\\)"]
        pub stream_compression: Option<::tracing::StreamCompression>,
        #[serde(rename = "traceConfig", skip_serializing_if = "Option::is_none")]
        pub trace_config: Option<::tracing::TraceConfig<'a>>,
    }
    impl<'a> ::CdpCommand for StartCommand<'a> {
        const COMMAND_NAME: &'static str = "Tracing.start";
    }
    impl<'a> ::SerializeCdpCommand for StartCommand<'a> {
        fn command_name(&self) -> &str {
            "Tracing.start"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for StartCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.start" {
                Ok(
                    <StartCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Start trace events collection.\n\n# Command `Tracing.start`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Command Struct:* [`cdp::tracing::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::tracing::StartResponse`](struct.StartResponse.html)"]
    pub struct StartResponse;
    impl ::serde::Serialize for StartResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| StartResponse)
        }
    }
    impl ::CdpCommand for StartResponse {
        const COMMAND_NAME: &'static str = "Tracing.start";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for StartCommand<'a> {
        type Response = StartResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartResponse {
        type Command = StartCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `Tracing.bufferUsage`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Event Struct:* [`cdp::tracing::BufferUsageEvent`](struct.BufferUsageEvent.html)"]
    pub struct BufferUsageEvent {
        #[serde(rename = "percentFull", skip_serializing_if = "Option::is_none")]
        #[doc = "A number in range \\[0..1\\] that indicates the used size of event buffer as a fraction of its\ntotal size."]
        pub percent_full: Option<f64>,
        #[serde(rename = "eventCount", skip_serializing_if = "Option::is_none")]
        #[doc = "An approximate number of events in the trace log."]
        pub event_count: Option<f64>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "A number in range \\[0..1\\] that indicates the used size of event buffer as a fraction of its\ntotal size."]
        pub value: Option<f64>,
    }
    impl ::CdpEvent for BufferUsageEvent {
        const EVENT_NAME: &'static str = "Tracing.bufferUsage";
    }
    impl ::SerializeCdpEvent for BufferUsageEvent {
        fn event_name(&self) -> &str {
            "Tracing.bufferUsage"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for BufferUsageEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.bufferUsage" {
                Ok(
                    <BufferUsageEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Contains an bucket of collected trace events. When tracing is stopped collected events will be\nsend as a sequence of dataCollected events followed by tracingComplete event.\n\n# Event `Tracing.dataCollected`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Event Struct:* [`cdp::tracing::DataCollectedEvent`](struct.DataCollectedEvent.html)"]
    pub struct DataCollectedEvent {
        #[serde(rename = "value")]
        pub value: Vec<::Empty>,
    }
    impl ::CdpEvent for DataCollectedEvent {
        const EVENT_NAME: &'static str = "Tracing.dataCollected";
    }
    impl ::SerializeCdpEvent for DataCollectedEvent {
        fn event_name(&self) -> &str {
            "Tracing.dataCollected"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for DataCollectedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.dataCollected" {
                Ok(
                    <DataCollectedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Signals that tracing is stopped and there is no trace buffers pending flush, all data were\ndelivered via dataCollected events.\n\n# Event `Tracing.tracingComplete`\n\n*Domain Module:* [`cdp::tracing`](index.html)  \n*Event Struct:* [`cdp::tracing::TracingCompleteEvent`](struct.TracingCompleteEvent.html)"]
    pub struct TracingCompleteEvent<'a> {
        #[serde(rename = "stream", skip_serializing_if = "Option::is_none")]
        #[doc = "A handle of the stream that holds resulting trace data."]
        pub stream: Option<::io::StreamHandle<'a>>,
        #[serde(rename = "streamCompression", skip_serializing_if = "Option::is_none")]
        #[doc = "Compression format of returned stream."]
        pub stream_compression: Option<::tracing::StreamCompression>,
    }
    impl<'a> ::CdpEvent for TracingCompleteEvent<'a> {
        const EVENT_NAME: &'static str = "Tracing.tracingComplete";
    }
    impl<'a> ::SerializeCdpEvent for TracingCompleteEvent<'a> {
        fn event_name(&self) -> &str {
            "Tracing.tracingComplete"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for TracingCompleteEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Tracing.tracingComplete" {
                Ok(
                    <TracingCompleteEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Configuration for memory dump. Used only when \"memory-infra\" category is enabled."]
    pub type MemoryDumpConfig = ::Empty;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::tracing::TraceConfig::record_mode`](struct.TraceConfig.html#structfield.record_mode)."]
    pub enum TraceConfigRecordMode {
        #[serde(rename = "recordUntilFull")]
        #[doc = "Represented as `\"recordUntilFull\"`."]
        RecordUntilFull,
        #[serde(rename = "recordContinuously")]
        #[doc = "Represented as `\"recordContinuously\"`."]
        RecordContinuously,
        #[serde(rename = "recordAsMuchAsPossible")]
        #[doc = "Represented as `\"recordAsMuchAsPossible\"`."]
        RecordAsMuchAsPossible,
        #[serde(rename = "echoToConsole")]
        #[doc = "Represented as `\"echoToConsole\"`."]
        EchoToConsole,
    }
    impl TraceConfigRecordMode {
        pub const ENUM_VALUES: &'static [TraceConfigRecordMode] =
            &[
                TraceConfigRecordMode::RecordUntilFull,
                TraceConfigRecordMode::RecordContinuously,
                TraceConfigRecordMode::RecordAsMuchAsPossible,
                TraceConfigRecordMode::EchoToConsole,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "recordUntilFull",
            "recordContinuously",
            "recordAsMuchAsPossible",
            "echoToConsole",
        ];
    }
    impl ::std::str::FromStr for TraceConfigRecordMode {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "recordUntilFull" => Ok(TraceConfigRecordMode::RecordUntilFull),
                "recordContinuously" => Ok(TraceConfigRecordMode::RecordContinuously),
                "recordAsMuchAsPossible" => Ok(TraceConfigRecordMode::RecordAsMuchAsPossible),
                "echoToConsole" => Ok(TraceConfigRecordMode::EchoToConsole),
                _ => Err(::ParseEnumError {
                    expected: TraceConfigRecordMode::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for TraceConfigRecordMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    TraceConfigRecordMode::RecordUntilFull => "recordUntilFull",
                    TraceConfigRecordMode::RecordContinuously => "recordContinuously",
                    TraceConfigRecordMode::RecordAsMuchAsPossible => "recordAsMuchAsPossible",
                    TraceConfigRecordMode::EchoToConsole => "echoToConsole",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct TraceConfig<'a> {
        #[serde(rename = "recordMode", skip_serializing_if = "Option::is_none")]
        #[doc = "Controls how the trace buffer stores data."]
        pub record_mode: Option<::tracing::TraceConfigRecordMode>,
        #[serde(rename = "enableSampling", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on JavaScript stack sampling."]
        pub enable_sampling: Option<bool>,
        #[serde(rename = "enableSystrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on system tracing."]
        pub enable_systrace: Option<bool>,
        #[serde(rename = "enableArgumentFilter", skip_serializing_if = "Option::is_none")]
        #[doc = "Turns on argument filter."]
        pub enable_argument_filter: Option<bool>,
        #[serde(rename = "includedCategories", skip_serializing_if = "Option::is_none")]
        #[doc = "Included category filters."]
        pub included_categories: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "excludedCategories", skip_serializing_if = "Option::is_none")]
        #[doc = "Excluded category filters."]
        pub excluded_categories: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "syntheticDelays", skip_serializing_if = "Option::is_none")]
        #[doc = "Configuration to synthesize the delays in tracing."]
        pub synthetic_delays: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "memoryDumpConfig", skip_serializing_if = "Option::is_none")]
        #[doc = "Configuration for memory dump triggers. Used only when \"memory-infra\" category is enabled."]
        pub memory_dump_config: Option<::tracing::MemoryDumpConfig>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Compression type to use for traces returned via streams."]
    pub enum StreamCompression {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "gzip")]
        #[doc = "Represented as `\"gzip\"`."]
        Gzip,
    }
    impl StreamCompression {
        pub const ENUM_VALUES: &'static [StreamCompression] =
            &[StreamCompression::None, StreamCompression::Gzip];
        pub const STR_VALUES: &'static [&'static str] = &["none", "gzip"];
    }
    impl ::std::str::FromStr for StreamCompression {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(StreamCompression::None),
                "gzip" => Ok(StreamCompression::Gzip),
                _ => Err(::ParseEnumError {
                    expected: StreamCompression::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for StreamCompression {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    StreamCompression::None => "none",
                    StreamCompression::Gzip => "gzip",
                }
            )
        }
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span> Testing domain is a dumping ground for the capabilities requires for browser or app testing that do not fit other\ndomains.\n\n# Testing\n\n## Commands\n\n- [`Testing.generateTestReport`](struct.GenerateTestReportCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Generates a report for testing.\n"]
pub mod testing {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Generates a report for testing.\n\n# Command `Testing.generateTestReport`\n\n*Domain Module:* [`cdp::testing`](index.html)  \n*Command Struct:* [`cdp::testing::GenerateTestReportCommand`](struct.GenerateTestReportCommand.html)  \n*Response Struct:* [`cdp::testing::GenerateTestReportResponse`](struct.GenerateTestReportResponse.html)"]
    pub struct GenerateTestReportCommand<'a> {
        #[serde(rename = "message")]
        #[doc = "Message to be displayed in the report."]
        pub message: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "group", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies the endpoint group to deliver the report to."]
        pub group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GenerateTestReportCommand<'a> {
        const COMMAND_NAME: &'static str = "Testing.generateTestReport";
    }
    impl<'a> ::SerializeCdpCommand for GenerateTestReportCommand<'a> {
        fn command_name(&self) -> &str {
            "Testing.generateTestReport"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GenerateTestReportCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Testing.generateTestReport" {
                Ok ( < GenerateTestReportCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Generates a report for testing.\n\n# Command `Testing.generateTestReport`\n\n*Domain Module:* [`cdp::testing`](index.html)  \n*Command Struct:* [`cdp::testing::GenerateTestReportCommand`](struct.GenerateTestReportCommand.html)  \n*Response Struct:* [`cdp::testing::GenerateTestReportResponse`](struct.GenerateTestReportResponse.html)"]
    pub struct GenerateTestReportResponse;
    impl ::serde::Serialize for GenerateTestReportResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GenerateTestReportResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GenerateTestReportResponse)
        }
    }
    impl ::CdpCommand for GenerateTestReportResponse {
        const COMMAND_NAME: &'static str = "Testing.generateTestReport";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GenerateTestReportCommand<'a> {
        type Response = GenerateTestReportResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GenerateTestReportResponse {
        type Command = GenerateTestReportCommand<'a>;
    }
}
#[doc = "# Console\n\n## Commands\n\n- [`Console.clearMessages`](struct.ClearMessagesCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Does nothing.\n- [`Console.disable`](struct.DisableCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Disables console domain, prevents further console messages from being reported to the client.\n- [`Console.enable`](struct.EnableCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Enables console domain, sends the messages collected so far to the client by means of the\n  `messageAdded` notification.\n\n## Events\n\n- [`Console.messageAdded`](struct.MessageAddedEvent.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Issued when new console message is added.\n\n##Types\n\n- [`ConsoleMessage`](struct.ConsoleMessage.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated - use Runtime or Log instead.</span>\n\n  Console message.\n"]
#[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
pub mod console {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Does nothing.\n\n# Command `Console.clearMessages`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::ClearMessagesCommand`](struct.ClearMessagesCommand.html)  \n*Response Struct:* [`cdp::console::ClearMessagesResponse`](struct.ClearMessagesResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ClearMessagesCommand;
    impl ::serde::Serialize for ClearMessagesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearMessagesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearMessagesCommand)
        }
    }
    impl ::CdpCommand for ClearMessagesCommand {
        const COMMAND_NAME: &'static str = "Console.clearMessages";
    }
    impl ::SerializeCdpCommand for ClearMessagesCommand {
        fn command_name(&self) -> &str {
            "Console.clearMessages"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ClearMessagesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.clearMessages" {
                Ok(
                    <ClearMessagesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Does nothing.\n\n# Command `Console.clearMessages`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::ClearMessagesCommand`](struct.ClearMessagesCommand.html)  \n*Response Struct:* [`cdp::console::ClearMessagesResponse`](struct.ClearMessagesResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ClearMessagesResponse;
    impl ::serde::Serialize for ClearMessagesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ClearMessagesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ClearMessagesResponse)
        }
    }
    impl ::CdpCommand for ClearMessagesResponse {
        const COMMAND_NAME: &'static str = "Console.clearMessages";
    }
    impl<'b> ::HasCdpResponse<'b> for ClearMessagesCommand {
        type Response = ClearMessagesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ClearMessagesResponse {
        type Command = ClearMessagesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables console domain, prevents further console messages from being reported to the client.\n\n# Command `Console.disable`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::console::DisableResponse`](struct.DisableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Console.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Console.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables console domain, prevents further console messages from being reported to the client.\n\n# Command `Console.disable`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::console::DisableResponse`](struct.DisableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Console.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables console domain, sends the messages collected so far to the client by means of the\n`messageAdded` notification.\n\n# Command `Console.enable`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::console::EnableResponse`](struct.EnableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Console.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Console.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables console domain, sends the messages collected so far to the client by means of the\n`messageAdded` notification.\n\n# Command `Console.enable`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Command Struct:* [`cdp::console::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::console::EnableResponse`](struct.EnableResponse.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Console.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when new console message is added.\n\n# Event `Console.messageAdded`\n\n*Domain Module:* [`cdp::console`](index.html)  \n*Event Struct:* [`cdp::console::MessageAddedEvent`](struct.MessageAddedEvent.html)"]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct MessageAddedEvent<'a> {
        #[serde(rename = "message")]
        #[doc = "Console message that has been added."]
        pub message: ::console::ConsoleMessage<'a>,
    }
    impl<'a> ::CdpEvent for MessageAddedEvent<'a> {
        const EVENT_NAME: &'static str = "Console.messageAdded";
    }
    impl<'a> ::SerializeCdpEvent for MessageAddedEvent<'a> {
        fn event_name(&self) -> &str {
            "Console.messageAdded"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for MessageAddedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Console.messageAdded" {
                Ok(
                    <MessageAddedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::console::ConsoleMessage::source`](struct.ConsoleMessage.html#structfield.source)."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub enum ConsoleMessageSource {
        #[serde(rename = "xml")]
        #[doc = "Represented as `\"xml\"`."]
        Xml,
        #[serde(rename = "javascript")]
        #[doc = "Represented as `\"javascript\"`."]
        Javascript,
        #[serde(rename = "network")]
        #[doc = "Represented as `\"network\"`."]
        Network,
        #[serde(rename = "console-api")]
        #[doc = "Represented as `\"console-api\"`."]
        ConsoleApi,
        #[serde(rename = "storage")]
        #[doc = "Represented as `\"storage\"`."]
        Storage,
        #[serde(rename = "appcache")]
        #[doc = "Represented as `\"appcache\"`."]
        Appcache,
        #[serde(rename = "rendering")]
        #[doc = "Represented as `\"rendering\"`."]
        Rendering,
        #[serde(rename = "security")]
        #[doc = "Represented as `\"security\"`."]
        Security,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
        #[serde(rename = "deprecation")]
        #[doc = "Represented as `\"deprecation\"`."]
        Deprecation,
        #[serde(rename = "worker")]
        #[doc = "Represented as `\"worker\"`."]
        Worker,
    }
    impl ConsoleMessageSource {
        pub const ENUM_VALUES: &'static [ConsoleMessageSource] = &[
            ConsoleMessageSource::Xml,
            ConsoleMessageSource::Javascript,
            ConsoleMessageSource::Network,
            ConsoleMessageSource::ConsoleApi,
            ConsoleMessageSource::Storage,
            ConsoleMessageSource::Appcache,
            ConsoleMessageSource::Rendering,
            ConsoleMessageSource::Security,
            ConsoleMessageSource::Other,
            ConsoleMessageSource::Deprecation,
            ConsoleMessageSource::Worker,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "xml",
            "javascript",
            "network",
            "console-api",
            "storage",
            "appcache",
            "rendering",
            "security",
            "other",
            "deprecation",
            "worker",
        ];
    }
    impl ::std::str::FromStr for ConsoleMessageSource {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "xml" => Ok(ConsoleMessageSource::Xml),
                "javascript" => Ok(ConsoleMessageSource::Javascript),
                "network" => Ok(ConsoleMessageSource::Network),
                "console-api" => Ok(ConsoleMessageSource::ConsoleApi),
                "storage" => Ok(ConsoleMessageSource::Storage),
                "appcache" => Ok(ConsoleMessageSource::Appcache),
                "rendering" => Ok(ConsoleMessageSource::Rendering),
                "security" => Ok(ConsoleMessageSource::Security),
                "other" => Ok(ConsoleMessageSource::Other),
                "deprecation" => Ok(ConsoleMessageSource::Deprecation),
                "worker" => Ok(ConsoleMessageSource::Worker),
                _ => Err(::ParseEnumError {
                    expected: ConsoleMessageSource::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleMessageSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleMessageSource::Xml => "xml",
                    ConsoleMessageSource::Javascript => "javascript",
                    ConsoleMessageSource::Network => "network",
                    ConsoleMessageSource::ConsoleApi => "console-api",
                    ConsoleMessageSource::Storage => "storage",
                    ConsoleMessageSource::Appcache => "appcache",
                    ConsoleMessageSource::Rendering => "rendering",
                    ConsoleMessageSource::Security => "security",
                    ConsoleMessageSource::Other => "other",
                    ConsoleMessageSource::Deprecation => "deprecation",
                    ConsoleMessageSource::Worker => "worker",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::console::ConsoleMessage::level`](struct.ConsoleMessage.html#structfield.level)."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub enum ConsoleMessageLevel {
        #[serde(rename = "log")]
        #[doc = "Represented as `\"log\"`."]
        Log,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "debug")]
        #[doc = "Represented as `\"debug\"`."]
        Debug,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
    }
    impl ConsoleMessageLevel {
        pub const ENUM_VALUES: &'static [ConsoleMessageLevel] = &[
            ConsoleMessageLevel::Log,
            ConsoleMessageLevel::Warning,
            ConsoleMessageLevel::Error,
            ConsoleMessageLevel::Debug,
            ConsoleMessageLevel::Info,
        ];
        pub const STR_VALUES: &'static [&'static str] =
            &["log", "warning", "error", "debug", "info"];
    }
    impl ::std::str::FromStr for ConsoleMessageLevel {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "log" => Ok(ConsoleMessageLevel::Log),
                "warning" => Ok(ConsoleMessageLevel::Warning),
                "error" => Ok(ConsoleMessageLevel::Error),
                "debug" => Ok(ConsoleMessageLevel::Debug),
                "info" => Ok(ConsoleMessageLevel::Info),
                _ => Err(::ParseEnumError {
                    expected: ConsoleMessageLevel::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleMessageLevel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleMessageLevel::Log => "log",
                    ConsoleMessageLevel::Warning => "warning",
                    ConsoleMessageLevel::Error => "error",
                    ConsoleMessageLevel::Debug => "debug",
                    ConsoleMessageLevel::Info => "info",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Console message."]
    #[deprecated(note = "This domain is deprecated - use Runtime or Log instead.")]
    pub struct ConsoleMessage<'a> {
        #[serde(rename = "source")]
        #[doc = "Message source."]
        pub source: ::console::ConsoleMessageSource,
        #[serde(rename = "level")]
        #[doc = "Message severity."]
        pub level: ::console::ConsoleMessageLevel,
        #[serde(rename = "text")]
        #[doc = "Message text."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the message origin."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "line", skip_serializing_if = "Option::is_none")]
        #[doc = "Line number in the resource that generated this message \\(1-based\\)."]
        pub line: Option<i32>,
        #[serde(rename = "column", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the resource that generated this message \\(1-based\\)."]
        pub column: Option<i32>,
    }
}
#[doc = "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing\nbreakpoints, stepping through execution, exploring stack traces, etc.\n\n# Debugger\n\n## Commands\n\n- [`Debugger.continueToLocation`](struct.ContinueToLocationCommand.html)\n\n  Continues execution until specific location is reached.\n- [`Debugger.disable`](struct.DisableCommand.html)\n\n  Disables debugger for given page.\n- [`Debugger.enable`](struct.EnableCommand.html)\n\n  Enables debugger for the given page. Clients should not assume that the debugging has been\n  enabled until the result for this command is received.\n- [`Debugger.evaluateOnCallFrame`](struct.EvaluateOnCallFrameCommand.html)\n\n  Evaluates expression on a given call frame.\n- [`Debugger.getPossibleBreakpoints`](struct.GetPossibleBreakpointsCommand.html)\n\n  Returns possible locations for breakpoint. scriptId in start and end range locations should be\n  the same.\n- [`Debugger.getScriptSource`](struct.GetScriptSourceCommand.html)\n\n  Returns source for the script with given id.\n- [`Debugger.getStackTrace`](struct.GetStackTraceCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns stack trace with given `stackTraceId`.\n- [`Debugger.pause`](struct.PauseCommand.html)\n\n  Stops on the next JavaScript statement.\n- [`Debugger.pauseOnAsyncCall`](struct.PauseOnAsyncCallCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Debugger.removeBreakpoint`](struct.RemoveBreakpointCommand.html)\n\n  Removes JavaScript breakpoint.\n- [`Debugger.restartFrame`](struct.RestartFrameCommand.html)\n\n  Restarts particular call frame from the beginning.\n- [`Debugger.resume`](struct.ResumeCommand.html)\n\n  Resumes JavaScript execution.\n- [`Debugger.scheduleStepIntoAsync`](struct.ScheduleStepIntoAsyncCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and\n  Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled\n  before next pause. Returns success when async task is actually scheduled, returns error if no\n  task were scheduled or another scheduleStepIntoAsync was called.\n- [`Debugger.searchInContent`](struct.SearchInContentCommand.html)\n\n  Searches for given string in script content.\n- [`Debugger.setAsyncCallStackDepth`](struct.SetAsyncCallStackDepthCommand.html)\n\n  Enables or disables async call stacks tracking.\n- [`Debugger.setBlackboxPatterns`](struct.SetBlackboxPatternsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in\n  scripts with url matching one of the patterns. VM will try to leave blackboxed script by\n  performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n- [`Debugger.setBlackboxedRanges`](struct.SetBlackboxedRangesCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted\n  scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\n  Positions array contains positions where blackbox state is changed. First interval isn't\n  blackboxed. Array should be sorted.\n- [`Debugger.setBreakpoint`](struct.SetBreakpointCommand.html)\n\n  Sets JavaScript breakpoint at a given location.\n- [`Debugger.setBreakpointByUrl`](struct.SetBreakpointByUrlCommand.html)\n\n  Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this\n  command is issued, all existing parsed scripts will have breakpoints resolved and returned in\n  `locations` property. Further matching script parsing will result in subsequent\n  `breakpointResolved` events issued. This logical breakpoint will survive page reloads.\n- [`Debugger.setBreakpointOnFunctionCall`](struct.SetBreakpointOnFunctionCallCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sets JavaScript breakpoint before each call to the given function.\n  If another function was created from the same source as a given one,\n  calling it will also trigger the breakpoint.\n- [`Debugger.setBreakpointsActive`](struct.SetBreakpointsActiveCommand.html)\n\n  Activates / deactivates all breakpoints on the page.\n- [`Debugger.setPauseOnExceptions`](struct.SetPauseOnExceptionsCommand.html)\n\n  Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or\n  no exceptions. Initial pause on exceptions state is `none`.\n- [`Debugger.setReturnValue`](struct.SetReturnValueCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Changes return value in top frame. Available only at return break position.\n- [`Debugger.setScriptSource`](struct.SetScriptSourceCommand.html)\n\n  Edits JavaScript source live.\n- [`Debugger.setSkipAllPauses`](struct.SetSkipAllPausesCommand.html)\n\n  Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n- [`Debugger.setVariableValue`](struct.SetVariableValueCommand.html)\n\n  Changes value of variable in a callframe. Object-based scopes are not supported and must be\n  mutated manually.\n- [`Debugger.stepInto`](struct.StepIntoCommand.html)\n\n  Steps into the function call.\n- [`Debugger.stepOut`](struct.StepOutCommand.html)\n\n  Steps out of the function call.\n- [`Debugger.stepOver`](struct.StepOverCommand.html)\n\n  Steps over the statement.\n\n## Events\n\n- [`Debugger.breakpointResolved`](struct.BreakpointResolvedEvent.html)\n\n  Fired when breakpoint is resolved to an actual script and location.\n- [`Debugger.paused`](struct.PausedEvent.html)\n\n  Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n- [`Debugger.resumed`](struct.ResumedEvent.html)\n\n  Fired when the virtual machine resumed execution.\n- [`Debugger.scriptFailedToParse`](struct.ScriptFailedToParseEvent.html)\n\n  Fired when virtual machine fails to parse the script.\n- [`Debugger.scriptParsed`](struct.ScriptParsedEvent.html)\n\n  Fired when virtual machine parses script. This event is also fired for all known and uncollected\n  scripts upon enabling debugger.\n\n##Types\n\n- [`BreakpointId`](type.BreakpointId.html)\n\n  Breakpoint identifier.\n- [`CallFrameId`](type.CallFrameId.html)\n\n  Call frame identifier.\n- [`Location`](struct.Location.html)\n\n  Location in the source code.\n- [`ScriptPosition`](struct.ScriptPosition.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Location in the source code.\n- [`CallFrame`](struct.CallFrame.html)\n\n  JavaScript call frame. Array of call frames form the call stack.\n- [`Scope`](struct.Scope.html)\n\n  Scope description.\n- [`SearchMatch`](struct.SearchMatch.html)\n\n  Search match for resource.\n- [`BreakLocation`](struct.BreakLocation.html)\n"]
pub mod debugger {
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::debugger::ContinueToLocationCommand::target_call_frames`](struct.ContinueToLocationCommand.html#structfield.target_call_frames)."]
    pub enum ContinueToLocationCommandTargetCallFrames {
        #[serde(rename = "any")]
        #[doc = "Represented as `\"any\"`."]
        Any,
        #[serde(rename = "current")]
        #[doc = "Represented as `\"current\"`."]
        Current,
    }
    impl ContinueToLocationCommandTargetCallFrames {
        pub const ENUM_VALUES: &'static [ContinueToLocationCommandTargetCallFrames] =
            &[
                ContinueToLocationCommandTargetCallFrames::Any,
                ContinueToLocationCommandTargetCallFrames::Current,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["any", "current"];
    }
    impl ::std::str::FromStr for ContinueToLocationCommandTargetCallFrames {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "any" => Ok(ContinueToLocationCommandTargetCallFrames::Any),
                "current" => Ok(ContinueToLocationCommandTargetCallFrames::Current),
                _ => Err(::ParseEnumError {
                    expected: ContinueToLocationCommandTargetCallFrames::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ContinueToLocationCommandTargetCallFrames {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ContinueToLocationCommandTargetCallFrames::Any => "any",
                    ContinueToLocationCommandTargetCallFrames::Current => "current",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Continues execution until specific location is reached.\n\n# Command `Debugger.continueToLocation`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ContinueToLocationCommand`](struct.ContinueToLocationCommand.html)  \n*Response Struct:* [`cdp::debugger::ContinueToLocationResponse`](struct.ContinueToLocationResponse.html)"]
    pub struct ContinueToLocationCommand<'a> {
        #[serde(rename = "location")]
        #[doc = "Location to continue to."]
        pub location: ::debugger::Location<'a>,
        #[serde(rename = "targetCallFrames", skip_serializing_if = "Option::is_none")]
        pub target_call_frames:
            Option<::debugger::ContinueToLocationCommandTargetCallFrames>,
    }
    impl<'a> ::CdpCommand for ContinueToLocationCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.continueToLocation";
    }
    impl<'a> ::SerializeCdpCommand for ContinueToLocationCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.continueToLocation"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ContinueToLocationCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.continueToLocation" {
                Ok ( < ContinueToLocationCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Continues execution until specific location is reached.\n\n# Command `Debugger.continueToLocation`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ContinueToLocationCommand`](struct.ContinueToLocationCommand.html)  \n*Response Struct:* [`cdp::debugger::ContinueToLocationResponse`](struct.ContinueToLocationResponse.html)"]
    pub struct ContinueToLocationResponse;
    impl ::serde::Serialize for ContinueToLocationResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ContinueToLocationResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ContinueToLocationResponse)
        }
    }
    impl ::CdpCommand for ContinueToLocationResponse {
        const COMMAND_NAME: &'static str = "Debugger.continueToLocation";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ContinueToLocationCommand<'a> {
        type Response = ContinueToLocationResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ContinueToLocationResponse {
        type Command = ContinueToLocationCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables debugger for given page.\n\n# Command `Debugger.disable`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::debugger::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Debugger.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Debugger.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables debugger for given page.\n\n# Command `Debugger.disable`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::debugger::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Debugger.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been\nenabled until the result for this command is received.\n\n# Command `Debugger.enable`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::debugger::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Debugger.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Debugger.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables debugger for the given page. Clients should not assume that the debugging has been\nenabled until the result for this command is received.\n\n# Command `Debugger.enable`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::debugger::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse<'a> {
        #[serde(rename = "debuggerId")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of the debugger."]
        pub debugger_id: ::runtime::UniqueDebuggerId<'a>,
    }
    impl<'a> ::CdpCommand for EnableResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for EnableResponse<'b> {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on a given call frame.\n\n# Command `Debugger.evaluateOnCallFrame`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::EvaluateOnCallFrameCommand`](struct.EvaluateOnCallFrameCommand.html)  \n*Response Struct:* [`cdp::debugger::EvaluateOnCallFrameResponse`](struct.EvaluateOnCallFrameResponse.html)"]
    pub struct EvaluateOnCallFrameCommand<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier to evaluate on."]
        pub call_frame_id: ::debugger::CallFrameId<'a>,
        #[serde(rename = "expression")]
        #[doc = "Expression to evaluate."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "String object group name to put result into \\(allows rapid releasing resulting object handles\nusing `releaseObjectGroup`\\)."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies whether command line API should be available to the evaluated expression, defaults\nto false."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
        pub silent: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "throwOnSideEffect", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether to throw an exception if side effect cannot be ruled out during evaluation."]
        pub throw_on_side_effect: Option<bool>,
        #[serde(rename = "timeout", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Terminate execution after timing out \\(number of milliseconds\\)."]
        pub timeout: Option<::runtime::TimeDelta>,
    }
    impl<'a> ::CdpCommand for EvaluateOnCallFrameCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.evaluateOnCallFrame";
    }
    impl<'a> ::SerializeCdpCommand for EvaluateOnCallFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.evaluateOnCallFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for EvaluateOnCallFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.evaluateOnCallFrame" {
                Ok ( < EvaluateOnCallFrameCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on a given call frame.\n\n# Command `Debugger.evaluateOnCallFrame`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::EvaluateOnCallFrameCommand`](struct.EvaluateOnCallFrameCommand.html)  \n*Response Struct:* [`cdp::debugger::EvaluateOnCallFrameResponse`](struct.EvaluateOnCallFrameResponse.html)"]
    pub struct EvaluateOnCallFrameResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Object wrapper for the evaluation result."]
        pub result: ::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for EvaluateOnCallFrameResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.evaluateOnCallFrame";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for EvaluateOnCallFrameCommand<'a> {
        type Response = EvaluateOnCallFrameResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for EvaluateOnCallFrameResponse<'b> {
        type Command = EvaluateOnCallFrameCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns possible locations for breakpoint. scriptId in start and end range locations should be\nthe same.\n\n# Command `Debugger.getPossibleBreakpoints`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetPossibleBreakpointsCommand`](struct.GetPossibleBreakpointsCommand.html)  \n*Response Struct:* [`cdp::debugger::GetPossibleBreakpointsResponse`](struct.GetPossibleBreakpointsResponse.html)"]
    pub struct GetPossibleBreakpointsCommand<'a> {
        #[serde(rename = "start")]
        #[doc = "Start of range to search possible breakpoint locations in."]
        pub start: ::debugger::Location<'a>,
        #[serde(rename = "end", skip_serializing_if = "Option::is_none")]
        #[doc = "End of range to search possible breakpoint locations in \\(excluding\\). When not specified, end\nof scripts is used as end of range."]
        pub end: Option<::debugger::Location<'a>>,
        #[serde(rename = "restrictToFunction", skip_serializing_if = "Option::is_none")]
        #[doc = "Only consider locations which are in the same \\(non-nested\\) function as start."]
        pub restrict_to_function: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetPossibleBreakpointsCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getPossibleBreakpoints";
    }
    impl<'a> ::SerializeCdpCommand for GetPossibleBreakpointsCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.getPossibleBreakpoints"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetPossibleBreakpointsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.getPossibleBreakpoints" {
                Ok ( < GetPossibleBreakpointsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns possible locations for breakpoint. scriptId in start and end range locations should be\nthe same.\n\n# Command `Debugger.getPossibleBreakpoints`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetPossibleBreakpointsCommand`](struct.GetPossibleBreakpointsCommand.html)  \n*Response Struct:* [`cdp::debugger::GetPossibleBreakpointsResponse`](struct.GetPossibleBreakpointsResponse.html)"]
    pub struct GetPossibleBreakpointsResponse<'a> {
        #[serde(rename = "locations")]
        #[doc = "List of the possible breakpoint locations."]
        pub locations: Vec<::debugger::BreakLocation<'a>>,
    }
    impl<'a> ::CdpCommand for GetPossibleBreakpointsResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getPossibleBreakpoints";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetPossibleBreakpointsCommand<'a> {
        type Response = GetPossibleBreakpointsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetPossibleBreakpointsResponse<'b> {
        type Command = GetPossibleBreakpointsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns source for the script with given id.\n\n# Command `Debugger.getScriptSource`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetScriptSourceCommand`](struct.GetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::debugger::GetScriptSourceResponse`](struct.GetScriptSourceResponse.html)"]
    pub struct GetScriptSourceCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to get source for."]
        pub script_id: ::runtime::ScriptId<'a>,
    }
    impl<'a> ::CdpCommand for GetScriptSourceCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getScriptSource";
    }
    impl<'a> ::SerializeCdpCommand for GetScriptSourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.getScriptSource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetScriptSourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.getScriptSource" {
                Ok(
                    <GetScriptSourceCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns source for the script with given id.\n\n# Command `Debugger.getScriptSource`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetScriptSourceCommand`](struct.GetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::debugger::GetScriptSourceResponse`](struct.GetScriptSourceResponse.html)"]
    pub struct GetScriptSourceResponse<'a> {
        #[serde(rename = "scriptSource")]
        #[doc = "Script source."]
        pub script_source: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetScriptSourceResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getScriptSource";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetScriptSourceCommand<'a> {
        type Response = GetScriptSourceResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetScriptSourceResponse<'b> {
        type Command = GetScriptSourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns stack trace with given `stackTraceId`.\n\n# Command `Debugger.getStackTrace`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetStackTraceCommand`](struct.GetStackTraceCommand.html)  \n*Response Struct:* [`cdp::debugger::GetStackTraceResponse`](struct.GetStackTraceResponse.html)"]
    pub struct GetStackTraceCommand<'a> {
        #[serde(rename = "stackTraceId")]
        pub stack_trace_id: ::runtime::StackTraceId<'a>,
    }
    impl<'a> ::CdpCommand for GetStackTraceCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getStackTrace";
    }
    impl<'a> ::SerializeCdpCommand for GetStackTraceCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.getStackTrace"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetStackTraceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.getStackTrace" {
                Ok(
                    <GetStackTraceCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns stack trace with given `stackTraceId`.\n\n# Command `Debugger.getStackTrace`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::GetStackTraceCommand`](struct.GetStackTraceCommand.html)  \n*Response Struct:* [`cdp::debugger::GetStackTraceResponse`](struct.GetStackTraceResponse.html)"]
    pub struct GetStackTraceResponse<'a> {
        #[serde(rename = "stackTrace")]
        pub stack_trace: ::runtime::StackTrace<'a>,
    }
    impl<'a> ::CdpCommand for GetStackTraceResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.getStackTrace";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetStackTraceCommand<'a> {
        type Response = GetStackTraceResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetStackTraceResponse<'b> {
        type Command = GetStackTraceCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stops on the next JavaScript statement.\n\n# Command `Debugger.pause`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::PauseCommand`](struct.PauseCommand.html)  \n*Response Struct:* [`cdp::debugger::PauseResponse`](struct.PauseResponse.html)"]
    pub struct PauseCommand;
    impl ::serde::Serialize for PauseCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PauseCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| PauseCommand)
        }
    }
    impl ::CdpCommand for PauseCommand {
        const COMMAND_NAME: &'static str = "Debugger.pause";
    }
    impl ::SerializeCdpCommand for PauseCommand {
        fn command_name(&self) -> &str {
            "Debugger.pause"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for PauseCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.pause" {
                Ok(
                    <PauseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Stops on the next JavaScript statement.\n\n# Command `Debugger.pause`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::PauseCommand`](struct.PauseCommand.html)  \n*Response Struct:* [`cdp::debugger::PauseResponse`](struct.PauseResponse.html)"]
    pub struct PauseResponse;
    impl ::serde::Serialize for PauseResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PauseResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| PauseResponse)
        }
    }
    impl ::CdpCommand for PauseResponse {
        const COMMAND_NAME: &'static str = "Debugger.pause";
    }
    impl<'b> ::HasCdpResponse<'b> for PauseCommand {
        type Response = PauseResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for PauseResponse {
        type Command = PauseCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Debugger.pauseOnAsyncCall`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::PauseOnAsyncCallCommand`](struct.PauseOnAsyncCallCommand.html)  \n*Response Struct:* [`cdp::debugger::PauseOnAsyncCallResponse`](struct.PauseOnAsyncCallResponse.html)"]
    pub struct PauseOnAsyncCallCommand<'a> {
        #[serde(rename = "parentStackTraceId")]
        #[doc = "Debugger will pause when async call with given stack trace is started."]
        pub parent_stack_trace_id: ::runtime::StackTraceId<'a>,
    }
    impl<'a> ::CdpCommand for PauseOnAsyncCallCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.pauseOnAsyncCall";
    }
    impl<'a> ::SerializeCdpCommand for PauseOnAsyncCallCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.pauseOnAsyncCall"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for PauseOnAsyncCallCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.pauseOnAsyncCall" {
                Ok ( < PauseOnAsyncCallCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Debugger.pauseOnAsyncCall`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::PauseOnAsyncCallCommand`](struct.PauseOnAsyncCallCommand.html)  \n*Response Struct:* [`cdp::debugger::PauseOnAsyncCallResponse`](struct.PauseOnAsyncCallResponse.html)"]
    pub struct PauseOnAsyncCallResponse;
    impl ::serde::Serialize for PauseOnAsyncCallResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PauseOnAsyncCallResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| PauseOnAsyncCallResponse)
        }
    }
    impl ::CdpCommand for PauseOnAsyncCallResponse {
        const COMMAND_NAME: &'static str = "Debugger.pauseOnAsyncCall";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for PauseOnAsyncCallCommand<'a> {
        type Response = PauseOnAsyncCallResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for PauseOnAsyncCallResponse {
        type Command = PauseOnAsyncCallCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Removes JavaScript breakpoint.\n\n# Command `Debugger.removeBreakpoint`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::RemoveBreakpointCommand`](struct.RemoveBreakpointCommand.html)  \n*Response Struct:* [`cdp::debugger::RemoveBreakpointResponse`](struct.RemoveBreakpointResponse.html)"]
    pub struct RemoveBreakpointCommand<'a> {
        #[serde(rename = "breakpointId")]
        pub breakpoint_id: ::debugger::BreakpointId<'a>,
    }
    impl<'a> ::CdpCommand for RemoveBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.removeBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for RemoveBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.removeBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.removeBreakpoint" {
                Ok ( < RemoveBreakpointCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Removes JavaScript breakpoint.\n\n# Command `Debugger.removeBreakpoint`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::RemoveBreakpointCommand`](struct.RemoveBreakpointCommand.html)  \n*Response Struct:* [`cdp::debugger::RemoveBreakpointResponse`](struct.RemoveBreakpointResponse.html)"]
    pub struct RemoveBreakpointResponse;
    impl ::serde::Serialize for RemoveBreakpointResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveBreakpointResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveBreakpointResponse)
        }
    }
    impl ::CdpCommand for RemoveBreakpointResponse {
        const COMMAND_NAME: &'static str = "Debugger.removeBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveBreakpointCommand<'a> {
        type Response = RemoveBreakpointResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveBreakpointResponse {
        type Command = RemoveBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Restarts particular call frame from the beginning.\n\n# Command `Debugger.restartFrame`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::RestartFrameCommand`](struct.RestartFrameCommand.html)  \n*Response Struct:* [`cdp::debugger::RestartFrameResponse`](struct.RestartFrameResponse.html)"]
    pub struct RestartFrameCommand<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier to evaluate on."]
        pub call_frame_id: ::debugger::CallFrameId<'a>,
    }
    impl<'a> ::CdpCommand for RestartFrameCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.restartFrame";
    }
    impl<'a> ::SerializeCdpCommand for RestartFrameCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.restartFrame"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RestartFrameCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.restartFrame" {
                Ok(
                    <RestartFrameCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Restarts particular call frame from the beginning.\n\n# Command `Debugger.restartFrame`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::RestartFrameCommand`](struct.RestartFrameCommand.html)  \n*Response Struct:* [`cdp::debugger::RestartFrameResponse`](struct.RestartFrameResponse.html)"]
    pub struct RestartFrameResponse<'a> {
        #[serde(rename = "callFrames")]
        #[doc = "New stack trace."]
        pub call_frames: Vec<::debugger::CallFrame<'a>>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "asyncStackTraceId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Async stack trace, if any."]
        pub async_stack_trace_id: Option<::runtime::StackTraceId<'a>>,
    }
    impl<'a> ::CdpCommand for RestartFrameResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.restartFrame";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RestartFrameCommand<'a> {
        type Response = RestartFrameResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RestartFrameResponse<'b> {
        type Command = RestartFrameCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Resumes JavaScript execution.\n\n# Command `Debugger.resume`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ResumeCommand`](struct.ResumeCommand.html)  \n*Response Struct:* [`cdp::debugger::ResumeResponse`](struct.ResumeResponse.html)"]
    pub struct ResumeCommand;
    impl ::serde::Serialize for ResumeCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumeCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| ResumeCommand)
        }
    }
    impl ::CdpCommand for ResumeCommand {
        const COMMAND_NAME: &'static str = "Debugger.resume";
    }
    impl ::SerializeCdpCommand for ResumeCommand {
        fn command_name(&self) -> &str {
            "Debugger.resume"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ResumeCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.resume" {
                Ok(
                    <ResumeCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Resumes JavaScript execution.\n\n# Command `Debugger.resume`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ResumeCommand`](struct.ResumeCommand.html)  \n*Response Struct:* [`cdp::debugger::ResumeResponse`](struct.ResumeResponse.html)"]
    pub struct ResumeResponse;
    impl ::serde::Serialize for ResumeResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumeResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResumeResponse)
        }
    }
    impl ::CdpCommand for ResumeResponse {
        const COMMAND_NAME: &'static str = "Debugger.resume";
    }
    impl<'b> ::HasCdpResponse<'b> for ResumeCommand {
        type Response = ResumeResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ResumeResponse {
        type Command = ResumeCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and\nDebugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled\nbefore next pause. Returns success when async task is actually scheduled, returns error if no\ntask were scheduled or another scheduleStepIntoAsync was called.\n\n# Command `Debugger.scheduleStepIntoAsync`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ScheduleStepIntoAsyncCommand`](struct.ScheduleStepIntoAsyncCommand.html)  \n*Response Struct:* [`cdp::debugger::ScheduleStepIntoAsyncResponse`](struct.ScheduleStepIntoAsyncResponse.html)"]
    pub struct ScheduleStepIntoAsyncCommand;
    impl ::serde::Serialize for ScheduleStepIntoAsyncCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScheduleStepIntoAsyncCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScheduleStepIntoAsyncCommand)
        }
    }
    impl ::CdpCommand for ScheduleStepIntoAsyncCommand {
        const COMMAND_NAME: &'static str = "Debugger.scheduleStepIntoAsync";
    }
    impl ::SerializeCdpCommand for ScheduleStepIntoAsyncCommand {
        fn command_name(&self) -> &str {
            "Debugger.scheduleStepIntoAsync"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for ScheduleStepIntoAsyncCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scheduleStepIntoAsync" {
                Ok ( < ScheduleStepIntoAsyncCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and\nDebugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled\nbefore next pause. Returns success when async task is actually scheduled, returns error if no\ntask were scheduled or another scheduleStepIntoAsync was called.\n\n# Command `Debugger.scheduleStepIntoAsync`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::ScheduleStepIntoAsyncCommand`](struct.ScheduleStepIntoAsyncCommand.html)  \n*Response Struct:* [`cdp::debugger::ScheduleStepIntoAsyncResponse`](struct.ScheduleStepIntoAsyncResponse.html)"]
    pub struct ScheduleStepIntoAsyncResponse;
    impl ::serde::Serialize for ScheduleStepIntoAsyncResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ScheduleStepIntoAsyncResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ScheduleStepIntoAsyncResponse)
        }
    }
    impl ::CdpCommand for ScheduleStepIntoAsyncResponse {
        const COMMAND_NAME: &'static str = "Debugger.scheduleStepIntoAsync";
    }
    impl<'b> ::HasCdpResponse<'b> for ScheduleStepIntoAsyncCommand {
        type Response = ScheduleStepIntoAsyncResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ScheduleStepIntoAsyncResponse {
        type Command = ScheduleStepIntoAsyncCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Searches for given string in script content.\n\n# Command `Debugger.searchInContent`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SearchInContentCommand`](struct.SearchInContentCommand.html)  \n*Response Struct:* [`cdp::debugger::SearchInContentResponse`](struct.SearchInContentResponse.html)"]
    pub struct SearchInContentCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to search in."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "query")]
        #[doc = "String to search for."]
        pub query: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "caseSensitive", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, search is case sensitive."]
        pub case_sensitive: Option<bool>,
        #[serde(rename = "isRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, treats string parameter as regex."]
        pub is_regex: Option<bool>,
    }
    impl<'a> ::CdpCommand for SearchInContentCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.searchInContent";
    }
    impl<'a> ::SerializeCdpCommand for SearchInContentCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.searchInContent"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SearchInContentCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.searchInContent" {
                Ok(
                    <SearchInContentCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Searches for given string in script content.\n\n# Command `Debugger.searchInContent`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SearchInContentCommand`](struct.SearchInContentCommand.html)  \n*Response Struct:* [`cdp::debugger::SearchInContentResponse`](struct.SearchInContentResponse.html)"]
    pub struct SearchInContentResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "List of search matches."]
        pub result: Vec<::debugger::SearchMatch<'a>>,
    }
    impl<'a> ::CdpCommand for SearchInContentResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.searchInContent";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SearchInContentCommand<'a> {
        type Response = SearchInContentResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SearchInContentResponse<'b> {
        type Command = SearchInContentCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Debugger.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::debugger::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthCommand {
        #[serde(rename = "maxDepth")]
        #[doc = "Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async\ncall stacks \\(default\\)."]
        pub max_depth: i32,
    }
    impl ::CdpCommand for SetAsyncCallStackDepthCommand {
        const COMMAND_NAME: &'static str = "Debugger.setAsyncCallStackDepth";
    }
    impl ::SerializeCdpCommand for SetAsyncCallStackDepthCommand {
        fn command_name(&self) -> &str {
            "Debugger.setAsyncCallStackDepth"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetAsyncCallStackDepthCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setAsyncCallStackDepth" {
                Ok ( < SetAsyncCallStackDepthCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Debugger.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::debugger::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthResponse;
    impl ::serde::Serialize for SetAsyncCallStackDepthResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAsyncCallStackDepthResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAsyncCallStackDepthResponse)
        }
    }
    impl ::CdpCommand for SetAsyncCallStackDepthResponse {
        const COMMAND_NAME: &'static str = "Debugger.setAsyncCallStackDepth";
    }
    impl<'b> ::HasCdpResponse<'b> for SetAsyncCallStackDepthCommand {
        type Response = SetAsyncCallStackDepthResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAsyncCallStackDepthResponse {
        type Command = SetAsyncCallStackDepthCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in\nscripts with url matching one of the patterns. VM will try to leave blackboxed script by\nperforming 'step in' several times, finally resorting to 'step out' if unsuccessful.\n\n# Command `Debugger.setBlackboxPatterns`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBlackboxPatternsCommand`](struct.SetBlackboxPatternsCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBlackboxPatternsResponse`](struct.SetBlackboxPatternsResponse.html)"]
    pub struct SetBlackboxPatternsCommand<'a> {
        #[serde(rename = "patterns")]
        #[doc = "Array of regexps that will be used to check script url for blackbox state."]
        pub patterns: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetBlackboxPatternsCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBlackboxPatterns";
    }
    impl<'a> ::SerializeCdpCommand for SetBlackboxPatternsCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBlackboxPatterns"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBlackboxPatternsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBlackboxPatterns" {
                Ok ( < SetBlackboxPatternsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in\nscripts with url matching one of the patterns. VM will try to leave blackboxed script by\nperforming 'step in' several times, finally resorting to 'step out' if unsuccessful.\n\n# Command `Debugger.setBlackboxPatterns`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBlackboxPatternsCommand`](struct.SetBlackboxPatternsCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBlackboxPatternsResponse`](struct.SetBlackboxPatternsResponse.html)"]
    pub struct SetBlackboxPatternsResponse;
    impl ::serde::Serialize for SetBlackboxPatternsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlackboxPatternsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlackboxPatternsResponse)
        }
    }
    impl ::CdpCommand for SetBlackboxPatternsResponse {
        const COMMAND_NAME: &'static str = "Debugger.setBlackboxPatterns";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBlackboxPatternsCommand<'a> {
        type Response = SetBlackboxPatternsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBlackboxPatternsResponse {
        type Command = SetBlackboxPatternsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted\nscripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\nPositions array contains positions where blackbox state is changed. First interval isn't\nblackboxed. Array should be sorted.\n\n# Command `Debugger.setBlackboxedRanges`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBlackboxedRangesCommand`](struct.SetBlackboxedRangesCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBlackboxedRangesResponse`](struct.SetBlackboxedRangesResponse.html)"]
    pub struct SetBlackboxedRangesCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "positions")]
        pub positions: Vec<::debugger::ScriptPosition>,
    }
    impl<'a> ::CdpCommand for SetBlackboxedRangesCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBlackboxedRanges";
    }
    impl<'a> ::SerializeCdpCommand for SetBlackboxedRangesCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBlackboxedRanges"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBlackboxedRangesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBlackboxedRanges" {
                Ok ( < SetBlackboxedRangesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted\nscripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.\nPositions array contains positions where blackbox state is changed. First interval isn't\nblackboxed. Array should be sorted.\n\n# Command `Debugger.setBlackboxedRanges`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBlackboxedRangesCommand`](struct.SetBlackboxedRangesCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBlackboxedRangesResponse`](struct.SetBlackboxedRangesResponse.html)"]
    pub struct SetBlackboxedRangesResponse;
    impl ::serde::Serialize for SetBlackboxedRangesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBlackboxedRangesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBlackboxedRangesResponse)
        }
    }
    impl ::CdpCommand for SetBlackboxedRangesResponse {
        const COMMAND_NAME: &'static str = "Debugger.setBlackboxedRanges";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBlackboxedRangesCommand<'a> {
        type Response = SetBlackboxedRangesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBlackboxedRangesResponse {
        type Command = SetBlackboxedRangesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at a given location.\n\n# Command `Debugger.setBreakpoint`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointCommand`](struct.SetBreakpointCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointResponse`](struct.SetBreakpointResponse.html)"]
    pub struct SetBreakpointCommand<'a> {
        #[serde(rename = "location")]
        #[doc = "Location to set breakpoint in."]
        pub location: ::debugger::Location<'a>,
        #[serde(rename = "condition", skip_serializing_if = "Option::is_none")]
        #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the\nbreakpoint if this expression evaluates to true."]
        pub condition: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetBreakpointCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpoint";
    }
    impl<'a> ::SerializeCdpCommand for SetBreakpointCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpoint"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBreakpointCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpoint" {
                Ok(
                    <SetBreakpointCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at a given location.\n\n# Command `Debugger.setBreakpoint`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointCommand`](struct.SetBreakpointCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointResponse`](struct.SetBreakpointResponse.html)"]
    pub struct SetBreakpointResponse<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Id of the created breakpoint for further reference."]
        pub breakpoint_id: ::debugger::BreakpointId<'a>,
        #[serde(rename = "actualLocation")]
        #[doc = "Location this breakpoint resolved into."]
        pub actual_location: ::debugger::Location<'a>,
    }
    impl<'a> ::CdpCommand for SetBreakpointResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpoint";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBreakpointCommand<'a> {
        type Response = SetBreakpointResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetBreakpointResponse<'b> {
        type Command = SetBreakpointCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this\ncommand is issued, all existing parsed scripts will have breakpoints resolved and returned in\n`locations` property. Further matching script parsing will result in subsequent\n`breakpointResolved` events issued. This logical breakpoint will survive page reloads.\n\n# Command `Debugger.setBreakpointByUrl`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointByUrlCommand`](struct.SetBreakpointByUrlCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointByUrlResponse`](struct.SetBreakpointByUrlResponse.html)"]
    pub struct SetBreakpointByUrlCommand<'a> {
        #[serde(rename = "lineNumber")]
        #[doc = "Line number to set breakpoint at."]
        pub line_number: i32,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the resources to set breakpoint on."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "urlRegex", skip_serializing_if = "Option::is_none")]
        #[doc = "Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or\n`urlRegex` must be specified."]
        pub url_regex: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "scriptHash", skip_serializing_if = "Option::is_none")]
        #[doc = "Script hash of the resources to set breakpoint on."]
        pub script_hash: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Offset in the line to set breakpoint at."]
        pub column_number: Option<i32>,
        #[serde(rename = "condition", skip_serializing_if = "Option::is_none")]
        #[doc = "Expression to use as a breakpoint condition. When specified, debugger will only stop on the\nbreakpoint if this expression evaluates to true."]
        pub condition: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetBreakpointByUrlCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointByUrl";
    }
    impl<'a> ::SerializeCdpCommand for SetBreakpointByUrlCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpointByUrl"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBreakpointByUrlCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpointByUrl" {
                Ok ( < SetBreakpointByUrlCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this\ncommand is issued, all existing parsed scripts will have breakpoints resolved and returned in\n`locations` property. Further matching script parsing will result in subsequent\n`breakpointResolved` events issued. This logical breakpoint will survive page reloads.\n\n# Command `Debugger.setBreakpointByUrl`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointByUrlCommand`](struct.SetBreakpointByUrlCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointByUrlResponse`](struct.SetBreakpointByUrlResponse.html)"]
    pub struct SetBreakpointByUrlResponse<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Id of the created breakpoint for further reference."]
        pub breakpoint_id: ::debugger::BreakpointId<'a>,
        #[serde(rename = "locations")]
        #[doc = "List of the locations this breakpoint resolved into upon addition."]
        pub locations: Vec<::debugger::Location<'a>>,
    }
    impl<'a> ::CdpCommand for SetBreakpointByUrlResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointByUrl";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBreakpointByUrlCommand<'a> {
        type Response = SetBreakpointByUrlResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetBreakpointByUrlResponse<'b> {
        type Command = SetBreakpointByUrlCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets JavaScript breakpoint before each call to the given function.\nIf another function was created from the same source as a given one,\ncalling it will also trigger the breakpoint.\n\n# Command `Debugger.setBreakpointOnFunctionCall`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointOnFunctionCallCommand`](struct.SetBreakpointOnFunctionCallCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointOnFunctionCallResponse`](struct.SetBreakpointOnFunctionCallResponse.html)"]
    pub struct SetBreakpointOnFunctionCallCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Function object id."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "condition", skip_serializing_if = "Option::is_none")]
        #[doc = "Expression to use as a breakpoint condition. When specified, debugger will\nstop on the breakpoint if this expression evaluates to true."]
        pub condition: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for SetBreakpointOnFunctionCallCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointOnFunctionCall";
    }
    impl<'a> ::SerializeCdpCommand for SetBreakpointOnFunctionCallCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpointOnFunctionCall"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetBreakpointOnFunctionCallCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpointOnFunctionCall" {
                Ok ( < SetBreakpointOnFunctionCallCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sets JavaScript breakpoint before each call to the given function.\nIf another function was created from the same source as a given one,\ncalling it will also trigger the breakpoint.\n\n# Command `Debugger.setBreakpointOnFunctionCall`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointOnFunctionCallCommand`](struct.SetBreakpointOnFunctionCallCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointOnFunctionCallResponse`](struct.SetBreakpointOnFunctionCallResponse.html)"]
    pub struct SetBreakpointOnFunctionCallResponse<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Id of the created breakpoint for further reference."]
        pub breakpoint_id: ::debugger::BreakpointId<'a>,
    }
    impl<'a> ::CdpCommand for SetBreakpointOnFunctionCallResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointOnFunctionCall";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetBreakpointOnFunctionCallCommand<'a> {
        type Response = SetBreakpointOnFunctionCallResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetBreakpointOnFunctionCallResponse<'b> {
        type Command = SetBreakpointOnFunctionCallCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Activates / deactivates all breakpoints on the page.\n\n# Command `Debugger.setBreakpointsActive`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointsActiveCommand`](struct.SetBreakpointsActiveCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointsActiveResponse`](struct.SetBreakpointsActiveResponse.html)"]
    pub struct SetBreakpointsActiveCommand {
        #[serde(rename = "active")]
        #[doc = "New value for breakpoints active state."]
        pub active: bool,
    }
    impl ::CdpCommand for SetBreakpointsActiveCommand {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointsActive";
    }
    impl ::SerializeCdpCommand for SetBreakpointsActiveCommand {
        fn command_name(&self) -> &str {
            "Debugger.setBreakpointsActive"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetBreakpointsActiveCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setBreakpointsActive" {
                Ok ( < SetBreakpointsActiveCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Activates / deactivates all breakpoints on the page.\n\n# Command `Debugger.setBreakpointsActive`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetBreakpointsActiveCommand`](struct.SetBreakpointsActiveCommand.html)  \n*Response Struct:* [`cdp::debugger::SetBreakpointsActiveResponse`](struct.SetBreakpointsActiveResponse.html)"]
    pub struct SetBreakpointsActiveResponse;
    impl ::serde::Serialize for SetBreakpointsActiveResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetBreakpointsActiveResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetBreakpointsActiveResponse)
        }
    }
    impl ::CdpCommand for SetBreakpointsActiveResponse {
        const COMMAND_NAME: &'static str = "Debugger.setBreakpointsActive";
    }
    impl<'b> ::HasCdpResponse<'b> for SetBreakpointsActiveCommand {
        type Response = SetBreakpointsActiveResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetBreakpointsActiveResponse {
        type Command = SetBreakpointsActiveCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::debugger::SetPauseOnExceptionsCommand::state`](struct.SetPauseOnExceptionsCommand.html#structfield.state)."]
    pub enum SetPauseOnExceptionsCommandState {
        #[serde(rename = "none")]
        #[doc = "Represented as `\"none\"`."]
        None,
        #[serde(rename = "uncaught")]
        #[doc = "Represented as `\"uncaught\"`."]
        Uncaught,
        #[serde(rename = "all")]
        #[doc = "Represented as `\"all\"`."]
        All,
    }
    impl SetPauseOnExceptionsCommandState {
        pub const ENUM_VALUES: &'static [SetPauseOnExceptionsCommandState] =
            &[
                SetPauseOnExceptionsCommandState::None,
                SetPauseOnExceptionsCommandState::Uncaught,
                SetPauseOnExceptionsCommandState::All,
            ];
        pub const STR_VALUES: &'static [&'static str] = &["none", "uncaught", "all"];
    }
    impl ::std::str::FromStr for SetPauseOnExceptionsCommandState {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "none" => Ok(SetPauseOnExceptionsCommandState::None),
                "uncaught" => Ok(SetPauseOnExceptionsCommandState::Uncaught),
                "all" => Ok(SetPauseOnExceptionsCommandState::All),
                _ => Err(::ParseEnumError {
                    expected: SetPauseOnExceptionsCommandState::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for SetPauseOnExceptionsCommandState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    SetPauseOnExceptionsCommandState::None => "none",
                    SetPauseOnExceptionsCommandState::Uncaught => "uncaught",
                    SetPauseOnExceptionsCommandState::All => "all",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or\nno exceptions. Initial pause on exceptions state is `none`.\n\n# Command `Debugger.setPauseOnExceptions`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetPauseOnExceptionsCommand`](struct.SetPauseOnExceptionsCommand.html)  \n*Response Struct:* [`cdp::debugger::SetPauseOnExceptionsResponse`](struct.SetPauseOnExceptionsResponse.html)"]
    pub struct SetPauseOnExceptionsCommand {
        #[serde(rename = "state")]
        #[doc = "Pause on exceptions mode."]
        pub state: ::debugger::SetPauseOnExceptionsCommandState,
    }
    impl ::CdpCommand for SetPauseOnExceptionsCommand {
        const COMMAND_NAME: &'static str = "Debugger.setPauseOnExceptions";
    }
    impl ::SerializeCdpCommand for SetPauseOnExceptionsCommand {
        fn command_name(&self) -> &str {
            "Debugger.setPauseOnExceptions"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetPauseOnExceptionsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setPauseOnExceptions" {
                Ok ( < SetPauseOnExceptionsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or\nno exceptions. Initial pause on exceptions state is `none`.\n\n# Command `Debugger.setPauseOnExceptions`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetPauseOnExceptionsCommand`](struct.SetPauseOnExceptionsCommand.html)  \n*Response Struct:* [`cdp::debugger::SetPauseOnExceptionsResponse`](struct.SetPauseOnExceptionsResponse.html)"]
    pub struct SetPauseOnExceptionsResponse;
    impl ::serde::Serialize for SetPauseOnExceptionsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetPauseOnExceptionsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetPauseOnExceptionsResponse)
        }
    }
    impl ::CdpCommand for SetPauseOnExceptionsResponse {
        const COMMAND_NAME: &'static str = "Debugger.setPauseOnExceptions";
    }
    impl<'b> ::HasCdpResponse<'b> for SetPauseOnExceptionsCommand {
        type Response = SetPauseOnExceptionsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetPauseOnExceptionsResponse {
        type Command = SetPauseOnExceptionsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Changes return value in top frame. Available only at return break position.\n\n# Command `Debugger.setReturnValue`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetReturnValueCommand`](struct.SetReturnValueCommand.html)  \n*Response Struct:* [`cdp::debugger::SetReturnValueResponse`](struct.SetReturnValueResponse.html)"]
    pub struct SetReturnValueCommand<'a> {
        #[serde(rename = "newValue")]
        #[doc = "New return value."]
        pub new_value: ::runtime::CallArgument<'a>,
    }
    impl<'a> ::CdpCommand for SetReturnValueCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setReturnValue";
    }
    impl<'a> ::SerializeCdpCommand for SetReturnValueCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setReturnValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetReturnValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setReturnValue" {
                Ok(
                    <SetReturnValueCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Changes return value in top frame. Available only at return break position.\n\n# Command `Debugger.setReturnValue`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetReturnValueCommand`](struct.SetReturnValueCommand.html)  \n*Response Struct:* [`cdp::debugger::SetReturnValueResponse`](struct.SetReturnValueResponse.html)"]
    pub struct SetReturnValueResponse;
    impl ::serde::Serialize for SetReturnValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetReturnValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetReturnValueResponse)
        }
    }
    impl ::CdpCommand for SetReturnValueResponse {
        const COMMAND_NAME: &'static str = "Debugger.setReturnValue";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetReturnValueCommand<'a> {
        type Response = SetReturnValueResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetReturnValueResponse {
        type Command = SetReturnValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Edits JavaScript source live.\n\n# Command `Debugger.setScriptSource`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetScriptSourceCommand`](struct.SetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::debugger::SetScriptSourceResponse`](struct.SetScriptSourceResponse.html)"]
    pub struct SetScriptSourceCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to edit."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "scriptSource")]
        #[doc = "New content of the script."]
        pub script_source: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "dryRun", skip_serializing_if = "Option::is_none")]
        #[doc = "If true the change will not actually be applied. Dry run may be used to get result\ndescription without actually modifying the code."]
        pub dry_run: Option<bool>,
    }
    impl<'a> ::CdpCommand for SetScriptSourceCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setScriptSource";
    }
    impl<'a> ::SerializeCdpCommand for SetScriptSourceCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setScriptSource"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetScriptSourceCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setScriptSource" {
                Ok(
                    <SetScriptSourceCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Edits JavaScript source live.\n\n# Command `Debugger.setScriptSource`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetScriptSourceCommand`](struct.SetScriptSourceCommand.html)  \n*Response Struct:* [`cdp::debugger::SetScriptSourceResponse`](struct.SetScriptSourceResponse.html)"]
    pub struct SetScriptSourceResponse<'a> {
        #[serde(rename = "callFrames", skip_serializing_if = "Option::is_none")]
        #[doc = "New stack trace in case editing has happened while VM was stopped."]
        pub call_frames: Option<Vec<::debugger::CallFrame<'a>>>,
        #[serde(rename = "stackChanged", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether current call stack  was modified after applying the changes."]
        pub stack_changed: Option<bool>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "asyncStackTraceId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Async stack trace, if any."]
        pub async_stack_trace_id: Option<::runtime::StackTraceId<'a>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details if any."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for SetScriptSourceResponse<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setScriptSource";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetScriptSourceCommand<'a> {
        type Response = SetScriptSourceResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for SetScriptSourceResponse<'b> {
        type Command = SetScriptSourceCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n\n# Command `Debugger.setSkipAllPauses`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetSkipAllPausesCommand`](struct.SetSkipAllPausesCommand.html)  \n*Response Struct:* [`cdp::debugger::SetSkipAllPausesResponse`](struct.SetSkipAllPausesResponse.html)"]
    pub struct SetSkipAllPausesCommand {
        #[serde(rename = "skip")]
        #[doc = "New value for skip pauses state."]
        pub skip: bool,
    }
    impl ::CdpCommand for SetSkipAllPausesCommand {
        const COMMAND_NAME: &'static str = "Debugger.setSkipAllPauses";
    }
    impl ::SerializeCdpCommand for SetSkipAllPausesCommand {
        fn command_name(&self) -> &str {
            "Debugger.setSkipAllPauses"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetSkipAllPausesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setSkipAllPauses" {
                Ok ( < SetSkipAllPausesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Makes page not interrupt on any pauses \\(breakpoint, exception, dom exception etc\\).\n\n# Command `Debugger.setSkipAllPauses`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetSkipAllPausesCommand`](struct.SetSkipAllPausesCommand.html)  \n*Response Struct:* [`cdp::debugger::SetSkipAllPausesResponse`](struct.SetSkipAllPausesResponse.html)"]
    pub struct SetSkipAllPausesResponse;
    impl ::serde::Serialize for SetSkipAllPausesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSkipAllPausesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSkipAllPausesResponse)
        }
    }
    impl ::CdpCommand for SetSkipAllPausesResponse {
        const COMMAND_NAME: &'static str = "Debugger.setSkipAllPauses";
    }
    impl<'b> ::HasCdpResponse<'b> for SetSkipAllPausesCommand {
        type Response = SetSkipAllPausesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetSkipAllPausesResponse {
        type Command = SetSkipAllPausesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be\nmutated manually.\n\n# Command `Debugger.setVariableValue`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetVariableValueCommand`](struct.SetVariableValueCommand.html)  \n*Response Struct:* [`cdp::debugger::SetVariableValueResponse`](struct.SetVariableValueResponse.html)"]
    pub struct SetVariableValueCommand<'a> {
        #[serde(rename = "scopeNumber")]
        #[doc = "0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'\nscope types are allowed. Other scopes could be manipulated manually."]
        pub scope_number: i32,
        #[serde(rename = "variableName")]
        #[doc = "Variable name."]
        pub variable_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "newValue")]
        #[doc = "New variable value."]
        pub new_value: ::runtime::CallArgument<'a>,
        #[serde(rename = "callFrameId")]
        #[doc = "Id of callframe that holds variable."]
        pub call_frame_id: ::debugger::CallFrameId<'a>,
    }
    impl<'a> ::CdpCommand for SetVariableValueCommand<'a> {
        const COMMAND_NAME: &'static str = "Debugger.setVariableValue";
    }
    impl<'a> ::SerializeCdpCommand for SetVariableValueCommand<'a> {
        fn command_name(&self) -> &str {
            "Debugger.setVariableValue"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for SetVariableValueCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.setVariableValue" {
                Ok ( < SetVariableValueCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Changes value of variable in a callframe. Object-based scopes are not supported and must be\nmutated manually.\n\n# Command `Debugger.setVariableValue`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::SetVariableValueCommand`](struct.SetVariableValueCommand.html)  \n*Response Struct:* [`cdp::debugger::SetVariableValueResponse`](struct.SetVariableValueResponse.html)"]
    pub struct SetVariableValueResponse;
    impl ::serde::Serialize for SetVariableValueResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetVariableValueResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetVariableValueResponse)
        }
    }
    impl ::CdpCommand for SetVariableValueResponse {
        const COMMAND_NAME: &'static str = "Debugger.setVariableValue";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for SetVariableValueCommand<'a> {
        type Response = SetVariableValueResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetVariableValueResponse {
        type Command = SetVariableValueCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Steps into the function call.\n\n# Command `Debugger.stepInto`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepIntoCommand`](struct.StepIntoCommand.html)  \n*Response Struct:* [`cdp::debugger::StepIntoResponse`](struct.StepIntoResponse.html)"]
    pub struct StepIntoCommand {
        #[serde(rename = "breakOnAsyncCall", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Debugger will issue additional Debugger.paused notification if any async task is scheduled\nbefore next pause."]
        pub break_on_async_call: Option<bool>,
    }
    impl ::CdpCommand for StepIntoCommand {
        const COMMAND_NAME: &'static str = "Debugger.stepInto";
    }
    impl ::SerializeCdpCommand for StepIntoCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepInto"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StepIntoCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepInto" {
                Ok(
                    <StepIntoCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps into the function call.\n\n# Command `Debugger.stepInto`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepIntoCommand`](struct.StepIntoCommand.html)  \n*Response Struct:* [`cdp::debugger::StepIntoResponse`](struct.StepIntoResponse.html)"]
    pub struct StepIntoResponse;
    impl ::serde::Serialize for StepIntoResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepIntoResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepIntoResponse)
        }
    }
    impl ::CdpCommand for StepIntoResponse {
        const COMMAND_NAME: &'static str = "Debugger.stepInto";
    }
    impl<'b> ::HasCdpResponse<'b> for StepIntoCommand {
        type Response = StepIntoResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StepIntoResponse {
        type Command = StepIntoCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps out of the function call.\n\n# Command `Debugger.stepOut`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepOutCommand`](struct.StepOutCommand.html)  \n*Response Struct:* [`cdp::debugger::StepOutResponse`](struct.StepOutResponse.html)"]
    pub struct StepOutCommand;
    impl ::serde::Serialize for StepOutCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOutCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOutCommand)
        }
    }
    impl ::CdpCommand for StepOutCommand {
        const COMMAND_NAME: &'static str = "Debugger.stepOut";
    }
    impl ::SerializeCdpCommand for StepOutCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepOut"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StepOutCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepOut" {
                Ok(
                    <StepOutCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps out of the function call.\n\n# Command `Debugger.stepOut`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepOutCommand`](struct.StepOutCommand.html)  \n*Response Struct:* [`cdp::debugger::StepOutResponse`](struct.StepOutResponse.html)"]
    pub struct StepOutResponse;
    impl ::serde::Serialize for StepOutResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOutResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOutResponse)
        }
    }
    impl ::CdpCommand for StepOutResponse {
        const COMMAND_NAME: &'static str = "Debugger.stepOut";
    }
    impl<'b> ::HasCdpResponse<'b> for StepOutCommand {
        type Response = StepOutResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StepOutResponse {
        type Command = StepOutCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps over the statement.\n\n# Command `Debugger.stepOver`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepOverCommand`](struct.StepOverCommand.html)  \n*Response Struct:* [`cdp::debugger::StepOverResponse`](struct.StepOverResponse.html)"]
    pub struct StepOverCommand;
    impl ::serde::Serialize for StepOverCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOverCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOverCommand)
        }
    }
    impl ::CdpCommand for StepOverCommand {
        const COMMAND_NAME: &'static str = "Debugger.stepOver";
    }
    impl ::SerializeCdpCommand for StepOverCommand {
        fn command_name(&self) -> &str {
            "Debugger.stepOver"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StepOverCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.stepOver" {
                Ok(
                    <StepOverCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Steps over the statement.\n\n# Command `Debugger.stepOver`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Command Struct:* [`cdp::debugger::StepOverCommand`](struct.StepOverCommand.html)  \n*Response Struct:* [`cdp::debugger::StepOverResponse`](struct.StepOverResponse.html)"]
    pub struct StepOverResponse;
    impl ::serde::Serialize for StepOverResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StepOverResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StepOverResponse)
        }
    }
    impl ::CdpCommand for StepOverResponse {
        const COMMAND_NAME: &'static str = "Debugger.stepOver";
    }
    impl<'b> ::HasCdpResponse<'b> for StepOverCommand {
        type Response = StepOverResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StepOverResponse {
        type Command = StepOverCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when breakpoint is resolved to an actual script and location.\n\n# Event `Debugger.breakpointResolved`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Event Struct:* [`cdp::debugger::BreakpointResolvedEvent`](struct.BreakpointResolvedEvent.html)"]
    pub struct BreakpointResolvedEvent<'a> {
        #[serde(rename = "breakpointId")]
        #[doc = "Breakpoint unique identifier."]
        pub breakpoint_id: ::debugger::BreakpointId<'a>,
        #[serde(rename = "location")]
        #[doc = "Actual breakpoint location."]
        pub location: ::debugger::Location<'a>,
    }
    impl<'a> ::CdpEvent for BreakpointResolvedEvent<'a> {
        const EVENT_NAME: &'static str = "Debugger.breakpointResolved";
    }
    impl<'a> ::SerializeCdpEvent for BreakpointResolvedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.breakpointResolved"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for BreakpointResolvedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.breakpointResolved" {
                Ok ( < BreakpointResolvedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::debugger::PausedEvent::reason`](struct.PausedEvent.html#structfield.reason)."]
    pub enum PausedEventReason {
        #[serde(rename = "XHR")]
        #[doc = "Represented as `\"XHR\"`."]
        Xhr,
        #[serde(rename = "DOM")]
        #[doc = "Represented as `\"DOM\"`."]
        Dom,
        #[serde(rename = "EventListener")]
        #[doc = "Represented as `\"EventListener\"`."]
        EventListener,
        #[serde(rename = "exception")]
        #[doc = "Represented as `\"exception\"`."]
        Exception,
        #[serde(rename = "assert")]
        #[doc = "Represented as `\"assert\"`."]
        Assert,
        #[serde(rename = "debugCommand")]
        #[doc = "Represented as `\"debugCommand\"`."]
        DebugCommand,
        #[serde(rename = "promiseRejection")]
        #[doc = "Represented as `\"promiseRejection\"`."]
        PromiseRejection,
        #[serde(rename = "OOM")]
        #[doc = "Represented as `\"OOM\"`."]
        Oom,
        #[serde(rename = "other")]
        #[doc = "Represented as `\"other\"`."]
        Other,
        #[serde(rename = "ambiguous")]
        #[doc = "Represented as `\"ambiguous\"`."]
        Ambiguous,
    }
    impl PausedEventReason {
        pub const ENUM_VALUES: &'static [PausedEventReason] = &[
            PausedEventReason::Xhr,
            PausedEventReason::Dom,
            PausedEventReason::EventListener,
            PausedEventReason::Exception,
            PausedEventReason::Assert,
            PausedEventReason::DebugCommand,
            PausedEventReason::PromiseRejection,
            PausedEventReason::Oom,
            PausedEventReason::Other,
            PausedEventReason::Ambiguous,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "XHR",
            "DOM",
            "EventListener",
            "exception",
            "assert",
            "debugCommand",
            "promiseRejection",
            "OOM",
            "other",
            "ambiguous",
        ];
    }
    impl ::std::str::FromStr for PausedEventReason {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "XHR" => Ok(PausedEventReason::Xhr),
                "DOM" => Ok(PausedEventReason::Dom),
                "EventListener" => Ok(PausedEventReason::EventListener),
                "exception" => Ok(PausedEventReason::Exception),
                "assert" => Ok(PausedEventReason::Assert),
                "debugCommand" => Ok(PausedEventReason::DebugCommand),
                "promiseRejection" => Ok(PausedEventReason::PromiseRejection),
                "OOM" => Ok(PausedEventReason::Oom),
                "other" => Ok(PausedEventReason::Other),
                "ambiguous" => Ok(PausedEventReason::Ambiguous),
                _ => Err(::ParseEnumError {
                    expected: PausedEventReason::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PausedEventReason {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PausedEventReason::Xhr => "XHR",
                    PausedEventReason::Dom => "DOM",
                    PausedEventReason::EventListener => "EventListener",
                    PausedEventReason::Exception => "exception",
                    PausedEventReason::Assert => "assert",
                    PausedEventReason::DebugCommand => "debugCommand",
                    PausedEventReason::PromiseRejection => "promiseRejection",
                    PausedEventReason::Oom => "OOM",
                    PausedEventReason::Other => "other",
                    PausedEventReason::Ambiguous => "ambiguous",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.\n\n# Event `Debugger.paused`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Event Struct:* [`cdp::debugger::PausedEvent`](struct.PausedEvent.html)"]
    pub struct PausedEvent<'a> {
        #[serde(rename = "callFrames")]
        #[doc = "Call stack the virtual machine stopped on."]
        pub call_frames: Vec<::debugger::CallFrame<'a>>,
        #[serde(rename = "reason")]
        #[doc = "Pause reason."]
        pub reason: ::debugger::PausedEventReason,
        #[serde(rename = "data", skip_serializing_if = "Option::is_none")]
        #[doc = "Object containing break-specific auxiliary properties."]
        pub data: Option<::Empty>,
        #[serde(rename = "hitBreakpoints", skip_serializing_if = "Option::is_none")]
        #[doc = "Hit breakpoints IDs"]
        pub hit_breakpoints: Option<Vec<::std::borrow::Cow<'a, str>>>,
        #[serde(rename = "asyncStackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Async stack trace, if any."]
        pub async_stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "asyncStackTraceId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Async stack trace, if any."]
        pub async_stack_trace_id: Option<::runtime::StackTraceId<'a>>,
        #[serde(rename = "asyncCallStackTraceId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Just scheduled async call will have this stack trace as parent stack during async execution.\nThis field is available only after `Debugger.stepInto` call with `breakOnAsynCall` flag."]
        pub async_call_stack_trace_id: Option<::runtime::StackTraceId<'a>>,
    }
    impl<'a> ::CdpEvent for PausedEvent<'a> {
        const EVENT_NAME: &'static str = "Debugger.paused";
    }
    impl<'a> ::SerializeCdpEvent for PausedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.paused"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for PausedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.paused" {
                Ok(
                    <PausedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Fired when the virtual machine resumed execution.\n\n# Event `Debugger.resumed`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Event Struct:* [`cdp::debugger::ResumedEvent`](struct.ResumedEvent.html)"]
    pub struct ResumedEvent;
    impl ::serde::Serialize for ResumedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResumedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| ResumedEvent)
        }
    }
    impl ::CdpEvent for ResumedEvent {
        const EVENT_NAME: &'static str = "Debugger.resumed";
    }
    impl ::SerializeCdpEvent for ResumedEvent {
        fn event_name(&self) -> &str {
            "Debugger.resumed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ResumedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.resumed" {
                Ok(
                    <ResumedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when virtual machine fails to parse the script.\n\n# Event `Debugger.scriptFailedToParse`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Event Struct:* [`cdp::debugger::ScriptFailedToParseEvent`](struct.ScriptFailedToParseEvent.html)"]
    pub struct ScriptFailedToParseEvent<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Identifier of the script parsed."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL or name of the script parsed \\(if any\\)."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the script within the resource with given URL \\(for script tags\\)."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the script within the resource with given URL."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "Last line of the script."]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "Length of the last line of the script."]
        pub end_column: i32,
        #[serde(rename = "executionContextId")]
        #[doc = "Specifies script creation context."]
        pub execution_context_id: ::runtime::ExecutionContextId,
        #[serde(rename = "hash")]
        #[doc = "Content hash of the script."]
        pub hash: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextAuxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub execution_context_aux_data: Option<::Empty>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "True, if this script has sourceURL."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isModule", skip_serializing_if = "Option::is_none")]
        #[doc = "True, if this script is ES6 module."]
        pub is_module: Option<bool>,
        #[serde(rename = "length", skip_serializing_if = "Option::is_none")]
        #[doc = "This script length."]
        pub length: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> JavaScript top stack frame of where the script parsed event was triggered if available."]
        pub stack_trace: Option<::runtime::StackTrace<'a>>,
    }
    impl<'a> ::CdpEvent for ScriptFailedToParseEvent<'a> {
        const EVENT_NAME: &'static str = "Debugger.scriptFailedToParse";
    }
    impl<'a> ::SerializeCdpEvent for ScriptFailedToParseEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.scriptFailedToParse"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ScriptFailedToParseEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scriptFailedToParse" {
                Ok ( < ScriptFailedToParseEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Fired when virtual machine parses script. This event is also fired for all known and uncollected\nscripts upon enabling debugger.\n\n# Event `Debugger.scriptParsed`\n\n*Domain Module:* [`cdp::debugger`](index.html)  \n*Event Struct:* [`cdp::debugger::ScriptParsedEvent`](struct.ScriptParsedEvent.html)"]
    pub struct ScriptParsedEvent<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Identifier of the script parsed."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "URL or name of the script parsed \\(if any\\)."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "startLine")]
        #[doc = "Line offset of the script within the resource with given URL \\(for script tags\\)."]
        pub start_line: i32,
        #[serde(rename = "startColumn")]
        #[doc = "Column offset of the script within the resource with given URL."]
        pub start_column: i32,
        #[serde(rename = "endLine")]
        #[doc = "Last line of the script."]
        pub end_line: i32,
        #[serde(rename = "endColumn")]
        #[doc = "Length of the last line of the script."]
        pub end_column: i32,
        #[serde(rename = "executionContextId")]
        #[doc = "Specifies script creation context."]
        pub execution_context_id: ::runtime::ExecutionContextId,
        #[serde(rename = "hash")]
        #[doc = "Content hash of the script."]
        pub hash: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextAuxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub execution_context_aux_data: Option<::Empty>,
        #[serde(rename = "isLiveEdit", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> True, if this script is generated as a result of the live edit operation."]
        pub is_live_edit: Option<bool>,
        #[serde(rename = "sourceMapURL", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of source map associated with script \\(if any\\)."]
        pub source_map_url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "hasSourceURL", skip_serializing_if = "Option::is_none")]
        #[doc = "True, if this script has sourceURL."]
        pub has_source_url: Option<bool>,
        #[serde(rename = "isModule", skip_serializing_if = "Option::is_none")]
        #[doc = "True, if this script is ES6 module."]
        pub is_module: Option<bool>,
        #[serde(rename = "length", skip_serializing_if = "Option::is_none")]
        #[doc = "This script length."]
        pub length: Option<i32>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> JavaScript top stack frame of where the script parsed event was triggered if available."]
        pub stack_trace: Option<::runtime::StackTrace<'a>>,
    }
    impl<'a> ::CdpEvent for ScriptParsedEvent<'a> {
        const EVENT_NAME: &'static str = "Debugger.scriptParsed";
    }
    impl<'a> ::SerializeCdpEvent for ScriptParsedEvent<'a> {
        fn event_name(&self) -> &str {
            "Debugger.scriptParsed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ScriptParsedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Debugger.scriptParsed" {
                Ok(
                    <ScriptParsedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Breakpoint identifier."]
    pub type BreakpointId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Call frame identifier."]
    pub type CallFrameId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Location in the source code."]
    pub struct Location<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Script identifier as reported in the `Debugger.scriptParsed`."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: Option<i32>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Location in the source code."]
    pub struct ScriptPosition {
        #[serde(rename = "lineNumber")]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        pub column_number: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "JavaScript call frame. Array of call frames form the call stack."]
    pub struct CallFrame<'a> {
        #[serde(rename = "callFrameId")]
        #[doc = "Call frame identifier. This identifier is only valid while the virtual machine is paused."]
        pub call_frame_id: ::debugger::CallFrameId<'a>,
        #[serde(rename = "functionName")]
        #[doc = "Name of the JavaScript function called on this call frame."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "functionLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "Location in the source code."]
        pub function_location: Option<::debugger::Location<'a>>,
        #[serde(rename = "location")]
        #[doc = "Location in the source code."]
        pub location: ::debugger::Location<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scopeChain")]
        #[doc = "Scope chain for this call frame."]
        pub scope_chain: Vec<::debugger::Scope<'a>>,
        #[serde(rename = "this")]
        #[doc = "`this` object for this call frame."]
        pub this: ::runtime::RemoteObject<'a>,
        #[serde(rename = "returnValue", skip_serializing_if = "Option::is_none")]
        #[doc = "The value being returned, if the function is at return point."]
        pub return_value: Option<::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::debugger::Scope::ty`](struct.Scope.html#structfield.ty)."]
    pub enum ScopeType {
        #[serde(rename = "global")]
        #[doc = "Represented as `\"global\"`."]
        Global,
        #[serde(rename = "local")]
        #[doc = "Represented as `\"local\"`."]
        Local,
        #[serde(rename = "with")]
        #[doc = "Represented as `\"with\"`."]
        With,
        #[serde(rename = "closure")]
        #[doc = "Represented as `\"closure\"`."]
        Closure,
        #[serde(rename = "catch")]
        #[doc = "Represented as `\"catch\"`."]
        Catch,
        #[serde(rename = "block")]
        #[doc = "Represented as `\"block\"`."]
        Block,
        #[serde(rename = "script")]
        #[doc = "Represented as `\"script\"`."]
        Script,
        #[serde(rename = "eval")]
        #[doc = "Represented as `\"eval\"`."]
        Eval,
        #[serde(rename = "module")]
        #[doc = "Represented as `\"module\"`."]
        Module,
    }
    impl ScopeType {
        pub const ENUM_VALUES: &'static [ScopeType] = &[
            ScopeType::Global,
            ScopeType::Local,
            ScopeType::With,
            ScopeType::Closure,
            ScopeType::Catch,
            ScopeType::Block,
            ScopeType::Script,
            ScopeType::Eval,
            ScopeType::Module,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "global",
            "local",
            "with",
            "closure",
            "catch",
            "block",
            "script",
            "eval",
            "module",
        ];
    }
    impl ::std::str::FromStr for ScopeType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "global" => Ok(ScopeType::Global),
                "local" => Ok(ScopeType::Local),
                "with" => Ok(ScopeType::With),
                "closure" => Ok(ScopeType::Closure),
                "catch" => Ok(ScopeType::Catch),
                "block" => Ok(ScopeType::Block),
                "script" => Ok(ScopeType::Script),
                "eval" => Ok(ScopeType::Eval),
                "module" => Ok(ScopeType::Module),
                _ => Err(::ParseEnumError {
                    expected: ScopeType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ScopeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ScopeType::Global => "global",
                    ScopeType::Local => "local",
                    ScopeType::With => "with",
                    ScopeType::Closure => "closure",
                    ScopeType::Catch => "catch",
                    ScopeType::Block => "block",
                    ScopeType::Script => "script",
                    ScopeType::Eval => "eval",
                    ScopeType::Module => "module",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Scope description."]
    pub struct Scope<'a> {
        #[serde(rename = "type")]
        #[doc = "Scope type."]
        pub ty: ::debugger::ScopeType,
        #[serde(rename = "object")]
        #[doc = "Object representing the scope. For `global` and `with` scopes it represents the actual\nobject; for the rest of the scopes, it is artificial transient object enumerating scope\nvariables as its properties."]
        pub object: ::runtime::RemoteObject<'a>,
        #[serde(rename = "name", skip_serializing_if = "Option::is_none")]
        pub name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "startLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "Location in the source code where scope starts"]
        pub start_location: Option<::debugger::Location<'a>>,
        #[serde(rename = "endLocation", skip_serializing_if = "Option::is_none")]
        #[doc = "Location in the source code where scope ends"]
        pub end_location: Option<::debugger::Location<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Search match for resource."]
    pub struct SearchMatch<'a> {
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in resource content."]
        pub line_number: f64,
        #[serde(rename = "lineContent")]
        #[doc = "Line with match content."]
        pub line_content: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::debugger::BreakLocation::ty`](struct.BreakLocation.html#structfield.ty)."]
    pub enum BreakLocationType {
        #[serde(rename = "debuggerStatement")]
        #[doc = "Represented as `\"debuggerStatement\"`."]
        DebuggerStatement,
        #[serde(rename = "call")]
        #[doc = "Represented as `\"call\"`."]
        Call,
        #[serde(rename = "return")]
        #[doc = "Represented as `\"return\"`."]
        Return,
    }
    impl BreakLocationType {
        pub const ENUM_VALUES: &'static [BreakLocationType] = &[
            BreakLocationType::DebuggerStatement,
            BreakLocationType::Call,
            BreakLocationType::Return,
        ];
        pub const STR_VALUES: &'static [&'static str] = &["debuggerStatement", "call", "return"];
    }
    impl ::std::str::FromStr for BreakLocationType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "debuggerStatement" => Ok(BreakLocationType::DebuggerStatement),
                "call" => Ok(BreakLocationType::Call),
                "return" => Ok(BreakLocationType::Return),
                _ => Err(::ParseEnumError {
                    expected: BreakLocationType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for BreakLocationType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    BreakLocationType::DebuggerStatement => "debuggerStatement",
                    BreakLocationType::Call => "call",
                    BreakLocationType::Return => "return",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    pub struct BreakLocation<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Script identifier as reported in the `Debugger.scriptParsed`."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number in the script \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber", skip_serializing_if = "Option::is_none")]
        #[doc = "Column number in the script \\(0-based\\)."]
        pub column_number: Option<i32>,
        #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
        pub ty: Option<::debugger::BreakLocationType>,
    }
}
#[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# HeapProfiler\n\n## Commands\n\n- [`HeapProfiler.addInspectedHeapObject`](struct.AddInspectedHeapObjectCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n  $x functions\\).\n- [`HeapProfiler.collectGarbage`](struct.CollectGarbageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.disable`](struct.DisableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.enable`](struct.EnableCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.getHeapObjectId`](struct.GetHeapObjectIdCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.getObjectByHeapObjectId`](struct.GetObjectByHeapObjectIdCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.getSamplingProfile`](struct.GetSamplingProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.startSampling`](struct.StartSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.startTrackingHeapObjects`](struct.StartTrackingHeapObjectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.stopSampling`](struct.StopSamplingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.stopTrackingHeapObjects`](struct.StopTrackingHeapObjectsCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.takeHeapSnapshot`](struct.TakeHeapSnapshotCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n## Events\n\n- [`HeapProfiler.addHeapSnapshotChunk`](struct.AddHeapSnapshotChunkEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.heapStatsUpdate`](struct.HeapStatsUpdateEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If heap objects tracking has been started then backend may send update for one or more fragments\n- [`HeapProfiler.lastSeenObjectId`](struct.LastSeenObjectIdEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If heap objects tracking has been started then backend regularly sends a current value for last\n  seen object id and corresponding timestamp. If the were changes in the heap since last event\n  then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n- [`HeapProfiler.reportHeapSnapshotProgress`](struct.ReportHeapSnapshotProgressEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`HeapProfiler.resetProfiles`](struct.ResetProfilesEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n##Types\n\n- [`HeapSnapshotObjectId`](type.HeapSnapshotObjectId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Heap snapshot object id.\n- [`SamplingHeapProfileNode`](struct.SamplingHeapProfileNode.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.\n- [`SamplingHeapProfile`](struct.SamplingHeapProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Profile.\n"]
pub mod heap_profiler {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n$x functions\\).\n\n# Command `HeapProfiler.addInspectedHeapObject`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::AddInspectedHeapObjectCommand`](struct.AddInspectedHeapObjectCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::AddInspectedHeapObjectResponse`](struct.AddInspectedHeapObjectResponse.html)"]
    pub struct AddInspectedHeapObjectCommand<'a> {
        #[serde(rename = "heapObjectId")]
        #[doc = "Heap snapshot object id to be accessible by means of $x command line API."]
        pub heap_object_id: ::heap_profiler::HeapSnapshotObjectId<'a>,
    }
    impl<'a> ::CdpCommand for AddInspectedHeapObjectCommand<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.addInspectedHeapObject";
    }
    impl<'a> ::SerializeCdpCommand for AddInspectedHeapObjectCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.addInspectedHeapObject"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddInspectedHeapObjectCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.addInspectedHeapObject" {
                Ok ( < AddInspectedHeapObjectCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enables console to refer to the node with given id via $x \\(see Command Line API for more details\n$x functions\\).\n\n# Command `HeapProfiler.addInspectedHeapObject`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::AddInspectedHeapObjectCommand`](struct.AddInspectedHeapObjectCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::AddInspectedHeapObjectResponse`](struct.AddInspectedHeapObjectResponse.html)"]
    pub struct AddInspectedHeapObjectResponse;
    impl ::serde::Serialize for AddInspectedHeapObjectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AddInspectedHeapObjectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| AddInspectedHeapObjectResponse)
        }
    }
    impl ::CdpCommand for AddInspectedHeapObjectResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.addInspectedHeapObject";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddInspectedHeapObjectCommand<'a> {
        type Response = AddInspectedHeapObjectResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for AddInspectedHeapObjectResponse {
        type Command = AddInspectedHeapObjectCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.collectGarbage`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::CollectGarbageCommand`](struct.CollectGarbageCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::CollectGarbageResponse`](struct.CollectGarbageResponse.html)"]
    pub struct CollectGarbageCommand;
    impl ::serde::Serialize for CollectGarbageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CollectGarbageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CollectGarbageCommand)
        }
    }
    impl ::CdpCommand for CollectGarbageCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.collectGarbage";
    }
    impl ::SerializeCdpCommand for CollectGarbageCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.collectGarbage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for CollectGarbageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.collectGarbage" {
                Ok(
                    <CollectGarbageCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.collectGarbage`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::CollectGarbageCommand`](struct.CollectGarbageCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::CollectGarbageResponse`](struct.CollectGarbageResponse.html)"]
    pub struct CollectGarbageResponse;
    impl ::serde::Serialize for CollectGarbageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CollectGarbageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| CollectGarbageResponse)
        }
    }
    impl ::CdpCommand for CollectGarbageResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.collectGarbage";
    }
    impl<'b> ::HasCdpResponse<'b> for CollectGarbageCommand {
        type Response = CollectGarbageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for CollectGarbageResponse {
        type Command = CollectGarbageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.disable`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.disable`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.enable`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.enable`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getHeapObjectId`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetHeapObjectIdCommand`](struct.GetHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetHeapObjectIdResponse`](struct.GetHeapObjectIdResponse.html)"]
    pub struct GetHeapObjectIdCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to get heap object id for."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::CdpCommand for GetHeapObjectIdCommand<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.getHeapObjectId";
    }
    impl<'a> ::SerializeCdpCommand for GetHeapObjectIdCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.getHeapObjectId"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetHeapObjectIdCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.getHeapObjectId" {
                Ok(
                    <GetHeapObjectIdCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getHeapObjectId`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetHeapObjectIdCommand`](struct.GetHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetHeapObjectIdResponse`](struct.GetHeapObjectIdResponse.html)"]
    pub struct GetHeapObjectIdResponse<'a> {
        #[serde(rename = "heapSnapshotObjectId")]
        #[doc = "Id of the heap snapshot object corresponding to the passed remote object id."]
        pub heap_snapshot_object_id: ::heap_profiler::HeapSnapshotObjectId<'a>,
    }
    impl<'a> ::CdpCommand for GetHeapObjectIdResponse<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.getHeapObjectId";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetHeapObjectIdCommand<'a> {
        type Response = GetHeapObjectIdResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetHeapObjectIdResponse<'b> {
        type Command = GetHeapObjectIdCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getObjectByHeapObjectId`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetObjectByHeapObjectIdCommand`](struct.GetObjectByHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetObjectByHeapObjectIdResponse`](struct.GetObjectByHeapObjectIdResponse.html)"]
    pub struct GetObjectByHeapObjectIdCommand<'a> {
        #[serde(rename = "objectId")]
        pub object_id: ::heap_profiler::HeapSnapshotObjectId<'a>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GetObjectByHeapObjectIdCommand<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.getObjectByHeapObjectId";
    }
    impl<'a> ::SerializeCdpCommand for GetObjectByHeapObjectIdCommand<'a> {
        fn command_name(&self) -> &str {
            "HeapProfiler.getObjectByHeapObjectId"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetObjectByHeapObjectIdCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.getObjectByHeapObjectId" {
                Ok ( < GetObjectByHeapObjectIdCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getObjectByHeapObjectId`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetObjectByHeapObjectIdCommand`](struct.GetObjectByHeapObjectIdCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetObjectByHeapObjectIdResponse`](struct.GetObjectByHeapObjectIdResponse.html)"]
    pub struct GetObjectByHeapObjectIdResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Evaluation result."]
        pub result: ::runtime::RemoteObject<'a>,
    }
    impl<'a> ::CdpCommand for GetObjectByHeapObjectIdResponse<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.getObjectByHeapObjectId";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetObjectByHeapObjectIdCommand<'a> {
        type Response = GetObjectByHeapObjectIdResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetObjectByHeapObjectIdResponse<'b> {
        type Command = GetObjectByHeapObjectIdCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getSamplingProfile`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetSamplingProfileCommand`](struct.GetSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetSamplingProfileResponse`](struct.GetSamplingProfileResponse.html)"]
    pub struct GetSamplingProfileCommand;
    impl ::serde::Serialize for GetSamplingProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetSamplingProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetSamplingProfileCommand)
        }
    }
    impl ::CdpCommand for GetSamplingProfileCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.getSamplingProfile";
    }
    impl ::SerializeCdpCommand for GetSamplingProfileCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.getSamplingProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetSamplingProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.getSamplingProfile" {
                Ok ( < GetSamplingProfileCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.getSamplingProfile`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::GetSamplingProfileCommand`](struct.GetSamplingProfileCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::GetSamplingProfileResponse`](struct.GetSamplingProfileResponse.html)"]
    pub struct GetSamplingProfileResponse<'a> {
        #[serde(rename = "profile")]
        #[doc = "Return the sampling profile being collected."]
        pub profile: ::heap_profiler::SamplingHeapProfile<'a>,
    }
    impl<'a> ::CdpCommand for GetSamplingProfileResponse<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.getSamplingProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for GetSamplingProfileCommand {
        type Response = GetSamplingProfileResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetSamplingProfileResponse<'b> {
        type Command = GetSamplingProfileCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startSampling`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingCommand {
        #[serde(rename = "samplingInterval", skip_serializing_if = "Option::is_none")]
        #[doc = "Average sample interval in bytes. Poisson distribution is used for the intervals. The\ndefault value is 32768 bytes."]
        pub sampling_interval: Option<f64>,
    }
    impl ::CdpCommand for StartSamplingCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.startSampling";
    }
    impl ::SerializeCdpCommand for StartSamplingCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.startSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.startSampling" {
                Ok(
                    <StartSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startSampling`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StartSamplingCommand`](struct.StartSamplingCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StartSamplingResponse`](struct.StartSamplingResponse.html)"]
    pub struct StartSamplingResponse;
    impl ::serde::Serialize for StartSamplingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartSamplingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartSamplingResponse)
        }
    }
    impl ::CdpCommand for StartSamplingResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.startSampling";
    }
    impl<'b> ::HasCdpResponse<'b> for StartSamplingCommand {
        type Response = StartSamplingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartSamplingResponse {
        type Command = StartSamplingCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startTrackingHeapObjects`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StartTrackingHeapObjectsCommand`](struct.StartTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StartTrackingHeapObjectsResponse`](struct.StartTrackingHeapObjectsResponse.html)"]
    pub struct StartTrackingHeapObjectsCommand {
        #[serde(rename = "trackAllocations", skip_serializing_if = "Option::is_none")]
        pub track_allocations: Option<bool>,
    }
    impl ::CdpCommand for StartTrackingHeapObjectsCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.startTrackingHeapObjects";
    }
    impl ::SerializeCdpCommand for StartTrackingHeapObjectsCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.startTrackingHeapObjects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartTrackingHeapObjectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.startTrackingHeapObjects" {
                Ok ( < StartTrackingHeapObjectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.startTrackingHeapObjects`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StartTrackingHeapObjectsCommand`](struct.StartTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StartTrackingHeapObjectsResponse`](struct.StartTrackingHeapObjectsResponse.html)"]
    pub struct StartTrackingHeapObjectsResponse;
    impl ::serde::Serialize for StartTrackingHeapObjectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartTrackingHeapObjectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartTrackingHeapObjectsResponse)
        }
    }
    impl ::CdpCommand for StartTrackingHeapObjectsResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.startTrackingHeapObjects";
    }
    impl<'b> ::HasCdpResponse<'b> for StartTrackingHeapObjectsCommand {
        type Response = StartTrackingHeapObjectsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartTrackingHeapObjectsResponse {
        type Command = StartTrackingHeapObjectsCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopSampling`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingCommand;
    impl ::serde::Serialize for StopSamplingCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopSamplingCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopSamplingCommand)
        }
    }
    impl ::CdpCommand for StopSamplingCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.stopSampling";
    }
    impl ::SerializeCdpCommand for StopSamplingCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.stopSampling"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopSamplingCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.stopSampling" {
                Ok(
                    <StopSamplingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopSampling`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StopSamplingCommand`](struct.StopSamplingCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StopSamplingResponse`](struct.StopSamplingResponse.html)"]
    pub struct StopSamplingResponse<'a> {
        #[serde(rename = "profile")]
        #[doc = "Recorded sampling heap profile."]
        pub profile: ::heap_profiler::SamplingHeapProfile<'a>,
    }
    impl<'a> ::CdpCommand for StopSamplingResponse<'a> {
        const COMMAND_NAME: &'static str = "HeapProfiler.stopSampling";
    }
    impl<'b> ::HasCdpResponse<'b> for StopSamplingCommand {
        type Response = StopSamplingResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for StopSamplingResponse<'b> {
        type Command = StopSamplingCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopTrackingHeapObjects`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StopTrackingHeapObjectsCommand`](struct.StopTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StopTrackingHeapObjectsResponse`](struct.StopTrackingHeapObjectsResponse.html)"]
    pub struct StopTrackingHeapObjectsCommand {
        #[serde(rename = "reportProgress", skip_serializing_if = "Option::is_none")]
        #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken\nwhen the tracking is stopped."]
        pub report_progress: Option<bool>,
    }
    impl ::CdpCommand for StopTrackingHeapObjectsCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.stopTrackingHeapObjects";
    }
    impl ::SerializeCdpCommand for StopTrackingHeapObjectsCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.stopTrackingHeapObjects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopTrackingHeapObjectsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.stopTrackingHeapObjects" {
                Ok ( < StopTrackingHeapObjectsCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.stopTrackingHeapObjects`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::StopTrackingHeapObjectsCommand`](struct.StopTrackingHeapObjectsCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::StopTrackingHeapObjectsResponse`](struct.StopTrackingHeapObjectsResponse.html)"]
    pub struct StopTrackingHeapObjectsResponse;
    impl ::serde::Serialize for StopTrackingHeapObjectsResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopTrackingHeapObjectsResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopTrackingHeapObjectsResponse)
        }
    }
    impl ::CdpCommand for StopTrackingHeapObjectsResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.stopTrackingHeapObjects";
    }
    impl<'b> ::HasCdpResponse<'b> for StopTrackingHeapObjectsCommand {
        type Response = StopTrackingHeapObjectsResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopTrackingHeapObjectsResponse {
        type Command = StopTrackingHeapObjectsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.takeHeapSnapshot`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::TakeHeapSnapshotCommand`](struct.TakeHeapSnapshotCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::TakeHeapSnapshotResponse`](struct.TakeHeapSnapshotResponse.html)"]
    pub struct TakeHeapSnapshotCommand {
        #[serde(rename = "reportProgress", skip_serializing_if = "Option::is_none")]
        #[doc = "If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken."]
        pub report_progress: Option<bool>,
    }
    impl ::CdpCommand for TakeHeapSnapshotCommand {
        const COMMAND_NAME: &'static str = "HeapProfiler.takeHeapSnapshot";
    }
    impl ::SerializeCdpCommand for TakeHeapSnapshotCommand {
        fn command_name(&self) -> &str {
            "HeapProfiler.takeHeapSnapshot"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for TakeHeapSnapshotCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.takeHeapSnapshot" {
                Ok ( < TakeHeapSnapshotCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `HeapProfiler.takeHeapSnapshot`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Command Struct:* [`cdp::heap_profiler::TakeHeapSnapshotCommand`](struct.TakeHeapSnapshotCommand.html)  \n*Response Struct:* [`cdp::heap_profiler::TakeHeapSnapshotResponse`](struct.TakeHeapSnapshotResponse.html)"]
    pub struct TakeHeapSnapshotResponse;
    impl ::serde::Serialize for TakeHeapSnapshotResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakeHeapSnapshotResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakeHeapSnapshotResponse)
        }
    }
    impl ::CdpCommand for TakeHeapSnapshotResponse {
        const COMMAND_NAME: &'static str = "HeapProfiler.takeHeapSnapshot";
    }
    impl<'b> ::HasCdpResponse<'b> for TakeHeapSnapshotCommand {
        type Response = TakeHeapSnapshotResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for TakeHeapSnapshotResponse {
        type Command = TakeHeapSnapshotCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.addHeapSnapshotChunk`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::heap_profiler::AddHeapSnapshotChunkEvent`](struct.AddHeapSnapshotChunkEvent.html)"]
    pub struct AddHeapSnapshotChunkEvent<'a> {
        #[serde(rename = "chunk")]
        pub chunk: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpEvent for AddHeapSnapshotChunkEvent<'a> {
        const EVENT_NAME: &'static str = "HeapProfiler.addHeapSnapshotChunk";
    }
    impl<'a> ::SerializeCdpEvent for AddHeapSnapshotChunkEvent<'a> {
        fn event_name(&self) -> &str {
            "HeapProfiler.addHeapSnapshotChunk"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for AddHeapSnapshotChunkEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.addHeapSnapshotChunk" {
                Ok ( < AddHeapSnapshotChunkEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If heap objects tracking has been started then backend may send update for one or more fragments\n\n# Event `HeapProfiler.heapStatsUpdate`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::heap_profiler::HeapStatsUpdateEvent`](struct.HeapStatsUpdateEvent.html)"]
    pub struct HeapStatsUpdateEvent {
        #[serde(rename = "statsUpdate")]
        #[doc = "An array of triplets. Each triplet describes a fragment. The first integer is the fragment\nindex, the second integer is a total count of objects for the fragment, the third integer is\na total size of the objects for the fragment."]
        pub stats_update: Vec<i32>,
    }
    impl ::CdpEvent for HeapStatsUpdateEvent {
        const EVENT_NAME: &'static str = "HeapProfiler.heapStatsUpdate";
    }
    impl ::SerializeCdpEvent for HeapStatsUpdateEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.heapStatsUpdate"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for HeapStatsUpdateEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.heapStatsUpdate" {
                Ok(
                    <HeapStatsUpdateEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If heap objects tracking has been started then backend regularly sends a current value for last\nseen object id and corresponding timestamp. If the were changes in the heap since last event\nthen one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.\n\n# Event `HeapProfiler.lastSeenObjectId`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::heap_profiler::LastSeenObjectIdEvent`](struct.LastSeenObjectIdEvent.html)"]
    pub struct LastSeenObjectIdEvent {
        #[serde(rename = "lastSeenObjectId")]
        pub last_seen_object_id: i32,
        #[serde(rename = "timestamp")]
        pub timestamp: f64,
    }
    impl ::CdpEvent for LastSeenObjectIdEvent {
        const EVENT_NAME: &'static str = "HeapProfiler.lastSeenObjectId";
    }
    impl ::SerializeCdpEvent for LastSeenObjectIdEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.lastSeenObjectId"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for LastSeenObjectIdEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.lastSeenObjectId" {
                Ok(
                    <LastSeenObjectIdEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.reportHeapSnapshotProgress`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::heap_profiler::ReportHeapSnapshotProgressEvent`](struct.ReportHeapSnapshotProgressEvent.html)"]
    pub struct ReportHeapSnapshotProgressEvent {
        #[serde(rename = "done")]
        pub done: i32,
        #[serde(rename = "total")]
        pub total: i32,
        #[serde(rename = "finished", skip_serializing_if = "Option::is_none")]
        pub finished: Option<bool>,
    }
    impl ::CdpEvent for ReportHeapSnapshotProgressEvent {
        const EVENT_NAME: &'static str = "HeapProfiler.reportHeapSnapshotProgress";
    }
    impl ::SerializeCdpEvent for ReportHeapSnapshotProgressEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.reportHeapSnapshotProgress"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ReportHeapSnapshotProgressEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.reportHeapSnapshotProgress" {
                Ok ( < ReportHeapSnapshotProgressEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Event `HeapProfiler.resetProfiles`\n\n*Domain Module:* [`cdp::heap_profiler`](index.html)  \n*Event Struct:* [`cdp::heap_profiler::ResetProfilesEvent`](struct.ResetProfilesEvent.html)"]
    pub struct ResetProfilesEvent;
    impl ::serde::Serialize for ResetProfilesEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ResetProfilesEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ResetProfilesEvent)
        }
    }
    impl ::CdpEvent for ResetProfilesEvent {
        const EVENT_NAME: &'static str = "HeapProfiler.resetProfiles";
    }
    impl ::SerializeCdpEvent for ResetProfilesEvent {
        fn event_name(&self) -> &str {
            "HeapProfiler.resetProfiles"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ResetProfilesEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "HeapProfiler.resetProfiles" {
                Ok(
                    <ResetProfilesEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Heap snapshot object id."]
    pub type HeapSnapshotObjectId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes."]
    pub struct SamplingHeapProfileNode<'a> {
        #[serde(rename = "callFrame")]
        #[doc = "Function location."]
        pub call_frame: ::runtime::CallFrame<'a>,
        #[serde(rename = "selfSize")]
        #[doc = "Allocations size in bytes for the node excluding children."]
        pub self_size: f64,
        #[serde(rename = "children")]
        #[doc = "Child nodes."]
        pub children: Vec<Box<::heap_profiler::SamplingHeapProfileNode<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Profile."]
    pub struct SamplingHeapProfile<'a> {
        #[serde(rename = "head")]
        pub head: ::heap_profiler::SamplingHeapProfileNode<'a>,
    }
}
#[doc = "# Profiler\n\n## Commands\n\n- [`Profiler.disable`](struct.DisableCommand.html)\n- [`Profiler.enable`](struct.EnableCommand.html)\n- [`Profiler.getBestEffortCoverage`](struct.GetBestEffortCoverageCommand.html)\n\n  Collect coverage data for the current isolate. The coverage data may be incomplete due to\n  garbage collection.\n- [`Profiler.setSamplingInterval`](struct.SetSamplingIntervalCommand.html)\n\n  Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n- [`Profiler.start`](struct.StartCommand.html)\n- [`Profiler.startPreciseCoverage`](struct.StartPreciseCoverageCommand.html)\n\n  Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code\n  coverage may be incomplete. Enabling prevents running optimized code and resets execution\n  counters.\n- [`Profiler.startTypeProfile`](struct.StartTypeProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Enable type profile.\n- [`Profiler.stop`](struct.StopCommand.html)\n- [`Profiler.stopPreciseCoverage`](struct.StopPreciseCoverageCommand.html)\n\n  Disable precise code coverage. Disabling releases unnecessary execution count records and allows\n  executing optimized code.\n- [`Profiler.stopTypeProfile`](struct.StopTypeProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Disable type profile. Disabling releases type profile data collected so far.\n- [`Profiler.takePreciseCoverage`](struct.TakePreciseCoverageCommand.html)\n\n  Collect coverage data for the current isolate, and resets execution counters. Precise code\n  coverage needs to have started.\n- [`Profiler.takeTypeProfile`](struct.TakeTypeProfileCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Collect type profile.\n\n## Events\n\n- [`Profiler.consoleProfileFinished`](struct.ConsoleProfileFinishedEvent.html)\n- [`Profiler.consoleProfileStarted`](struct.ConsoleProfileStartedEvent.html)\n\n  Sent when new profile recording is started using console.profile\\(\\) call.\n\n##Types\n\n- [`ProfileNode`](struct.ProfileNode.html)\n\n  Profile node. Holds callsite information, execution statistics and child nodes.\n- [`Profile`](struct.Profile.html)\n\n  Profile.\n- [`PositionTickInfo`](struct.PositionTickInfo.html)\n\n  Specifies a number of samples attributed to a certain source position.\n- [`CoverageRange`](struct.CoverageRange.html)\n\n  Coverage data for a source range.\n- [`FunctionCoverage`](struct.FunctionCoverage.html)\n\n  Coverage data for a JavaScript function.\n- [`ScriptCoverage`](struct.ScriptCoverage.html)\n\n  Coverage data for a JavaScript script.\n- [`TypeObject`](struct.TypeObject.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Describes a type collected during runtime.\n- [`TypeProfileEntry`](struct.TypeProfileEntry.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Source offset and types for a parameter or return value.\n- [`ScriptTypeProfile`](struct.ScriptTypeProfile.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Type profile data collected during runtime for a JavaScript script.\n"]
pub mod profiler {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.disable`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Profiler.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Profiler.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.disable`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::profiler::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Profiler.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.enable`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Profiler.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Profiler.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.enable`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::profiler::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Profiler.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Collect coverage data for the current isolate. The coverage data may be incomplete due to\ngarbage collection.\n\n# Command `Profiler.getBestEffortCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::GetBestEffortCoverageCommand`](struct.GetBestEffortCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::GetBestEffortCoverageResponse`](struct.GetBestEffortCoverageResponse.html)"]
    pub struct GetBestEffortCoverageCommand;
    impl ::serde::Serialize for GetBestEffortCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetBestEffortCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetBestEffortCoverageCommand)
        }
    }
    impl ::CdpCommand for GetBestEffortCoverageCommand {
        const COMMAND_NAME: &'static str = "Profiler.getBestEffortCoverage";
    }
    impl ::SerializeCdpCommand for GetBestEffortCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.getBestEffortCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetBestEffortCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.getBestEffortCoverage" {
                Ok ( < GetBestEffortCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Collect coverage data for the current isolate. The coverage data may be incomplete due to\ngarbage collection.\n\n# Command `Profiler.getBestEffortCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::GetBestEffortCoverageCommand`](struct.GetBestEffortCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::GetBestEffortCoverageResponse`](struct.GetBestEffortCoverageResponse.html)"]
    pub struct GetBestEffortCoverageResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Coverage data for the current isolate."]
        pub result: Vec<::profiler::ScriptCoverage<'a>>,
    }
    impl<'a> ::CdpCommand for GetBestEffortCoverageResponse<'a> {
        const COMMAND_NAME: &'static str = "Profiler.getBestEffortCoverage";
    }
    impl<'b> ::HasCdpResponse<'b> for GetBestEffortCoverageCommand {
        type Response = GetBestEffortCoverageResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetBestEffortCoverageResponse<'b> {
        type Command = GetBestEffortCoverageCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n\n# Command `Profiler.setSamplingInterval`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::SetSamplingIntervalCommand`](struct.SetSamplingIntervalCommand.html)  \n*Response Struct:* [`cdp::profiler::SetSamplingIntervalResponse`](struct.SetSamplingIntervalResponse.html)"]
    pub struct SetSamplingIntervalCommand {
        #[serde(rename = "interval")]
        #[doc = "New sampling interval in microseconds."]
        pub interval: i32,
    }
    impl ::CdpCommand for SetSamplingIntervalCommand {
        const COMMAND_NAME: &'static str = "Profiler.setSamplingInterval";
    }
    impl ::SerializeCdpCommand for SetSamplingIntervalCommand {
        fn command_name(&self) -> &str {
            "Profiler.setSamplingInterval"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetSamplingIntervalCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.setSamplingInterval" {
                Ok ( < SetSamplingIntervalCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.\n\n# Command `Profiler.setSamplingInterval`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::SetSamplingIntervalCommand`](struct.SetSamplingIntervalCommand.html)  \n*Response Struct:* [`cdp::profiler::SetSamplingIntervalResponse`](struct.SetSamplingIntervalResponse.html)"]
    pub struct SetSamplingIntervalResponse;
    impl ::serde::Serialize for SetSamplingIntervalResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetSamplingIntervalResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetSamplingIntervalResponse)
        }
    }
    impl ::CdpCommand for SetSamplingIntervalResponse {
        const COMMAND_NAME: &'static str = "Profiler.setSamplingInterval";
    }
    impl<'b> ::HasCdpResponse<'b> for SetSamplingIntervalCommand {
        type Response = SetSamplingIntervalResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetSamplingIntervalResponse {
        type Command = SetSamplingIntervalCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.start`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::profiler::StartResponse`](struct.StartResponse.html)"]
    pub struct StartCommand;
    impl ::serde::Serialize for StartCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| StartCommand)
        }
    }
    impl ::CdpCommand for StartCommand {
        const COMMAND_NAME: &'static str = "Profiler.start";
    }
    impl ::SerializeCdpCommand for StartCommand {
        fn command_name(&self) -> &str {
            "Profiler.start"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.start" {
                Ok(
                    <StartCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.start`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartCommand`](struct.StartCommand.html)  \n*Response Struct:* [`cdp::profiler::StartResponse`](struct.StartResponse.html)"]
    pub struct StartResponse;
    impl ::serde::Serialize for StartResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| StartResponse)
        }
    }
    impl ::CdpCommand for StartResponse {
        const COMMAND_NAME: &'static str = "Profiler.start";
    }
    impl<'b> ::HasCdpResponse<'b> for StartCommand {
        type Response = StartResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartResponse {
        type Command = StartCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code\ncoverage may be incomplete. Enabling prevents running optimized code and resets execution\ncounters.\n\n# Command `Profiler.startPreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartPreciseCoverageCommand`](struct.StartPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::StartPreciseCoverageResponse`](struct.StartPreciseCoverageResponse.html)"]
    pub struct StartPreciseCoverageCommand {
        #[serde(rename = "callCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Collect accurate call counts beyond simple 'covered' or 'not covered'."]
        pub call_count: Option<bool>,
        #[serde(rename = "detailed", skip_serializing_if = "Option::is_none")]
        #[doc = "Collect block-based coverage."]
        pub detailed: Option<bool>,
    }
    impl ::CdpCommand for StartPreciseCoverageCommand {
        const COMMAND_NAME: &'static str = "Profiler.startPreciseCoverage";
    }
    impl ::SerializeCdpCommand for StartPreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.startPreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartPreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.startPreciseCoverage" {
                Ok ( < StartPreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code\ncoverage may be incomplete. Enabling prevents running optimized code and resets execution\ncounters.\n\n# Command `Profiler.startPreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartPreciseCoverageCommand`](struct.StartPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::StartPreciseCoverageResponse`](struct.StartPreciseCoverageResponse.html)"]
    pub struct StartPreciseCoverageResponse;
    impl ::serde::Serialize for StartPreciseCoverageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartPreciseCoverageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartPreciseCoverageResponse)
        }
    }
    impl ::CdpCommand for StartPreciseCoverageResponse {
        const COMMAND_NAME: &'static str = "Profiler.startPreciseCoverage";
    }
    impl<'b> ::HasCdpResponse<'b> for StartPreciseCoverageCommand {
        type Response = StartPreciseCoverageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartPreciseCoverageResponse {
        type Command = StartPreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable type profile.\n\n# Command `Profiler.startTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartTypeProfileCommand`](struct.StartTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::StartTypeProfileResponse`](struct.StartTypeProfileResponse.html)"]
    pub struct StartTypeProfileCommand;
    impl ::serde::Serialize for StartTypeProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartTypeProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartTypeProfileCommand)
        }
    }
    impl ::CdpCommand for StartTypeProfileCommand {
        const COMMAND_NAME: &'static str = "Profiler.startTypeProfile";
    }
    impl ::SerializeCdpCommand for StartTypeProfileCommand {
        fn command_name(&self) -> &str {
            "Profiler.startTypeProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StartTypeProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.startTypeProfile" {
                Ok ( < StartTypeProfileCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Enable type profile.\n\n# Command `Profiler.startTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StartTypeProfileCommand`](struct.StartTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::StartTypeProfileResponse`](struct.StartTypeProfileResponse.html)"]
    pub struct StartTypeProfileResponse;
    impl ::serde::Serialize for StartTypeProfileResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StartTypeProfileResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StartTypeProfileResponse)
        }
    }
    impl ::CdpCommand for StartTypeProfileResponse {
        const COMMAND_NAME: &'static str = "Profiler.startTypeProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for StartTypeProfileCommand {
        type Response = StartTypeProfileResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StartTypeProfileResponse {
        type Command = StartTypeProfileCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.stop`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopCommand`](struct.StopCommand.html)  \n*Response Struct:* [`cdp::profiler::StopResponse`](struct.StopResponse.html)"]
    pub struct StopCommand;
    impl ::serde::Serialize for StopCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| StopCommand)
        }
    }
    impl ::CdpCommand for StopCommand {
        const COMMAND_NAME: &'static str = "Profiler.stop";
    }
    impl ::SerializeCdpCommand for StopCommand {
        fn command_name(&self) -> &str {
            "Profiler.stop"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.stop" {
                Ok(
                    <StopCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Command `Profiler.stop`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopCommand`](struct.StopCommand.html)  \n*Response Struct:* [`cdp::profiler::StopResponse`](struct.StopResponse.html)"]
    pub struct StopResponse<'a> {
        #[serde(rename = "profile")]
        #[doc = "Recorded profile."]
        pub profile: ::profiler::Profile<'a>,
    }
    impl<'a> ::CdpCommand for StopResponse<'a> {
        const COMMAND_NAME: &'static str = "Profiler.stop";
    }
    impl<'b> ::HasCdpResponse<'b> for StopCommand {
        type Response = StopResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for StopResponse<'b> {
        type Command = StopCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disable precise code coverage. Disabling releases unnecessary execution count records and allows\nexecuting optimized code.\n\n# Command `Profiler.stopPreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopPreciseCoverageCommand`](struct.StopPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::StopPreciseCoverageResponse`](struct.StopPreciseCoverageResponse.html)"]
    pub struct StopPreciseCoverageCommand;
    impl ::serde::Serialize for StopPreciseCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopPreciseCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopPreciseCoverageCommand)
        }
    }
    impl ::CdpCommand for StopPreciseCoverageCommand {
        const COMMAND_NAME: &'static str = "Profiler.stopPreciseCoverage";
    }
    impl ::SerializeCdpCommand for StopPreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.stopPreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopPreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.stopPreciseCoverage" {
                Ok ( < StopPreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disable precise code coverage. Disabling releases unnecessary execution count records and allows\nexecuting optimized code.\n\n# Command `Profiler.stopPreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopPreciseCoverageCommand`](struct.StopPreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::StopPreciseCoverageResponse`](struct.StopPreciseCoverageResponse.html)"]
    pub struct StopPreciseCoverageResponse;
    impl ::serde::Serialize for StopPreciseCoverageResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopPreciseCoverageResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopPreciseCoverageResponse)
        }
    }
    impl ::CdpCommand for StopPreciseCoverageResponse {
        const COMMAND_NAME: &'static str = "Profiler.stopPreciseCoverage";
    }
    impl<'b> ::HasCdpResponse<'b> for StopPreciseCoverageCommand {
        type Response = StopPreciseCoverageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopPreciseCoverageResponse {
        type Command = StopPreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disable type profile. Disabling releases type profile data collected so far.\n\n# Command `Profiler.stopTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopTypeProfileCommand`](struct.StopTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::StopTypeProfileResponse`](struct.StopTypeProfileResponse.html)"]
    pub struct StopTypeProfileCommand;
    impl ::serde::Serialize for StopTypeProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopTypeProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopTypeProfileCommand)
        }
    }
    impl ::CdpCommand for StopTypeProfileCommand {
        const COMMAND_NAME: &'static str = "Profiler.stopTypeProfile";
    }
    impl ::SerializeCdpCommand for StopTypeProfileCommand {
        fn command_name(&self) -> &str {
            "Profiler.stopTypeProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for StopTypeProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.stopTypeProfile" {
                Ok(
                    <StopTypeProfileCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Disable type profile. Disabling releases type profile data collected so far.\n\n# Command `Profiler.stopTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::StopTypeProfileCommand`](struct.StopTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::StopTypeProfileResponse`](struct.StopTypeProfileResponse.html)"]
    pub struct StopTypeProfileResponse;
    impl ::serde::Serialize for StopTypeProfileResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for StopTypeProfileResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| StopTypeProfileResponse)
        }
    }
    impl ::CdpCommand for StopTypeProfileResponse {
        const COMMAND_NAME: &'static str = "Profiler.stopTypeProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for StopTypeProfileCommand {
        type Response = StopTypeProfileResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for StopTypeProfileResponse {
        type Command = StopTypeProfileCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Collect coverage data for the current isolate, and resets execution counters. Precise code\ncoverage needs to have started.\n\n# Command `Profiler.takePreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::TakePreciseCoverageCommand`](struct.TakePreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::TakePreciseCoverageResponse`](struct.TakePreciseCoverageResponse.html)"]
    pub struct TakePreciseCoverageCommand;
    impl ::serde::Serialize for TakePreciseCoverageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakePreciseCoverageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakePreciseCoverageCommand)
        }
    }
    impl ::CdpCommand for TakePreciseCoverageCommand {
        const COMMAND_NAME: &'static str = "Profiler.takePreciseCoverage";
    }
    impl ::SerializeCdpCommand for TakePreciseCoverageCommand {
        fn command_name(&self) -> &str {
            "Profiler.takePreciseCoverage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for TakePreciseCoverageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.takePreciseCoverage" {
                Ok ( < TakePreciseCoverageCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Collect coverage data for the current isolate, and resets execution counters. Precise code\ncoverage needs to have started.\n\n# Command `Profiler.takePreciseCoverage`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::TakePreciseCoverageCommand`](struct.TakePreciseCoverageCommand.html)  \n*Response Struct:* [`cdp::profiler::TakePreciseCoverageResponse`](struct.TakePreciseCoverageResponse.html)"]
    pub struct TakePreciseCoverageResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Coverage data for the current isolate."]
        pub result: Vec<::profiler::ScriptCoverage<'a>>,
    }
    impl<'a> ::CdpCommand for TakePreciseCoverageResponse<'a> {
        const COMMAND_NAME: &'static str = "Profiler.takePreciseCoverage";
    }
    impl<'b> ::HasCdpResponse<'b> for TakePreciseCoverageCommand {
        type Response = TakePreciseCoverageResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for TakePreciseCoverageResponse<'b> {
        type Command = TakePreciseCoverageCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect type profile.\n\n# Command `Profiler.takeTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::TakeTypeProfileCommand`](struct.TakeTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::TakeTypeProfileResponse`](struct.TakeTypeProfileResponse.html)"]
    pub struct TakeTypeProfileCommand;
    impl ::serde::Serialize for TakeTypeProfileCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TakeTypeProfileCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TakeTypeProfileCommand)
        }
    }
    impl ::CdpCommand for TakeTypeProfileCommand {
        const COMMAND_NAME: &'static str = "Profiler.takeTypeProfile";
    }
    impl ::SerializeCdpCommand for TakeTypeProfileCommand {
        fn command_name(&self) -> &str {
            "Profiler.takeTypeProfile"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for TakeTypeProfileCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.takeTypeProfile" {
                Ok(
                    <TakeTypeProfileCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Collect type profile.\n\n# Command `Profiler.takeTypeProfile`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Command Struct:* [`cdp::profiler::TakeTypeProfileCommand`](struct.TakeTypeProfileCommand.html)  \n*Response Struct:* [`cdp::profiler::TakeTypeProfileResponse`](struct.TakeTypeProfileResponse.html)"]
    pub struct TakeTypeProfileResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Type profile for all scripts since startTypeProfile\\(\\) was turned on."]
        pub result: Vec<::profiler::ScriptTypeProfile<'a>>,
    }
    impl<'a> ::CdpCommand for TakeTypeProfileResponse<'a> {
        const COMMAND_NAME: &'static str = "Profiler.takeTypeProfile";
    }
    impl<'b> ::HasCdpResponse<'b> for TakeTypeProfileCommand {
        type Response = TakeTypeProfileResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for TakeTypeProfileResponse<'b> {
        type Command = TakeTypeProfileCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Event `Profiler.consoleProfileFinished`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Event Struct:* [`cdp::profiler::ConsoleProfileFinishedEvent`](struct.ConsoleProfileFinishedEvent.html)"]
    pub struct ConsoleProfileFinishedEvent<'a> {
        #[serde(rename = "id")]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Location of console.profileEnd\\(\\)."]
        pub location: ::debugger::Location<'a>,
        #[serde(rename = "profile")]
        pub profile: ::profiler::Profile<'a>,
        #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
        #[doc = "Profile title passed as an argument to console.profile\\(\\)."]
        pub title: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpEvent for ConsoleProfileFinishedEvent<'a> {
        const EVENT_NAME: &'static str = "Profiler.consoleProfileFinished";
    }
    impl<'a> ::SerializeCdpEvent for ConsoleProfileFinishedEvent<'a> {
        fn event_name(&self) -> &str {
            "Profiler.consoleProfileFinished"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ConsoleProfileFinishedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.consoleProfileFinished" {
                Ok ( < ConsoleProfileFinishedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Sent when new profile recording is started using console.profile\\(\\) call.\n\n# Event `Profiler.consoleProfileStarted`\n\n*Domain Module:* [`cdp::profiler`](index.html)  \n*Event Struct:* [`cdp::profiler::ConsoleProfileStartedEvent`](struct.ConsoleProfileStartedEvent.html)"]
    pub struct ConsoleProfileStartedEvent<'a> {
        #[serde(rename = "id")]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "location")]
        #[doc = "Location of console.profile\\(\\)."]
        pub location: ::debugger::Location<'a>,
        #[serde(rename = "title", skip_serializing_if = "Option::is_none")]
        #[doc = "Profile title passed as an argument to console.profile\\(\\)."]
        pub title: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpEvent for ConsoleProfileStartedEvent<'a> {
        const EVENT_NAME: &'static str = "Profiler.consoleProfileStarted";
    }
    impl<'a> ::SerializeCdpEvent for ConsoleProfileStartedEvent<'a> {
        fn event_name(&self) -> &str {
            "Profiler.consoleProfileStarted"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ConsoleProfileStartedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Profiler.consoleProfileStarted" {
                Ok ( < ConsoleProfileStartedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Profile node. Holds callsite information, execution statistics and child nodes."]
    pub struct ProfileNode<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the node."]
        pub id: i32,
        #[serde(rename = "callFrame")]
        #[doc = "Function location."]
        pub call_frame: ::runtime::CallFrame<'a>,
        #[serde(rename = "hitCount", skip_serializing_if = "Option::is_none")]
        #[doc = "Number of samples where this node was on top of the call stack."]
        pub hit_count: Option<i32>,
        #[serde(rename = "children", skip_serializing_if = "Option::is_none")]
        #[doc = "Child node ids."]
        pub children: Option<Vec<i32>>,
        #[serde(rename = "deoptReason", skip_serializing_if = "Option::is_none")]
        #[doc = "The reason of being not optimized. The function may be deoptimized or marked as don't\noptimize."]
        pub deopt_reason: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "positionTicks", skip_serializing_if = "Option::is_none")]
        #[doc = "An array of source position ticks."]
        pub position_ticks: Option<Vec<::profiler::PositionTickInfo>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Profile."]
    pub struct Profile<'a> {
        #[serde(rename = "nodes")]
        #[doc = "The list of profile nodes. First item is the root node."]
        pub nodes: Vec<::profiler::ProfileNode<'a>>,
        #[serde(rename = "startTime")]
        #[doc = "Profiling start timestamp in microseconds."]
        pub start_time: f64,
        #[serde(rename = "endTime")]
        #[doc = "Profiling end timestamp in microseconds."]
        pub end_time: f64,
        #[serde(rename = "samples", skip_serializing_if = "Option::is_none")]
        #[doc = "Ids of samples top nodes."]
        pub samples: Option<Vec<i32>>,
        #[serde(rename = "timeDeltas", skip_serializing_if = "Option::is_none")]
        #[doc = "Time intervals between adjacent samples in microseconds. The first delta is relative to the\nprofile startTime."]
        pub time_deltas: Option<Vec<i32>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Specifies a number of samples attributed to a certain source position."]
    pub struct PositionTickInfo {
        #[serde(rename = "line")]
        #[doc = "Source line number \\(1-based\\)."]
        pub line: i32,
        #[serde(rename = "ticks")]
        #[doc = "Number of samples attributed to the source line."]
        pub ticks: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Coverage data for a source range."]
    pub struct CoverageRange {
        #[serde(rename = "startOffset")]
        #[doc = "JavaScript script source offset for the range start."]
        pub start_offset: i32,
        #[serde(rename = "endOffset")]
        #[doc = "JavaScript script source offset for the range end."]
        pub end_offset: i32,
        #[serde(rename = "count")]
        #[doc = "Collected execution count of the source range."]
        pub count: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Coverage data for a JavaScript function."]
    pub struct FunctionCoverage<'a> {
        #[serde(rename = "functionName")]
        #[doc = "JavaScript function name."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "ranges")]
        #[doc = "Source ranges inside the function with coverage data."]
        pub ranges: Vec<::profiler::CoverageRange>,
        #[serde(rename = "isBlockCoverage")]
        #[doc = "Whether coverage data for this function has block granularity."]
        pub is_block_coverage: bool,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Coverage data for a JavaScript script."]
    pub struct ScriptCoverage<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "JavaScript script id."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "functions")]
        #[doc = "Functions contained in the script that has coverage data."]
        pub functions: Vec<::profiler::FunctionCoverage<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Describes a type collected during runtime."]
    pub struct TypeObject<'a> {
        #[serde(rename = "name")]
        #[doc = "Name of a type collected with type profiling."]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Source offset and types for a parameter or return value."]
    pub struct TypeProfileEntry<'a> {
        #[serde(rename = "offset")]
        #[doc = "Source offset of the parameter or end of function for return values."]
        pub offset: i32,
        #[serde(rename = "types")]
        #[doc = "The types for this parameter or return value."]
        pub types: Vec<::profiler::TypeObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Type profile data collected during runtime for a JavaScript script."]
    pub struct ScriptTypeProfile<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "JavaScript script id."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "entries")]
        #[doc = "Type profile entries for parameters and return values of the functions in the script."]
        pub entries: Vec<::profiler::TypeProfileEntry<'a>>,
    }
}
#[doc = "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.\nEvaluation results are returned as mirror object that expose object type, string representation\nand unique identifier that can be used for further object reference. Original objects are\nmaintained in memory unless they are either explicitly released or are released along with the\nother objects in their object group.\n\n# Runtime\n\n## Commands\n\n- [`Runtime.awaitPromise`](struct.AwaitPromiseCommand.html)\n\n  Add handler to promise with given promise object id.\n- [`Runtime.callFunctionOn`](struct.CallFunctionOnCommand.html)\n\n  Calls function with given declaration on the given object. Object group of the result is\n  inherited from the target object.\n- [`Runtime.compileScript`](struct.CompileScriptCommand.html)\n\n  Compiles expression.\n- [`Runtime.disable`](struct.DisableCommand.html)\n\n  Disables reporting of execution contexts creation.\n- [`Runtime.discardConsoleEntries`](struct.DiscardConsoleEntriesCommand.html)\n\n  Discards collected exceptions and console API calls.\n- [`Runtime.enable`](struct.EnableCommand.html)\n\n  Enables reporting of execution contexts creation by means of `executionContextCreated` event.\n  When the reporting gets enabled the event will be sent immediately for each existing execution\n  context.\n- [`Runtime.evaluate`](struct.EvaluateCommand.html)\n\n  Evaluates expression on global object.\n- [`Runtime.getIsolateId`](struct.GetIsolateIdCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the isolate id.\n- [`Runtime.getHeapUsage`](struct.GetHeapUsageCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Returns the JavaScript heap usage.\n  It is the total usage of the corresponding isolate not scoped to a particular Runtime.\n- [`Runtime.getProperties`](struct.GetPropertiesCommand.html)\n\n  Returns properties of a given object. Object group of the result is inherited from the target\n  object.\n- [`Runtime.globalLexicalScopeNames`](struct.GlobalLexicalScopeNamesCommand.html)\n\n  Returns all let, const and class variables from global scope.\n- [`Runtime.queryObjects`](struct.QueryObjectsCommand.html)\n- [`Runtime.releaseObject`](struct.ReleaseObjectCommand.html)\n\n  Releases remote object with given id.\n- [`Runtime.releaseObjectGroup`](struct.ReleaseObjectGroupCommand.html)\n\n  Releases all remote objects that belong to a given group.\n- [`Runtime.runIfWaitingForDebugger`](struct.RunIfWaitingForDebuggerCommand.html)\n\n  Tells inspected instance to run if it was waiting for debugger to attach.\n- [`Runtime.runScript`](struct.RunScriptCommand.html)\n\n  Runs script with given id in a given context.\n- [`Runtime.setAsyncCallStackDepth`](struct.SetAsyncCallStackDepthCommand.html)\n\n  Enables or disables async call stacks tracking.\n- [`Runtime.setCustomObjectFormatterEnabled`](struct.SetCustomObjectFormatterEnabledCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Runtime.setMaxCallStackSizeToCapture`](struct.SetMaxCallStackSizeToCaptureCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`Runtime.terminateExecution`](struct.TerminateExecutionCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Terminate current or next JavaScript execution.\n  Will cancel the termination when the outer-most script execution ends.\n- [`Runtime.addBinding`](struct.AddBindingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If executionContextId is empty, adds binding with the given name on the\n  global objects of all inspected contexts, including those created later,\n  bindings survive reloads.\n  If executionContextId is specified, adds binding only on global object of\n  given execution context.\n  Binding function takes exactly one argument, this argument should be string,\n  in case of any other input, function throws an exception.\n  Each binding function call produces Runtime.bindingCalled notification.\n- [`Runtime.removeBinding`](struct.RemoveBindingCommand.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  This method does not remove binding function from global object but\n  unsubscribes current runtime agent from Runtime.bindingCalled notifications.\n\n## Events\n\n- [`Runtime.bindingCalled`](struct.BindingCalledEvent.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Notification is issued every time when binding is called.\n- [`Runtime.consoleAPICalled`](struct.ConsoleApiCalledEvent.html)\n\n  Issued when console API was called.\n- [`Runtime.exceptionRevoked`](struct.ExceptionRevokedEvent.html)\n\n  Issued when unhandled exception was revoked.\n- [`Runtime.exceptionThrown`](struct.ExceptionThrownEvent.html)\n\n  Issued when exception was thrown and unhandled.\n- [`Runtime.executionContextCreated`](struct.ExecutionContextCreatedEvent.html)\n\n  Issued when new execution context is created.\n- [`Runtime.executionContextDestroyed`](struct.ExecutionContextDestroyedEvent.html)\n\n  Issued when execution context is destroyed.\n- [`Runtime.executionContextsCleared`](struct.ExecutionContextsClearedEvent.html)\n\n  Issued when all executionContexts were cleared in browser\n- [`Runtime.inspectRequested`](struct.InspectRequestedEvent.html)\n\n  Issued when object should be inspected \\(for example, as a result of inspect\\(\\) command line API\n  call\\).\n\n##Types\n\n- [`ScriptId`](type.ScriptId.html)\n\n  Unique script identifier.\n- [`RemoteObjectId`](type.RemoteObjectId.html)\n\n  Unique object identifier.\n- [`UnserializableValue`](type.UnserializableValue.html)\n\n  Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,\n  `-Infinity`, and bigint literals.\n- [`RemoteObject`](struct.RemoteObject.html)\n\n  Mirror object referencing original JavaScript object.\n- [`CustomPreview`](struct.CustomPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`ObjectPreview`](struct.ObjectPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Object containing abbreviated remote object value.\n- [`PropertyPreview`](struct.PropertyPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`EntryPreview`](struct.EntryPreview.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n- [`PropertyDescriptor`](struct.PropertyDescriptor.html)\n\n  Object property descriptor.\n- [`InternalPropertyDescriptor`](struct.InternalPropertyDescriptor.html)\n\n  Object internal property descriptor. This property isn't normally visible in JavaScript code.\n- [`CallArgument`](struct.CallArgument.html)\n\n  Represents function call argument. Either remote object id `objectId`, primitive `value`,\n  unserializable primitive value or neither of \\(for undefined\\) them should be specified.\n- [`ExecutionContextId`](type.ExecutionContextId.html)\n\n  Id of an execution context.\n- [`ExecutionContextDescription`](struct.ExecutionContextDescription.html)\n\n  Description of an isolated world.\n- [`ExceptionDetails`](struct.ExceptionDetails.html)\n\n  Detailed information about exception \\(or error\\) that was thrown during script compilation or\n  execution.\n- [`Timestamp`](type.Timestamp.html)\n\n  Number of milliseconds since epoch.\n- [`TimeDelta`](type.TimeDelta.html)\n\n  Number of milliseconds.\n- [`CallFrame`](struct.CallFrame.html)\n\n  Stack entry for runtime errors and assertions.\n- [`StackTrace`](struct.StackTrace.html)\n\n  Call frames for assertions or error messages.\n- [`UniqueDebuggerId`](type.UniqueDebuggerId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  Unique identifier of current debugger.\n- [`StackTraceId`](struct.StackTraceId.html) <span class=\"stab unstable\" style=\"display: inline-block\">Experimental</span>\n\n  If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This\n  allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.\n"]
pub mod runtime {
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Add handler to promise with given promise object id.\n\n# Command `Runtime.awaitPromise`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::AwaitPromiseCommand`](struct.AwaitPromiseCommand.html)  \n*Response Struct:* [`cdp::runtime::AwaitPromiseResponse`](struct.AwaitPromiseResponse.html)"]
    pub struct AwaitPromiseCommand<'a> {
        #[serde(rename = "promiseObjectId")]
        #[doc = "Identifier of the promise."]
        pub promise_object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
    }
    impl<'a> ::CdpCommand for AwaitPromiseCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.awaitPromise";
    }
    impl<'a> ::SerializeCdpCommand for AwaitPromiseCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.awaitPromise"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AwaitPromiseCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.awaitPromise" {
                Ok(
                    <AwaitPromiseCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Add handler to promise with given promise object id.\n\n# Command `Runtime.awaitPromise`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::AwaitPromiseCommand`](struct.AwaitPromiseCommand.html)  \n*Response Struct:* [`cdp::runtime::AwaitPromiseResponse`](struct.AwaitPromiseResponse.html)"]
    pub struct AwaitPromiseResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Promise result. Will contain rejected value if promise was rejected."]
        pub result: ::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details if stack strace is available."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for AwaitPromiseResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.awaitPromise";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AwaitPromiseCommand<'a> {
        type Response = AwaitPromiseResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for AwaitPromiseResponse<'b> {
        type Command = AwaitPromiseCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Calls function with given declaration on the given object. Object group of the result is\ninherited from the target object.\n\n# Command `Runtime.callFunctionOn`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::CallFunctionOnCommand`](struct.CallFunctionOnCommand.html)  \n*Response Struct:* [`cdp::runtime::CallFunctionOnResponse`](struct.CallFunctionOnResponse.html)"]
    pub struct CallFunctionOnCommand<'a> {
        #[serde(rename = "functionDeclaration")]
        #[doc = "Declaration of the function to call."]
        pub function_declaration: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the object to call function on. Either objectId or executionContextId should\nbe specified."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
        #[serde(rename = "arguments", skip_serializing_if = "Option::is_none")]
        #[doc = "Call arguments. All call arguments must belong to the same JavaScript world as the target\nobject."]
        pub arguments: Option<Vec<::runtime::CallArgument<'a>>>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
        pub silent: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "userGesture", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should be treated as initiated by user in the UI."]
        pub user_gesture: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
        pub await_promise: Option<bool>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies execution context which global object will be used to call function on. Either\nexecutionContextId or objectId should be specified."]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects. If objectGroup is not\nspecified and objectId is, objectGroup will be inherited from object."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for CallFunctionOnCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.callFunctionOn";
    }
    impl<'a> ::SerializeCdpCommand for CallFunctionOnCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.callFunctionOn"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CallFunctionOnCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.callFunctionOn" {
                Ok(
                    <CallFunctionOnCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Calls function with given declaration on the given object. Object group of the result is\ninherited from the target object.\n\n# Command `Runtime.callFunctionOn`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::CallFunctionOnCommand`](struct.CallFunctionOnCommand.html)  \n*Response Struct:* [`cdp::runtime::CallFunctionOnResponse`](struct.CallFunctionOnResponse.html)"]
    pub struct CallFunctionOnResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Call result."]
        pub result: ::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for CallFunctionOnResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.callFunctionOn";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CallFunctionOnCommand<'a> {
        type Response = CallFunctionOnResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CallFunctionOnResponse<'b> {
        type Command = CallFunctionOnCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Compiles expression.\n\n# Command `Runtime.compileScript`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::CompileScriptCommand`](struct.CompileScriptCommand.html)  \n*Response Struct:* [`cdp::runtime::CompileScriptResponse`](struct.CompileScriptResponse.html)"]
    pub struct CompileScriptCommand<'a> {
        #[serde(rename = "expression")]
        #[doc = "Expression to compile."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "sourceURL")]
        #[doc = "Source url to be set for the script."]
        pub source_url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "persistScript")]
        #[doc = "Specifies whether the compiled script should be persisted."]
        pub persist_script: bool,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page."]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
    }
    impl<'a> ::CdpCommand for CompileScriptCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.compileScript";
    }
    impl<'a> ::SerializeCdpCommand for CompileScriptCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.compileScript"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for CompileScriptCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.compileScript" {
                Ok(
                    <CompileScriptCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Compiles expression.\n\n# Command `Runtime.compileScript`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::CompileScriptCommand`](struct.CompileScriptCommand.html)  \n*Response Struct:* [`cdp::runtime::CompileScriptResponse`](struct.CompileScriptResponse.html)"]
    pub struct CompileScriptResponse<'a> {
        #[serde(rename = "scriptId", skip_serializing_if = "Option::is_none")]
        #[doc = "Id of the script."]
        pub script_id: Option<::runtime::ScriptId<'a>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for CompileScriptResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.compileScript";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for CompileScriptCommand<'a> {
        type Response = CompileScriptResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for CompileScriptResponse<'b> {
        type Command = CompileScriptCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables reporting of execution contexts creation.\n\n# Command `Runtime.disable`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::runtime::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableCommand;
    impl ::serde::Serialize for DisableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableCommand)
        }
    }
    impl ::CdpCommand for DisableCommand {
        const COMMAND_NAME: &'static str = "Runtime.disable";
    }
    impl ::SerializeCdpCommand for DisableCommand {
        fn command_name(&self) -> &str {
            "Runtime.disable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DisableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.disable" {
                Ok(
                    <DisableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Disables reporting of execution contexts creation.\n\n# Command `Runtime.disable`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::DisableCommand`](struct.DisableCommand.html)  \n*Response Struct:* [`cdp::runtime::DisableResponse`](struct.DisableResponse.html)"]
    pub struct DisableResponse;
    impl ::serde::Serialize for DisableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DisableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DisableResponse)
        }
    }
    impl ::CdpCommand for DisableResponse {
        const COMMAND_NAME: &'static str = "Runtime.disable";
    }
    impl<'b> ::HasCdpResponse<'b> for DisableCommand {
        type Response = DisableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DisableResponse {
        type Command = DisableCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Discards collected exceptions and console API calls.\n\n# Command `Runtime.discardConsoleEntries`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::DiscardConsoleEntriesCommand`](struct.DiscardConsoleEntriesCommand.html)  \n*Response Struct:* [`cdp::runtime::DiscardConsoleEntriesResponse`](struct.DiscardConsoleEntriesResponse.html)"]
    pub struct DiscardConsoleEntriesCommand;
    impl ::serde::Serialize for DiscardConsoleEntriesCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardConsoleEntriesCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardConsoleEntriesCommand)
        }
    }
    impl ::CdpCommand for DiscardConsoleEntriesCommand {
        const COMMAND_NAME: &'static str = "Runtime.discardConsoleEntries";
    }
    impl ::SerializeCdpCommand for DiscardConsoleEntriesCommand {
        fn command_name(&self) -> &str {
            "Runtime.discardConsoleEntries"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for DiscardConsoleEntriesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.discardConsoleEntries" {
                Ok ( < DiscardConsoleEntriesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Discards collected exceptions and console API calls.\n\n# Command `Runtime.discardConsoleEntries`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::DiscardConsoleEntriesCommand`](struct.DiscardConsoleEntriesCommand.html)  \n*Response Struct:* [`cdp::runtime::DiscardConsoleEntriesResponse`](struct.DiscardConsoleEntriesResponse.html)"]
    pub struct DiscardConsoleEntriesResponse;
    impl ::serde::Serialize for DiscardConsoleEntriesResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for DiscardConsoleEntriesResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| DiscardConsoleEntriesResponse)
        }
    }
    impl ::CdpCommand for DiscardConsoleEntriesResponse {
        const COMMAND_NAME: &'static str = "Runtime.discardConsoleEntries";
    }
    impl<'b> ::HasCdpResponse<'b> for DiscardConsoleEntriesCommand {
        type Response = DiscardConsoleEntriesResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for DiscardConsoleEntriesResponse {
        type Command = DiscardConsoleEntriesCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables reporting of execution contexts creation by means of `executionContextCreated` event.\nWhen the reporting gets enabled the event will be sent immediately for each existing execution\ncontext.\n\n# Command `Runtime.enable`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::runtime::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableCommand;
    impl ::serde::Serialize for EnableCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer).map(|_| EnableCommand)
        }
    }
    impl ::CdpCommand for EnableCommand {
        const COMMAND_NAME: &'static str = "Runtime.enable";
    }
    impl ::SerializeCdpCommand for EnableCommand {
        fn command_name(&self) -> &str {
            "Runtime.enable"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for EnableCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.enable" {
                Ok(
                    <EnableCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables reporting of execution contexts creation by means of `executionContextCreated` event.\nWhen the reporting gets enabled the event will be sent immediately for each existing execution\ncontext.\n\n# Command `Runtime.enable`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::EnableCommand`](struct.EnableCommand.html)  \n*Response Struct:* [`cdp::runtime::EnableResponse`](struct.EnableResponse.html)"]
    pub struct EnableResponse;
    impl ::serde::Serialize for EnableResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EnableResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| EnableResponse)
        }
    }
    impl ::CdpCommand for EnableResponse {
        const COMMAND_NAME: &'static str = "Runtime.enable";
    }
    impl<'b> ::HasCdpResponse<'b> for EnableCommand {
        type Response = EnableResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for EnableResponse {
        type Command = EnableCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on global object.\n\n# Command `Runtime.evaluate`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::EvaluateCommand`](struct.EvaluateCommand.html)  \n*Response Struct:* [`cdp::runtime::EvaluateResponse`](struct.EvaluateResponse.html)"]
    pub struct EvaluateCommand<'a> {
        #[serde(rename = "expression")]
        #[doc = "Expression to evaluate."]
        pub expression: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Determines whether Command Line API should be available during the evaluation."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
        pub silent: Option<bool>,
        #[serde(rename = "contextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform evaluation. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page."]
        pub context_id: Option<::runtime::ExecutionContextId>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object that should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "userGesture", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should be treated as initiated by user in the UI."]
        pub user_gesture: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
        pub await_promise: Option<bool>,
        #[serde(rename = "throwOnSideEffect", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether to throw an exception if side effect cannot be ruled out during evaluation."]
        pub throw_on_side_effect: Option<bool>,
        #[serde(rename = "timeout", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Terminate execution after timing out \\(number of milliseconds\\)."]
        pub timeout: Option<::runtime::TimeDelta>,
    }
    impl<'a> ::CdpCommand for EvaluateCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.evaluate";
    }
    impl<'a> ::SerializeCdpCommand for EvaluateCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.evaluate"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for EvaluateCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.evaluate" {
                Ok(
                    <EvaluateCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Evaluates expression on global object.\n\n# Command `Runtime.evaluate`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::EvaluateCommand`](struct.EvaluateCommand.html)  \n*Response Struct:* [`cdp::runtime::EvaluateResponse`](struct.EvaluateResponse.html)"]
    pub struct EvaluateResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Evaluation result."]
        pub result: ::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for EvaluateResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.evaluate";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for EvaluateCommand<'a> {
        type Response = EvaluateResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for EvaluateResponse<'b> {
        type Command = EvaluateCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the isolate id.\n\n# Command `Runtime.getIsolateId`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetIsolateIdCommand`](struct.GetIsolateIdCommand.html)  \n*Response Struct:* [`cdp::runtime::GetIsolateIdResponse`](struct.GetIsolateIdResponse.html)"]
    pub struct GetIsolateIdCommand;
    impl ::serde::Serialize for GetIsolateIdCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetIsolateIdCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetIsolateIdCommand)
        }
    }
    impl ::CdpCommand for GetIsolateIdCommand {
        const COMMAND_NAME: &'static str = "Runtime.getIsolateId";
    }
    impl ::SerializeCdpCommand for GetIsolateIdCommand {
        fn command_name(&self) -> &str {
            "Runtime.getIsolateId"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetIsolateIdCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.getIsolateId" {
                Ok(
                    <GetIsolateIdCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the isolate id.\n\n# Command `Runtime.getIsolateId`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetIsolateIdCommand`](struct.GetIsolateIdCommand.html)  \n*Response Struct:* [`cdp::runtime::GetIsolateIdResponse`](struct.GetIsolateIdResponse.html)"]
    pub struct GetIsolateIdResponse<'a> {
        #[serde(rename = "id")]
        #[doc = "The isolate id."]
        pub id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for GetIsolateIdResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.getIsolateId";
    }
    impl<'b> ::HasCdpResponse<'b> for GetIsolateIdCommand {
        type Response = GetIsolateIdResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetIsolateIdResponse<'b> {
        type Command = GetIsolateIdCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the JavaScript heap usage.\nIt is the total usage of the corresponding isolate not scoped to a particular Runtime.\n\n# Command `Runtime.getHeapUsage`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetHeapUsageCommand`](struct.GetHeapUsageCommand.html)  \n*Response Struct:* [`cdp::runtime::GetHeapUsageResponse`](struct.GetHeapUsageResponse.html)"]
    pub struct GetHeapUsageCommand;
    impl ::serde::Serialize for GetHeapUsageCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetHeapUsageCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetHeapUsageCommand)
        }
    }
    impl ::CdpCommand for GetHeapUsageCommand {
        const COMMAND_NAME: &'static str = "Runtime.getHeapUsage";
    }
    impl ::SerializeCdpCommand for GetHeapUsageCommand {
        fn command_name(&self) -> &str {
            "Runtime.getHeapUsage"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetHeapUsageCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.getHeapUsage" {
                Ok(
                    <GetHeapUsageCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Returns the JavaScript heap usage.\nIt is the total usage of the corresponding isolate not scoped to a particular Runtime.\n\n# Command `Runtime.getHeapUsage`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetHeapUsageCommand`](struct.GetHeapUsageCommand.html)  \n*Response Struct:* [`cdp::runtime::GetHeapUsageResponse`](struct.GetHeapUsageResponse.html)"]
    pub struct GetHeapUsageResponse {
        #[serde(rename = "usedSize")]
        #[doc = "Used heap size in bytes."]
        pub used_size: f64,
        #[serde(rename = "totalSize")]
        #[doc = "Allocated heap size in bytes."]
        pub total_size: f64,
    }
    impl ::CdpCommand for GetHeapUsageResponse {
        const COMMAND_NAME: &'static str = "Runtime.getHeapUsage";
    }
    impl<'b> ::HasCdpResponse<'b> for GetHeapUsageCommand {
        type Response = GetHeapUsageResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for GetHeapUsageResponse {
        type Command = GetHeapUsageCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns properties of a given object. Object group of the result is inherited from the target\nobject.\n\n# Command `Runtime.getProperties`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetPropertiesCommand`](struct.GetPropertiesCommand.html)  \n*Response Struct:* [`cdp::runtime::GetPropertiesResponse`](struct.GetPropertiesResponse.html)"]
    pub struct GetPropertiesCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to return properties for."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "ownProperties", skip_serializing_if = "Option::is_none")]
        #[doc = "If true, returns properties belonging only to the element itself, not to its prototype\nchain."]
        pub own_properties: Option<bool>,
        #[serde(rename = "accessorPropertiesOnly", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> If true, returns accessor properties \\(with getter/setter\\) only; internal properties are not\nreturned either."]
        pub accessor_properties_only: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Whether preview should be generated for the results."]
        pub generate_preview: Option<bool>,
    }
    impl<'a> ::CdpCommand for GetPropertiesCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.getProperties";
    }
    impl<'a> ::SerializeCdpCommand for GetPropertiesCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.getProperties"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for GetPropertiesCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.getProperties" {
                Ok(
                    <GetPropertiesCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns properties of a given object. Object group of the result is inherited from the target\nobject.\n\n# Command `Runtime.getProperties`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GetPropertiesCommand`](struct.GetPropertiesCommand.html)  \n*Response Struct:* [`cdp::runtime::GetPropertiesResponse`](struct.GetPropertiesResponse.html)"]
    pub struct GetPropertiesResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Object properties."]
        pub result: Vec<::runtime::PropertyDescriptor<'a>>,
        #[serde(rename = "internalProperties", skip_serializing_if = "Option::is_none")]
        #[doc = "Internal object properties \\(only of the element itself\\)."]
        pub internal_properties: Option<Vec<::runtime::InternalPropertyDescriptor<'a>>>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for GetPropertiesResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.getProperties";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for GetPropertiesCommand<'a> {
        type Response = GetPropertiesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetPropertiesResponse<'b> {
        type Command = GetPropertiesCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns all let, const and class variables from global scope.\n\n# Command `Runtime.globalLexicalScopeNames`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GlobalLexicalScopeNamesCommand`](struct.GlobalLexicalScopeNamesCommand.html)  \n*Response Struct:* [`cdp::runtime::GlobalLexicalScopeNamesResponse`](struct.GlobalLexicalScopeNamesResponse.html)"]
    pub struct GlobalLexicalScopeNamesCommand {
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to lookup global scope variables."]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
    }
    impl ::CdpCommand for GlobalLexicalScopeNamesCommand {
        const COMMAND_NAME: &'static str = "Runtime.globalLexicalScopeNames";
    }
    impl ::SerializeCdpCommand for GlobalLexicalScopeNamesCommand {
        fn command_name(&self) -> &str {
            "Runtime.globalLexicalScopeNames"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GlobalLexicalScopeNamesCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.globalLexicalScopeNames" {
                Ok ( < GlobalLexicalScopeNamesCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns all let, const and class variables from global scope.\n\n# Command `Runtime.globalLexicalScopeNames`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::GlobalLexicalScopeNamesCommand`](struct.GlobalLexicalScopeNamesCommand.html)  \n*Response Struct:* [`cdp::runtime::GlobalLexicalScopeNamesResponse`](struct.GlobalLexicalScopeNamesResponse.html)"]
    pub struct GlobalLexicalScopeNamesResponse<'a> {
        #[serde(rename = "names")]
        pub names: Vec<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for GlobalLexicalScopeNamesResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.globalLexicalScopeNames";
    }
    impl<'b> ::HasCdpResponse<'b> for GlobalLexicalScopeNamesCommand {
        type Response = GlobalLexicalScopeNamesResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GlobalLexicalScopeNamesResponse<'b> {
        type Command = GlobalLexicalScopeNamesCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Command `Runtime.queryObjects`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::QueryObjectsCommand`](struct.QueryObjectsCommand.html)  \n*Response Struct:* [`cdp::runtime::QueryObjectsResponse`](struct.QueryObjectsResponse.html)"]
    pub struct QueryObjectsCommand<'a> {
        #[serde(rename = "prototypeObjectId")]
        #[doc = "Identifier of the prototype to return objects for."]
        pub prototype_object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release the results."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpCommand for QueryObjectsCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.queryObjects";
    }
    impl<'a> ::SerializeCdpCommand for QueryObjectsCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.queryObjects"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for QueryObjectsCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.queryObjects" {
                Ok(
                    <QueryObjectsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "# Command `Runtime.queryObjects`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::QueryObjectsCommand`](struct.QueryObjectsCommand.html)  \n*Response Struct:* [`cdp::runtime::QueryObjectsResponse`](struct.QueryObjectsResponse.html)"]
    pub struct QueryObjectsResponse<'a> {
        #[serde(rename = "objects")]
        #[doc = "Array with objects."]
        pub objects: ::runtime::RemoteObject<'a>,
    }
    impl<'a> ::CdpCommand for QueryObjectsResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.queryObjects";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for QueryObjectsCommand<'a> {
        type Response = QueryObjectsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for QueryObjectsResponse<'b> {
        type Command = QueryObjectsCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Releases remote object with given id.\n\n# Command `Runtime.releaseObject`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::ReleaseObjectCommand`](struct.ReleaseObjectCommand.html)  \n*Response Struct:* [`cdp::runtime::ReleaseObjectResponse`](struct.ReleaseObjectResponse.html)"]
    pub struct ReleaseObjectCommand<'a> {
        #[serde(rename = "objectId")]
        #[doc = "Identifier of the object to release."]
        pub object_id: ::runtime::RemoteObjectId<'a>,
    }
    impl<'a> ::CdpCommand for ReleaseObjectCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.releaseObject";
    }
    impl<'a> ::SerializeCdpCommand for ReleaseObjectCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.releaseObject"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReleaseObjectCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.releaseObject" {
                Ok(
                    <ReleaseObjectCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Releases remote object with given id.\n\n# Command `Runtime.releaseObject`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::ReleaseObjectCommand`](struct.ReleaseObjectCommand.html)  \n*Response Struct:* [`cdp::runtime::ReleaseObjectResponse`](struct.ReleaseObjectResponse.html)"]
    pub struct ReleaseObjectResponse;
    impl ::serde::Serialize for ReleaseObjectResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseObjectResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseObjectResponse)
        }
    }
    impl ::CdpCommand for ReleaseObjectResponse {
        const COMMAND_NAME: &'static str = "Runtime.releaseObject";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReleaseObjectCommand<'a> {
        type Response = ReleaseObjectResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReleaseObjectResponse {
        type Command = ReleaseObjectCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Releases all remote objects that belong to a given group.\n\n# Command `Runtime.releaseObjectGroup`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::ReleaseObjectGroupCommand`](struct.ReleaseObjectGroupCommand.html)  \n*Response Struct:* [`cdp::runtime::ReleaseObjectGroupResponse`](struct.ReleaseObjectGroupResponse.html)"]
    pub struct ReleaseObjectGroupCommand<'a> {
        #[serde(rename = "objectGroup")]
        #[doc = "Symbolic object group name."]
        pub object_group: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for ReleaseObjectGroupCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.releaseObjectGroup";
    }
    impl<'a> ::SerializeCdpCommand for ReleaseObjectGroupCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.releaseObjectGroup"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for ReleaseObjectGroupCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.releaseObjectGroup" {
                Ok ( < ReleaseObjectGroupCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Releases all remote objects that belong to a given group.\n\n# Command `Runtime.releaseObjectGroup`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::ReleaseObjectGroupCommand`](struct.ReleaseObjectGroupCommand.html)  \n*Response Struct:* [`cdp::runtime::ReleaseObjectGroupResponse`](struct.ReleaseObjectGroupResponse.html)"]
    pub struct ReleaseObjectGroupResponse;
    impl ::serde::Serialize for ReleaseObjectGroupResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ReleaseObjectGroupResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ReleaseObjectGroupResponse)
        }
    }
    impl ::CdpCommand for ReleaseObjectGroupResponse {
        const COMMAND_NAME: &'static str = "Runtime.releaseObjectGroup";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for ReleaseObjectGroupCommand<'a> {
        type Response = ReleaseObjectGroupResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for ReleaseObjectGroupResponse {
        type Command = ReleaseObjectGroupCommand<'a>;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n\n# Command `Runtime.runIfWaitingForDebugger`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RunIfWaitingForDebuggerCommand`](struct.RunIfWaitingForDebuggerCommand.html)  \n*Response Struct:* [`cdp::runtime::RunIfWaitingForDebuggerResponse`](struct.RunIfWaitingForDebuggerResponse.html)"]
    pub struct RunIfWaitingForDebuggerCommand;
    impl ::serde::Serialize for RunIfWaitingForDebuggerCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RunIfWaitingForDebuggerCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RunIfWaitingForDebuggerCommand)
        }
    }
    impl ::CdpCommand for RunIfWaitingForDebuggerCommand {
        const COMMAND_NAME: &'static str = "Runtime.runIfWaitingForDebugger";
    }
    impl ::SerializeCdpCommand for RunIfWaitingForDebuggerCommand {
        fn command_name(&self) -> &str {
            "Runtime.runIfWaitingForDebugger"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for RunIfWaitingForDebuggerCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.runIfWaitingForDebugger" {
                Ok ( < RunIfWaitingForDebuggerCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Tells inspected instance to run if it was waiting for debugger to attach.\n\n# Command `Runtime.runIfWaitingForDebugger`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RunIfWaitingForDebuggerCommand`](struct.RunIfWaitingForDebuggerCommand.html)  \n*Response Struct:* [`cdp::runtime::RunIfWaitingForDebuggerResponse`](struct.RunIfWaitingForDebuggerResponse.html)"]
    pub struct RunIfWaitingForDebuggerResponse;
    impl ::serde::Serialize for RunIfWaitingForDebuggerResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RunIfWaitingForDebuggerResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RunIfWaitingForDebuggerResponse)
        }
    }
    impl ::CdpCommand for RunIfWaitingForDebuggerResponse {
        const COMMAND_NAME: &'static str = "Runtime.runIfWaitingForDebugger";
    }
    impl<'b> ::HasCdpResponse<'b> for RunIfWaitingForDebuggerCommand {
        type Response = RunIfWaitingForDebuggerResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RunIfWaitingForDebuggerResponse {
        type Command = RunIfWaitingForDebuggerCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Runs script with given id in a given context.\n\n# Command `Runtime.runScript`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RunScriptCommand`](struct.RunScriptCommand.html)  \n*Response Struct:* [`cdp::runtime::RunScriptResponse`](struct.RunScriptResponse.html)"]
    pub struct RunScriptCommand<'a> {
        #[serde(rename = "scriptId")]
        #[doc = "Id of the script to run."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Specifies in which execution context to perform script run. If the parameter is omitted the\nevaluation will be performed in the context of the inspected page."]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
        #[serde(rename = "objectGroup", skip_serializing_if = "Option::is_none")]
        #[doc = "Symbolic group name that can be used to release multiple objects."]
        pub object_group: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "silent", skip_serializing_if = "Option::is_none")]
        #[doc = "In silent mode exceptions thrown during evaluation are not reported and do not pause\nexecution. Overrides `setPauseOnException` state."]
        pub silent: Option<bool>,
        #[serde(rename = "includeCommandLineAPI", skip_serializing_if = "Option::is_none")]
        #[doc = "Determines whether Command Line API should be available during the evaluation."]
        pub include_command_line_api: Option<bool>,
        #[serde(rename = "returnByValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether the result is expected to be a JSON object which should be sent by value."]
        pub return_by_value: Option<bool>,
        #[serde(rename = "generatePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether preview should be generated for the result."]
        pub generate_preview: Option<bool>,
        #[serde(rename = "awaitPromise", skip_serializing_if = "Option::is_none")]
        #[doc = "Whether execution should `await` for resulting value and return once awaited promise is\nresolved."]
        pub await_promise: Option<bool>,
    }
    impl<'a> ::CdpCommand for RunScriptCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.runScript";
    }
    impl<'a> ::SerializeCdpCommand for RunScriptCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.runScript"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RunScriptCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.runScript" {
                Ok(
                    <RunScriptCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Runs script with given id in a given context.\n\n# Command `Runtime.runScript`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RunScriptCommand`](struct.RunScriptCommand.html)  \n*Response Struct:* [`cdp::runtime::RunScriptResponse`](struct.RunScriptResponse.html)"]
    pub struct RunScriptResponse<'a> {
        #[serde(rename = "result")]
        #[doc = "Run result."]
        pub result: ::runtime::RemoteObject<'a>,
        #[serde(rename = "exceptionDetails", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception details."]
        pub exception_details: Option<::runtime::ExceptionDetails<'a>>,
    }
    impl<'a> ::CdpCommand for RunScriptResponse<'a> {
        const COMMAND_NAME: &'static str = "Runtime.runScript";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RunScriptCommand<'a> {
        type Response = RunScriptResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for RunScriptResponse<'b> {
        type Command = RunScriptCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Runtime.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::runtime::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthCommand {
        #[serde(rename = "maxDepth")]
        #[doc = "Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async\ncall stacks \\(default\\)."]
        pub max_depth: i32,
    }
    impl ::CdpCommand for SetAsyncCallStackDepthCommand {
        const COMMAND_NAME: &'static str = "Runtime.setAsyncCallStackDepth";
    }
    impl ::SerializeCdpCommand for SetAsyncCallStackDepthCommand {
        fn command_name(&self) -> &str {
            "Runtime.setAsyncCallStackDepth"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetAsyncCallStackDepthCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.setAsyncCallStackDepth" {
                Ok ( < SetAsyncCallStackDepthCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Enables or disables async call stacks tracking.\n\n# Command `Runtime.setAsyncCallStackDepth`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetAsyncCallStackDepthCommand`](struct.SetAsyncCallStackDepthCommand.html)  \n*Response Struct:* [`cdp::runtime::SetAsyncCallStackDepthResponse`](struct.SetAsyncCallStackDepthResponse.html)"]
    pub struct SetAsyncCallStackDepthResponse;
    impl ::serde::Serialize for SetAsyncCallStackDepthResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetAsyncCallStackDepthResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetAsyncCallStackDepthResponse)
        }
    }
    impl ::CdpCommand for SetAsyncCallStackDepthResponse {
        const COMMAND_NAME: &'static str = "Runtime.setAsyncCallStackDepth";
    }
    impl<'b> ::HasCdpResponse<'b> for SetAsyncCallStackDepthCommand {
        type Response = SetAsyncCallStackDepthResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetAsyncCallStackDepthResponse {
        type Command = SetAsyncCallStackDepthCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setCustomObjectFormatterEnabled`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetCustomObjectFormatterEnabledCommand`](struct.SetCustomObjectFormatterEnabledCommand.html)  \n*Response Struct:* [`cdp::runtime::SetCustomObjectFormatterEnabledResponse`](struct.SetCustomObjectFormatterEnabledResponse.html)"]
    pub struct SetCustomObjectFormatterEnabledCommand {
        #[serde(rename = "enabled")]
        pub enabled: bool,
    }
    impl ::CdpCommand for SetCustomObjectFormatterEnabledCommand {
        const COMMAND_NAME: &'static str = "Runtime.setCustomObjectFormatterEnabled";
    }
    impl ::SerializeCdpCommand for SetCustomObjectFormatterEnabledCommand {
        fn command_name(&self) -> &str {
            "Runtime.setCustomObjectFormatterEnabled"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetCustomObjectFormatterEnabledCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.setCustomObjectFormatterEnabled" {
                Ok ( < SetCustomObjectFormatterEnabledCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setCustomObjectFormatterEnabled`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetCustomObjectFormatterEnabledCommand`](struct.SetCustomObjectFormatterEnabledCommand.html)  \n*Response Struct:* [`cdp::runtime::SetCustomObjectFormatterEnabledResponse`](struct.SetCustomObjectFormatterEnabledResponse.html)"]
    pub struct SetCustomObjectFormatterEnabledResponse;
    impl ::serde::Serialize for SetCustomObjectFormatterEnabledResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetCustomObjectFormatterEnabledResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetCustomObjectFormatterEnabledResponse)
        }
    }
    impl ::CdpCommand for SetCustomObjectFormatterEnabledResponse {
        const COMMAND_NAME: &'static str = "Runtime.setCustomObjectFormatterEnabled";
    }
    impl<'b> ::HasCdpResponse<'b> for SetCustomObjectFormatterEnabledCommand {
        type Response = SetCustomObjectFormatterEnabledResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetCustomObjectFormatterEnabledResponse {
        type Command = SetCustomObjectFormatterEnabledCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setMaxCallStackSizeToCapture`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetMaxCallStackSizeToCaptureCommand`](struct.SetMaxCallStackSizeToCaptureCommand.html)  \n*Response Struct:* [`cdp::runtime::SetMaxCallStackSizeToCaptureResponse`](struct.SetMaxCallStackSizeToCaptureResponse.html)"]
    pub struct SetMaxCallStackSizeToCaptureCommand {
        #[serde(rename = "size")]
        pub size: i32,
    }
    impl ::CdpCommand for SetMaxCallStackSizeToCaptureCommand {
        const COMMAND_NAME: &'static str = "Runtime.setMaxCallStackSizeToCapture";
    }
    impl ::SerializeCdpCommand for SetMaxCallStackSizeToCaptureCommand {
        fn command_name(&self) -> &str {
            "Runtime.setMaxCallStackSizeToCapture"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for SetMaxCallStackSizeToCaptureCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.setMaxCallStackSizeToCapture" {
                Ok ( < SetMaxCallStackSizeToCaptureCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\n# Command `Runtime.setMaxCallStackSizeToCapture`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::SetMaxCallStackSizeToCaptureCommand`](struct.SetMaxCallStackSizeToCaptureCommand.html)  \n*Response Struct:* [`cdp::runtime::SetMaxCallStackSizeToCaptureResponse`](struct.SetMaxCallStackSizeToCaptureResponse.html)"]
    pub struct SetMaxCallStackSizeToCaptureResponse;
    impl ::serde::Serialize for SetMaxCallStackSizeToCaptureResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SetMaxCallStackSizeToCaptureResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| SetMaxCallStackSizeToCaptureResponse)
        }
    }
    impl ::CdpCommand for SetMaxCallStackSizeToCaptureResponse {
        const COMMAND_NAME: &'static str = "Runtime.setMaxCallStackSizeToCapture";
    }
    impl<'b> ::HasCdpResponse<'b> for SetMaxCallStackSizeToCaptureCommand {
        type Response = SetMaxCallStackSizeToCaptureResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for SetMaxCallStackSizeToCaptureResponse {
        type Command = SetMaxCallStackSizeToCaptureCommand;
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Terminate current or next JavaScript execution.\nWill cancel the termination when the outer-most script execution ends.\n\n# Command `Runtime.terminateExecution`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::TerminateExecutionCommand`](struct.TerminateExecutionCommand.html)  \n*Response Struct:* [`cdp::runtime::TerminateExecutionResponse`](struct.TerminateExecutionResponse.html)"]
    pub struct TerminateExecutionCommand;
    impl ::serde::Serialize for TerminateExecutionCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TerminateExecutionCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TerminateExecutionCommand)
        }
    }
    impl ::CdpCommand for TerminateExecutionCommand {
        const COMMAND_NAME: &'static str = "Runtime.terminateExecution";
    }
    impl ::SerializeCdpCommand for TerminateExecutionCommand {
        fn command_name(&self) -> &str {
            "Runtime.terminateExecution"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for TerminateExecutionCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.terminateExecution" {
                Ok ( < TerminateExecutionCommand as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Terminate current or next JavaScript execution.\nWill cancel the termination when the outer-most script execution ends.\n\n# Command `Runtime.terminateExecution`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::TerminateExecutionCommand`](struct.TerminateExecutionCommand.html)  \n*Response Struct:* [`cdp::runtime::TerminateExecutionResponse`](struct.TerminateExecutionResponse.html)"]
    pub struct TerminateExecutionResponse;
    impl ::serde::Serialize for TerminateExecutionResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for TerminateExecutionResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| TerminateExecutionResponse)
        }
    }
    impl ::CdpCommand for TerminateExecutionResponse {
        const COMMAND_NAME: &'static str = "Runtime.terminateExecution";
    }
    impl<'b> ::HasCdpResponse<'b> for TerminateExecutionCommand {
        type Response = TerminateExecutionResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for TerminateExecutionResponse {
        type Command = TerminateExecutionCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If executionContextId is empty, adds binding with the given name on the\nglobal objects of all inspected contexts, including those created later,\nbindings survive reloads.\nIf executionContextId is specified, adds binding only on global object of\ngiven execution context.\nBinding function takes exactly one argument, this argument should be string,\nin case of any other input, function throws an exception.\nEach binding function call produces Runtime.bindingCalled notification.\n\n# Command `Runtime.addBinding`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::AddBindingCommand`](struct.AddBindingCommand.html)  \n*Response Struct:* [`cdp::runtime::AddBindingResponse`](struct.AddBindingResponse.html)"]
    pub struct AddBindingCommand<'a> {
        #[serde(rename = "name")]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
    }
    impl<'a> ::CdpCommand for AddBindingCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.addBinding";
    }
    impl<'a> ::SerializeCdpCommand for AddBindingCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.addBinding"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for AddBindingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.addBinding" {
                Ok(
                    <AddBindingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If executionContextId is empty, adds binding with the given name on the\nglobal objects of all inspected contexts, including those created later,\nbindings survive reloads.\nIf executionContextId is specified, adds binding only on global object of\ngiven execution context.\nBinding function takes exactly one argument, this argument should be string,\nin case of any other input, function throws an exception.\nEach binding function call produces Runtime.bindingCalled notification.\n\n# Command `Runtime.addBinding`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::AddBindingCommand`](struct.AddBindingCommand.html)  \n*Response Struct:* [`cdp::runtime::AddBindingResponse`](struct.AddBindingResponse.html)"]
    pub struct AddBindingResponse;
    impl ::serde::Serialize for AddBindingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for AddBindingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| AddBindingResponse)
        }
    }
    impl ::CdpCommand for AddBindingResponse {
        const COMMAND_NAME: &'static str = "Runtime.addBinding";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for AddBindingCommand<'a> {
        type Response = AddBindingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for AddBindingResponse {
        type Command = AddBindingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method does not remove binding function from global object but\nunsubscribes current runtime agent from Runtime.bindingCalled notifications.\n\n# Command `Runtime.removeBinding`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RemoveBindingCommand`](struct.RemoveBindingCommand.html)  \n*Response Struct:* [`cdp::runtime::RemoveBindingResponse`](struct.RemoveBindingResponse.html)"]
    pub struct RemoveBindingCommand<'a> {
        #[serde(rename = "name")]
        pub name: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ::CdpCommand for RemoveBindingCommand<'a> {
        const COMMAND_NAME: &'static str = "Runtime.removeBinding";
    }
    impl<'a> ::SerializeCdpCommand for RemoveBindingCommand<'a> {
        fn command_name(&self) -> &str {
            "Runtime.removeBinding"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpCommand<'de> for RemoveBindingCommand<'a> {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.removeBinding" {
                Ok(
                    <RemoveBindingCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> This method does not remove binding function from global object but\nunsubscribes current runtime agent from Runtime.bindingCalled notifications.\n\n# Command `Runtime.removeBinding`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Command Struct:* [`cdp::runtime::RemoveBindingCommand`](struct.RemoveBindingCommand.html)  \n*Response Struct:* [`cdp::runtime::RemoveBindingResponse`](struct.RemoveBindingResponse.html)"]
    pub struct RemoveBindingResponse;
    impl ::serde::Serialize for RemoveBindingResponse {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for RemoveBindingResponse {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| RemoveBindingResponse)
        }
    }
    impl ::CdpCommand for RemoveBindingResponse {
        const COMMAND_NAME: &'static str = "Runtime.removeBinding";
    }
    impl<'b, 'a> ::HasCdpResponse<'b> for RemoveBindingCommand<'a> {
        type Response = RemoveBindingResponse;
    }
    impl<'a> ::HasCdpCommand<'a> for RemoveBindingResponse {
        type Command = RemoveBindingCommand<'a>;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Notification is issued every time when binding is called.\n\n# Event `Runtime.bindingCalled`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::BindingCalledEvent`](struct.BindingCalledEvent.html)"]
    pub struct BindingCalledEvent<'a> {
        #[serde(rename = "name")]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "payload")]
        pub payload: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "executionContextId")]
        #[doc = "Identifier of the context where the call was made."]
        pub execution_context_id: ::runtime::ExecutionContextId,
    }
    impl<'a> ::CdpEvent for BindingCalledEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.bindingCalled";
    }
    impl<'a> ::SerializeCdpEvent for BindingCalledEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.bindingCalled"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for BindingCalledEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.bindingCalled" {
                Ok(
                    <BindingCalledEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::runtime::ConsoleApiCalledEvent::ty`](struct.ConsoleApiCalledEvent.html#structfield.ty)."]
    pub enum ConsoleApiCalledEventType {
        #[serde(rename = "log")]
        #[doc = "Represented as `\"log\"`."]
        Log,
        #[serde(rename = "debug")]
        #[doc = "Represented as `\"debug\"`."]
        Debug,
        #[serde(rename = "info")]
        #[doc = "Represented as `\"info\"`."]
        Info,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "warning")]
        #[doc = "Represented as `\"warning\"`."]
        Warning,
        #[serde(rename = "dir")]
        #[doc = "Represented as `\"dir\"`."]
        Dir,
        #[serde(rename = "dirxml")]
        #[doc = "Represented as `\"dirxml\"`."]
        Dirxml,
        #[serde(rename = "table")]
        #[doc = "Represented as `\"table\"`."]
        Table,
        #[serde(rename = "trace")]
        #[doc = "Represented as `\"trace\"`."]
        Trace,
        #[serde(rename = "clear")]
        #[doc = "Represented as `\"clear\"`."]
        Clear,
        #[serde(rename = "startGroup")]
        #[doc = "Represented as `\"startGroup\"`."]
        StartGroup,
        #[serde(rename = "startGroupCollapsed")]
        #[doc = "Represented as `\"startGroupCollapsed\"`."]
        StartGroupCollapsed,
        #[serde(rename = "endGroup")]
        #[doc = "Represented as `\"endGroup\"`."]
        EndGroup,
        #[serde(rename = "assert")]
        #[doc = "Represented as `\"assert\"`."]
        Assert,
        #[serde(rename = "profile")]
        #[doc = "Represented as `\"profile\"`."]
        Profile,
        #[serde(rename = "profileEnd")]
        #[doc = "Represented as `\"profileEnd\"`."]
        ProfileEnd,
        #[serde(rename = "count")]
        #[doc = "Represented as `\"count\"`."]
        Count,
        #[serde(rename = "timeEnd")]
        #[doc = "Represented as `\"timeEnd\"`."]
        TimeEnd,
    }
    impl ConsoleApiCalledEventType {
        pub const ENUM_VALUES: &'static [ConsoleApiCalledEventType] =
            &[
                ConsoleApiCalledEventType::Log,
                ConsoleApiCalledEventType::Debug,
                ConsoleApiCalledEventType::Info,
                ConsoleApiCalledEventType::Error,
                ConsoleApiCalledEventType::Warning,
                ConsoleApiCalledEventType::Dir,
                ConsoleApiCalledEventType::Dirxml,
                ConsoleApiCalledEventType::Table,
                ConsoleApiCalledEventType::Trace,
                ConsoleApiCalledEventType::Clear,
                ConsoleApiCalledEventType::StartGroup,
                ConsoleApiCalledEventType::StartGroupCollapsed,
                ConsoleApiCalledEventType::EndGroup,
                ConsoleApiCalledEventType::Assert,
                ConsoleApiCalledEventType::Profile,
                ConsoleApiCalledEventType::ProfileEnd,
                ConsoleApiCalledEventType::Count,
                ConsoleApiCalledEventType::TimeEnd,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "log",
            "debug",
            "info",
            "error",
            "warning",
            "dir",
            "dirxml",
            "table",
            "trace",
            "clear",
            "startGroup",
            "startGroupCollapsed",
            "endGroup",
            "assert",
            "profile",
            "profileEnd",
            "count",
            "timeEnd",
        ];
    }
    impl ::std::str::FromStr for ConsoleApiCalledEventType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "log" => Ok(ConsoleApiCalledEventType::Log),
                "debug" => Ok(ConsoleApiCalledEventType::Debug),
                "info" => Ok(ConsoleApiCalledEventType::Info),
                "error" => Ok(ConsoleApiCalledEventType::Error),
                "warning" => Ok(ConsoleApiCalledEventType::Warning),
                "dir" => Ok(ConsoleApiCalledEventType::Dir),
                "dirxml" => Ok(ConsoleApiCalledEventType::Dirxml),
                "table" => Ok(ConsoleApiCalledEventType::Table),
                "trace" => Ok(ConsoleApiCalledEventType::Trace),
                "clear" => Ok(ConsoleApiCalledEventType::Clear),
                "startGroup" => Ok(ConsoleApiCalledEventType::StartGroup),
                "startGroupCollapsed" => Ok(ConsoleApiCalledEventType::StartGroupCollapsed),
                "endGroup" => Ok(ConsoleApiCalledEventType::EndGroup),
                "assert" => Ok(ConsoleApiCalledEventType::Assert),
                "profile" => Ok(ConsoleApiCalledEventType::Profile),
                "profileEnd" => Ok(ConsoleApiCalledEventType::ProfileEnd),
                "count" => Ok(ConsoleApiCalledEventType::Count),
                "timeEnd" => Ok(ConsoleApiCalledEventType::TimeEnd),
                _ => Err(::ParseEnumError {
                    expected: ConsoleApiCalledEventType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ConsoleApiCalledEventType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ConsoleApiCalledEventType::Log => "log",
                    ConsoleApiCalledEventType::Debug => "debug",
                    ConsoleApiCalledEventType::Info => "info",
                    ConsoleApiCalledEventType::Error => "error",
                    ConsoleApiCalledEventType::Warning => "warning",
                    ConsoleApiCalledEventType::Dir => "dir",
                    ConsoleApiCalledEventType::Dirxml => "dirxml",
                    ConsoleApiCalledEventType::Table => "table",
                    ConsoleApiCalledEventType::Trace => "trace",
                    ConsoleApiCalledEventType::Clear => "clear",
                    ConsoleApiCalledEventType::StartGroup => "startGroup",
                    ConsoleApiCalledEventType::StartGroupCollapsed => "startGroupCollapsed",
                    ConsoleApiCalledEventType::EndGroup => "endGroup",
                    ConsoleApiCalledEventType::Assert => "assert",
                    ConsoleApiCalledEventType::Profile => "profile",
                    ConsoleApiCalledEventType::ProfileEnd => "profileEnd",
                    ConsoleApiCalledEventType::Count => "count",
                    ConsoleApiCalledEventType::TimeEnd => "timeEnd",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when console API was called.\n\n# Event `Runtime.consoleAPICalled`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ConsoleApiCalledEvent`](struct.ConsoleApiCalledEvent.html)"]
    pub struct ConsoleApiCalledEvent<'a> {
        #[serde(rename = "type")]
        #[doc = "Type of the call."]
        pub ty: ::runtime::ConsoleApiCalledEventType,
        #[serde(rename = "args")]
        #[doc = "Call arguments."]
        pub args: Vec<::runtime::RemoteObject<'a>>,
        #[serde(rename = "executionContextId")]
        #[doc = "Identifier of the context where the call was made."]
        pub execution_context_id: ::runtime::ExecutionContextId,
        #[serde(rename = "timestamp")]
        #[doc = "Call timestamp."]
        pub timestamp: ::runtime::Timestamp,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "Stack trace captured when the call was made."]
        pub stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "context", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Console context descriptor for calls on non-default console context \\(not console.\\*\\):\n'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call\non named context."]
        pub context: Option<::std::borrow::Cow<'a, str>>,
    }
    impl<'a> ::CdpEvent for ConsoleApiCalledEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.consoleAPICalled";
    }
    impl<'a> ::SerializeCdpEvent for ConsoleApiCalledEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.consoleAPICalled"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ConsoleApiCalledEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.consoleAPICalled" {
                Ok(
                    <ConsoleApiCalledEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when unhandled exception was revoked.\n\n# Event `Runtime.exceptionRevoked`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ExceptionRevokedEvent`](struct.ExceptionRevokedEvent.html)"]
    pub struct ExceptionRevokedEvent<'a> {
        #[serde(rename = "reason")]
        #[doc = "Reason describing why exception was revoked."]
        pub reason: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "exceptionId")]
        #[doc = "The id of revoked exception, as reported in `exceptionThrown`."]
        pub exception_id: i32,
    }
    impl<'a> ::CdpEvent for ExceptionRevokedEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.exceptionRevoked";
    }
    impl<'a> ::SerializeCdpEvent for ExceptionRevokedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.exceptionRevoked"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ExceptionRevokedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.exceptionRevoked" {
                Ok(
                    <ExceptionRevokedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when exception was thrown and unhandled.\n\n# Event `Runtime.exceptionThrown`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ExceptionThrownEvent`](struct.ExceptionThrownEvent.html)"]
    pub struct ExceptionThrownEvent<'a> {
        #[serde(rename = "timestamp")]
        #[doc = "Timestamp of the exception."]
        pub timestamp: ::runtime::Timestamp,
        #[serde(rename = "exceptionDetails")]
        pub exception_details: ::runtime::ExceptionDetails<'a>,
    }
    impl<'a> ::CdpEvent for ExceptionThrownEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.exceptionThrown";
    }
    impl<'a> ::SerializeCdpEvent for ExceptionThrownEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.exceptionThrown"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ExceptionThrownEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.exceptionThrown" {
                Ok(
                    <ExceptionThrownEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when new execution context is created.\n\n# Event `Runtime.executionContextCreated`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ExecutionContextCreatedEvent`](struct.ExecutionContextCreatedEvent.html)"]
    pub struct ExecutionContextCreatedEvent<'a> {
        #[serde(rename = "context")]
        #[doc = "A newly created execution context."]
        pub context: ::runtime::ExecutionContextDescription<'a>,
    }
    impl<'a> ::CdpEvent for ExecutionContextCreatedEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.executionContextCreated";
    }
    impl<'a> ::SerializeCdpEvent for ExecutionContextCreatedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.executionContextCreated"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for ExecutionContextCreatedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextCreated" {
                Ok ( < ExecutionContextCreatedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when execution context is destroyed.\n\n# Event `Runtime.executionContextDestroyed`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ExecutionContextDestroyedEvent`](struct.ExecutionContextDestroyedEvent.html)"]
    pub struct ExecutionContextDestroyedEvent {
        #[serde(rename = "executionContextId")]
        #[doc = "Id of the destroyed context"]
        pub execution_context_id: ::runtime::ExecutionContextId,
    }
    impl ::CdpEvent for ExecutionContextDestroyedEvent {
        const EVENT_NAME: &'static str = "Runtime.executionContextDestroyed";
    }
    impl ::SerializeCdpEvent for ExecutionContextDestroyedEvent {
        fn event_name(&self) -> &str {
            "Runtime.executionContextDestroyed"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ExecutionContextDestroyedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextDestroyed" {
                Ok ( < ExecutionContextDestroyedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Issued when all executionContexts were cleared in browser\n\n# Event `Runtime.executionContextsCleared`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::ExecutionContextsClearedEvent`](struct.ExecutionContextsClearedEvent.html)"]
    pub struct ExecutionContextsClearedEvent;
    impl ::serde::Serialize for ExecutionContextsClearedEvent {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for ExecutionContextsClearedEvent {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| ExecutionContextsClearedEvent)
        }
    }
    impl ::CdpEvent for ExecutionContextsClearedEvent {
        const EVENT_NAME: &'static str = "Runtime.executionContextsCleared";
    }
    impl ::SerializeCdpEvent for ExecutionContextsClearedEvent {
        fn event_name(&self) -> &str {
            "Runtime.executionContextsCleared"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpEvent<'de> for ExecutionContextsClearedEvent {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.executionContextsCleared" {
                Ok ( < ExecutionContextsClearedEvent as :: serde :: Deserialize < 'de >> :: deserialize ( params ) )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Issued when object should be inspected \\(for example, as a result of inspect\\(\\) command line API\ncall\\).\n\n# Event `Runtime.inspectRequested`\n\n*Domain Module:* [`cdp::runtime`](index.html)  \n*Event Struct:* [`cdp::runtime::InspectRequestedEvent`](struct.InspectRequestedEvent.html)"]
    pub struct InspectRequestedEvent<'a> {
        #[serde(rename = "object")]
        pub object: ::runtime::RemoteObject<'a>,
        #[serde(rename = "hints")]
        pub hints: ::Empty,
    }
    impl<'a> ::CdpEvent for InspectRequestedEvent<'a> {
        const EVENT_NAME: &'static str = "Runtime.inspectRequested";
    }
    impl<'a> ::SerializeCdpEvent for InspectRequestedEvent<'a> {
        fn event_name(&self) -> &str {
            "Runtime.inspectRequested"
        }
        fn serialize_event_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de, 'a> ::DeserializeCdpEvent<'de> for InspectRequestedEvent<'a> {
        fn deserialize_event<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Runtime.inspectRequested" {
                Ok(
                    <InspectRequestedEvent as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[doc = "Unique script identifier."]
    pub type ScriptId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Unique object identifier."]
    pub type RemoteObjectId<'a> = ::std::borrow::Cow<'a, str>;
    #[doc = "Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,\n`-Infinity`, and bigint literals."]
    pub type UnserializableValue<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::runtime::RemoteObject::ty`](struct.RemoteObject.html#structfield.ty)."]
    pub enum RemoteObjectType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
        #[serde(rename = "bigint")]
        #[doc = "Represented as `\"bigint\"`."]
        Bigint,
    }
    impl RemoteObjectType {
        pub const ENUM_VALUES: &'static [RemoteObjectType] = &[
            RemoteObjectType::Object,
            RemoteObjectType::Function,
            RemoteObjectType::Undefined,
            RemoteObjectType::String,
            RemoteObjectType::Number,
            RemoteObjectType::Boolean,
            RemoteObjectType::Symbol,
            RemoteObjectType::Bigint,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
            "bigint",
        ];
    }
    impl ::std::str::FromStr for RemoteObjectType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(RemoteObjectType::Object),
                "function" => Ok(RemoteObjectType::Function),
                "undefined" => Ok(RemoteObjectType::Undefined),
                "string" => Ok(RemoteObjectType::String),
                "number" => Ok(RemoteObjectType::Number),
                "boolean" => Ok(RemoteObjectType::Boolean),
                "symbol" => Ok(RemoteObjectType::Symbol),
                "bigint" => Ok(RemoteObjectType::Bigint),
                _ => Err(::ParseEnumError {
                    expected: RemoteObjectType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RemoteObjectType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RemoteObjectType::Object => "object",
                    RemoteObjectType::Function => "function",
                    RemoteObjectType::Undefined => "undefined",
                    RemoteObjectType::String => "string",
                    RemoteObjectType::Number => "number",
                    RemoteObjectType::Boolean => "boolean",
                    RemoteObjectType::Symbol => "symbol",
                    RemoteObjectType::Bigint => "bigint",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "Used in the type of [`cdp::runtime::RemoteObject::subtype`](struct.RemoteObject.html#structfield.subtype)."]
    pub enum RemoteObjectSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
        #[serde(rename = "proxy")]
        #[doc = "Represented as `\"proxy\"`."]
        Proxy,
        #[serde(rename = "promise")]
        #[doc = "Represented as `\"promise\"`."]
        Promise,
        #[serde(rename = "typedarray")]
        #[doc = "Represented as `\"typedarray\"`."]
        Typedarray,
    }
    impl RemoteObjectSubtype {
        pub const ENUM_VALUES: &'static [RemoteObjectSubtype] = &[
            RemoteObjectSubtype::Array,
            RemoteObjectSubtype::Null,
            RemoteObjectSubtype::Node,
            RemoteObjectSubtype::Regexp,
            RemoteObjectSubtype::Date,
            RemoteObjectSubtype::Map,
            RemoteObjectSubtype::Set,
            RemoteObjectSubtype::Weakmap,
            RemoteObjectSubtype::Weakset,
            RemoteObjectSubtype::Iterator,
            RemoteObjectSubtype::Generator,
            RemoteObjectSubtype::Error,
            RemoteObjectSubtype::Proxy,
            RemoteObjectSubtype::Promise,
            RemoteObjectSubtype::Typedarray,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
            "proxy",
            "promise",
            "typedarray",
        ];
    }
    impl ::std::str::FromStr for RemoteObjectSubtype {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(RemoteObjectSubtype::Array),
                "null" => Ok(RemoteObjectSubtype::Null),
                "node" => Ok(RemoteObjectSubtype::Node),
                "regexp" => Ok(RemoteObjectSubtype::Regexp),
                "date" => Ok(RemoteObjectSubtype::Date),
                "map" => Ok(RemoteObjectSubtype::Map),
                "set" => Ok(RemoteObjectSubtype::Set),
                "weakmap" => Ok(RemoteObjectSubtype::Weakmap),
                "weakset" => Ok(RemoteObjectSubtype::Weakset),
                "iterator" => Ok(RemoteObjectSubtype::Iterator),
                "generator" => Ok(RemoteObjectSubtype::Generator),
                "error" => Ok(RemoteObjectSubtype::Error),
                "proxy" => Ok(RemoteObjectSubtype::Proxy),
                "promise" => Ok(RemoteObjectSubtype::Promise),
                "typedarray" => Ok(RemoteObjectSubtype::Typedarray),
                _ => Err(::ParseEnumError {
                    expected: RemoteObjectSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for RemoteObjectSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    RemoteObjectSubtype::Array => "array",
                    RemoteObjectSubtype::Null => "null",
                    RemoteObjectSubtype::Node => "node",
                    RemoteObjectSubtype::Regexp => "regexp",
                    RemoteObjectSubtype::Date => "date",
                    RemoteObjectSubtype::Map => "map",
                    RemoteObjectSubtype::Set => "set",
                    RemoteObjectSubtype::Weakmap => "weakmap",
                    RemoteObjectSubtype::Weakset => "weakset",
                    RemoteObjectSubtype::Iterator => "iterator",
                    RemoteObjectSubtype::Generator => "generator",
                    RemoteObjectSubtype::Error => "error",
                    RemoteObjectSubtype::Proxy => "proxy",
                    RemoteObjectSubtype::Promise => "promise",
                    RemoteObjectSubtype::Typedarray => "typedarray",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Mirror object referencing original JavaScript object."]
    pub struct RemoteObject<'a> {
        #[serde(rename = "type")]
        #[doc = "Object type."]
        pub ty: ::runtime::RemoteObjectType,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for `object` type values only."]
        pub subtype: Option<::runtime::RemoteObjectSubtype>,
        #[serde(rename = "className", skip_serializing_if = "Option::is_none")]
        #[doc = "Object class \\(constructor\\) name. Specified for `object` type values only."]
        pub class_name: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote object value in case of primitive values or JSON values \\(if it was requested\\)."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "unserializableValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value which can not be JSON-stringified does not have `value`, but gets this\nproperty."]
        pub unserializable_value: Option<::runtime::UnserializableValue<'a>>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String representation of the object."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "Unique object identifier \\(for non-primitive values\\)."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
        #[serde(rename = "preview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Preview containing abbreviated property values. Specified for `object` type values only."]
        pub preview: Option<::runtime::ObjectPreview<'a>>,
        #[serde(rename = "customPreview", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
        pub custom_preview: Option<::runtime::CustomPreview<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct CustomPreview<'a> {
        #[serde(rename = "header")]
        pub header: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "hasBody")]
        pub has_body: bool,
        #[serde(rename = "formatterObjectId")]
        pub formatter_object_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "bindRemoteObjectFunctionId")]
        pub bind_remote_object_function_id: ::runtime::RemoteObjectId<'a>,
        #[serde(rename = "configObjectId", skip_serializing_if = "Option::is_none")]
        pub config_object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::runtime::ObjectPreview::ty`](struct.ObjectPreview.html#structfield.ty)."]
    pub enum ObjectPreviewType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
        #[serde(rename = "bigint")]
        #[doc = "Represented as `\"bigint\"`."]
        Bigint,
    }
    impl ObjectPreviewType {
        pub const ENUM_VALUES: &'static [ObjectPreviewType] = &[
            ObjectPreviewType::Object,
            ObjectPreviewType::Function,
            ObjectPreviewType::Undefined,
            ObjectPreviewType::String,
            ObjectPreviewType::Number,
            ObjectPreviewType::Boolean,
            ObjectPreviewType::Symbol,
            ObjectPreviewType::Bigint,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
            "bigint",
        ];
    }
    impl ::std::str::FromStr for ObjectPreviewType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(ObjectPreviewType::Object),
                "function" => Ok(ObjectPreviewType::Function),
                "undefined" => Ok(ObjectPreviewType::Undefined),
                "string" => Ok(ObjectPreviewType::String),
                "number" => Ok(ObjectPreviewType::Number),
                "boolean" => Ok(ObjectPreviewType::Boolean),
                "symbol" => Ok(ObjectPreviewType::Symbol),
                "bigint" => Ok(ObjectPreviewType::Bigint),
                _ => Err(::ParseEnumError {
                    expected: ObjectPreviewType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ObjectPreviewType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ObjectPreviewType::Object => "object",
                    ObjectPreviewType::Function => "function",
                    ObjectPreviewType::Undefined => "undefined",
                    ObjectPreviewType::String => "string",
                    ObjectPreviewType::Number => "number",
                    ObjectPreviewType::Boolean => "boolean",
                    ObjectPreviewType::Symbol => "symbol",
                    ObjectPreviewType::Bigint => "bigint",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::runtime::ObjectPreview::subtype`](struct.ObjectPreview.html#structfield.subtype)."]
    pub enum ObjectPreviewSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl ObjectPreviewSubtype {
        pub const ENUM_VALUES: &'static [ObjectPreviewSubtype] = &[
            ObjectPreviewSubtype::Array,
            ObjectPreviewSubtype::Null,
            ObjectPreviewSubtype::Node,
            ObjectPreviewSubtype::Regexp,
            ObjectPreviewSubtype::Date,
            ObjectPreviewSubtype::Map,
            ObjectPreviewSubtype::Set,
            ObjectPreviewSubtype::Weakmap,
            ObjectPreviewSubtype::Weakset,
            ObjectPreviewSubtype::Iterator,
            ObjectPreviewSubtype::Generator,
            ObjectPreviewSubtype::Error,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
        ];
    }
    impl ::std::str::FromStr for ObjectPreviewSubtype {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(ObjectPreviewSubtype::Array),
                "null" => Ok(ObjectPreviewSubtype::Null),
                "node" => Ok(ObjectPreviewSubtype::Node),
                "regexp" => Ok(ObjectPreviewSubtype::Regexp),
                "date" => Ok(ObjectPreviewSubtype::Date),
                "map" => Ok(ObjectPreviewSubtype::Map),
                "set" => Ok(ObjectPreviewSubtype::Set),
                "weakmap" => Ok(ObjectPreviewSubtype::Weakmap),
                "weakset" => Ok(ObjectPreviewSubtype::Weakset),
                "iterator" => Ok(ObjectPreviewSubtype::Iterator),
                "generator" => Ok(ObjectPreviewSubtype::Generator),
                "error" => Ok(ObjectPreviewSubtype::Error),
                _ => Err(::ParseEnumError {
                    expected: ObjectPreviewSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for ObjectPreviewSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    ObjectPreviewSubtype::Array => "array",
                    ObjectPreviewSubtype::Null => "null",
                    ObjectPreviewSubtype::Node => "node",
                    ObjectPreviewSubtype::Regexp => "regexp",
                    ObjectPreviewSubtype::Date => "date",
                    ObjectPreviewSubtype::Map => "map",
                    ObjectPreviewSubtype::Set => "set",
                    ObjectPreviewSubtype::Weakmap => "weakmap",
                    ObjectPreviewSubtype::Weakset => "weakset",
                    ObjectPreviewSubtype::Iterator => "iterator",
                    ObjectPreviewSubtype::Generator => "generator",
                    ObjectPreviewSubtype::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Object containing abbreviated remote object value."]
    pub struct ObjectPreview<'a> {
        #[serde(rename = "type")]
        #[doc = "Object type."]
        pub ty: ::runtime::ObjectPreviewType,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for `object` type values only."]
        pub subtype: Option<::runtime::ObjectPreviewSubtype>,
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String representation of the object."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "overflow")]
        #[doc = "True iff some of the properties or entries of the original object did not fit."]
        pub overflow: bool,
        #[serde(rename = "properties")]
        #[doc = "List of the properties."]
        pub properties: Vec<::runtime::PropertyPreview<'a>>,
        #[serde(rename = "entries", skip_serializing_if = "Option::is_none")]
        #[doc = "List of the entries. Specified for `map` and `set` subtype values only."]
        pub entries: Option<Vec<::runtime::EntryPreview<'a>>>,
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::runtime::PropertyPreview::ty`](struct.PropertyPreview.html#structfield.ty)."]
    pub enum PropertyPreviewType {
        #[serde(rename = "object")]
        #[doc = "Represented as `\"object\"`."]
        Object,
        #[serde(rename = "function")]
        #[doc = "Represented as `\"function\"`."]
        Function,
        #[serde(rename = "undefined")]
        #[doc = "Represented as `\"undefined\"`."]
        Undefined,
        #[serde(rename = "string")]
        #[doc = "Represented as `\"string\"`."]
        String,
        #[serde(rename = "number")]
        #[doc = "Represented as `\"number\"`."]
        Number,
        #[serde(rename = "boolean")]
        #[doc = "Represented as `\"boolean\"`."]
        Boolean,
        #[serde(rename = "symbol")]
        #[doc = "Represented as `\"symbol\"`."]
        Symbol,
        #[serde(rename = "accessor")]
        #[doc = "Represented as `\"accessor\"`."]
        Accessor,
        #[serde(rename = "bigint")]
        #[doc = "Represented as `\"bigint\"`."]
        Bigint,
    }
    impl PropertyPreviewType {
        pub const ENUM_VALUES: &'static [PropertyPreviewType] = &[
            PropertyPreviewType::Object,
            PropertyPreviewType::Function,
            PropertyPreviewType::Undefined,
            PropertyPreviewType::String,
            PropertyPreviewType::Number,
            PropertyPreviewType::Boolean,
            PropertyPreviewType::Symbol,
            PropertyPreviewType::Accessor,
            PropertyPreviewType::Bigint,
        ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "object",
            "function",
            "undefined",
            "string",
            "number",
            "boolean",
            "symbol",
            "accessor",
            "bigint",
        ];
    }
    impl ::std::str::FromStr for PropertyPreviewType {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "object" => Ok(PropertyPreviewType::Object),
                "function" => Ok(PropertyPreviewType::Function),
                "undefined" => Ok(PropertyPreviewType::Undefined),
                "string" => Ok(PropertyPreviewType::String),
                "number" => Ok(PropertyPreviewType::Number),
                "boolean" => Ok(PropertyPreviewType::Boolean),
                "symbol" => Ok(PropertyPreviewType::Symbol),
                "accessor" => Ok(PropertyPreviewType::Accessor),
                "bigint" => Ok(PropertyPreviewType::Bigint),
                _ => Err(::ParseEnumError {
                    expected: PropertyPreviewType::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PropertyPreviewType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PropertyPreviewType::Object => "object",
                    PropertyPreviewType::Function => "function",
                    PropertyPreviewType::Undefined => "undefined",
                    PropertyPreviewType::String => "string",
                    PropertyPreviewType::Number => "number",
                    PropertyPreviewType::Boolean => "boolean",
                    PropertyPreviewType::Symbol => "symbol",
                    PropertyPreviewType::Accessor => "accessor",
                    PropertyPreviewType::Bigint => "bigint",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>\n\nUsed in the type of [`cdp::runtime::PropertyPreview::subtype`](struct.PropertyPreview.html#structfield.subtype)."]
    pub enum PropertyPreviewSubtype {
        #[serde(rename = "array")]
        #[doc = "Represented as `\"array\"`."]
        Array,
        #[serde(rename = "null")]
        #[doc = "Represented as `\"null\"`."]
        Null,
        #[serde(rename = "node")]
        #[doc = "Represented as `\"node\"`."]
        Node,
        #[serde(rename = "regexp")]
        #[doc = "Represented as `\"regexp\"`."]
        Regexp,
        #[serde(rename = "date")]
        #[doc = "Represented as `\"date\"`."]
        Date,
        #[serde(rename = "map")]
        #[doc = "Represented as `\"map\"`."]
        Map,
        #[serde(rename = "set")]
        #[doc = "Represented as `\"set\"`."]
        Set,
        #[serde(rename = "weakmap")]
        #[doc = "Represented as `\"weakmap\"`."]
        Weakmap,
        #[serde(rename = "weakset")]
        #[doc = "Represented as `\"weakset\"`."]
        Weakset,
        #[serde(rename = "iterator")]
        #[doc = "Represented as `\"iterator\"`."]
        Iterator,
        #[serde(rename = "generator")]
        #[doc = "Represented as `\"generator\"`."]
        Generator,
        #[serde(rename = "error")]
        #[doc = "Represented as `\"error\"`."]
        Error,
    }
    impl PropertyPreviewSubtype {
        pub const ENUM_VALUES: &'static [PropertyPreviewSubtype] =
            &[
                PropertyPreviewSubtype::Array,
                PropertyPreviewSubtype::Null,
                PropertyPreviewSubtype::Node,
                PropertyPreviewSubtype::Regexp,
                PropertyPreviewSubtype::Date,
                PropertyPreviewSubtype::Map,
                PropertyPreviewSubtype::Set,
                PropertyPreviewSubtype::Weakmap,
                PropertyPreviewSubtype::Weakset,
                PropertyPreviewSubtype::Iterator,
                PropertyPreviewSubtype::Generator,
                PropertyPreviewSubtype::Error,
            ];
        pub const STR_VALUES: &'static [&'static str] = &[
            "array",
            "null",
            "node",
            "regexp",
            "date",
            "map",
            "set",
            "weakmap",
            "weakset",
            "iterator",
            "generator",
            "error",
        ];
    }
    impl ::std::str::FromStr for PropertyPreviewSubtype {
        type Err = ::ParseEnumError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "array" => Ok(PropertyPreviewSubtype::Array),
                "null" => Ok(PropertyPreviewSubtype::Null),
                "node" => Ok(PropertyPreviewSubtype::Node),
                "regexp" => Ok(PropertyPreviewSubtype::Regexp),
                "date" => Ok(PropertyPreviewSubtype::Date),
                "map" => Ok(PropertyPreviewSubtype::Map),
                "set" => Ok(PropertyPreviewSubtype::Set),
                "weakmap" => Ok(PropertyPreviewSubtype::Weakmap),
                "weakset" => Ok(PropertyPreviewSubtype::Weakset),
                "iterator" => Ok(PropertyPreviewSubtype::Iterator),
                "generator" => Ok(PropertyPreviewSubtype::Generator),
                "error" => Ok(PropertyPreviewSubtype::Error),
                _ => Err(::ParseEnumError {
                    expected: PropertyPreviewSubtype::STR_VALUES,
                    actual: s.into(),
                }),
            }
        }
    }
    impl ::std::fmt::Display for PropertyPreviewSubtype {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(
                f,
                "{}",
                match *self {
                    PropertyPreviewSubtype::Array => "array",
                    PropertyPreviewSubtype::Null => "null",
                    PropertyPreviewSubtype::Node => "node",
                    PropertyPreviewSubtype::Regexp => "regexp",
                    PropertyPreviewSubtype::Date => "date",
                    PropertyPreviewSubtype::Map => "map",
                    PropertyPreviewSubtype::Set => "set",
                    PropertyPreviewSubtype::Weakmap => "weakmap",
                    PropertyPreviewSubtype::Weakset => "weakset",
                    PropertyPreviewSubtype::Iterator => "iterator",
                    PropertyPreviewSubtype::Generator => "generator",
                    PropertyPreviewSubtype::Error => "error",
                }
            )
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct PropertyPreview<'a> {
        #[serde(rename = "name")]
        #[doc = "Property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "type")]
        #[doc = "Object type. Accessor means that the property itself is an accessor property."]
        pub ty: ::runtime::PropertyPreviewType,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "User-friendly property value string."]
        pub value: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "valuePreview", skip_serializing_if = "Option::is_none")]
        #[doc = "Nested value preview."]
        pub value_preview: Option<::runtime::ObjectPreview<'a>>,
        #[serde(rename = "subtype", skip_serializing_if = "Option::is_none")]
        #[doc = "Object subtype hint. Specified for `object` type values only."]
        pub subtype: Option<::runtime::PropertyPreviewSubtype>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span>"]
    pub struct EntryPreview<'a> {
        #[serde(rename = "key", skip_serializing_if = "Option::is_none")]
        #[doc = "Preview of the key. Specified for map-like collection entries."]
        pub key: Option<::runtime::ObjectPreview<'a>>,
        #[serde(rename = "value")]
        #[doc = "Preview of the value."]
        pub value: ::runtime::ObjectPreview<'a>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Object property descriptor."]
    pub struct PropertyDescriptor<'a> {
        #[serde(rename = "name")]
        #[doc = "Property name or symbol description."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value associated with the property."]
        pub value: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "writable", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the value associated with the property may be changed \\(data descriptors only\\)."]
        pub writable: Option<bool>,
        #[serde(rename = "get", skip_serializing_if = "Option::is_none")]
        #[doc = "A function which serves as a getter for the property, or `undefined` if there is no getter\n\\(accessor descriptors only\\)."]
        pub get: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "set", skip_serializing_if = "Option::is_none")]
        #[doc = "A function which serves as a setter for the property, or `undefined` if there is no setter\n\\(accessor descriptors only\\)."]
        pub set: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "configurable")]
        #[doc = "True if the type of this property descriptor may be changed and if the property may be\ndeleted from the corresponding object."]
        pub configurable: bool,
        #[serde(rename = "enumerable")]
        #[doc = "True if this property shows up during enumeration of the properties on the corresponding\nobject."]
        pub enumerable: bool,
        #[serde(rename = "wasThrown", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the result was thrown during the evaluation."]
        pub was_thrown: Option<bool>,
        #[serde(rename = "isOwn", skip_serializing_if = "Option::is_none")]
        #[doc = "True if the property is owned for the object."]
        pub is_own: Option<bool>,
        #[serde(rename = "symbol", skip_serializing_if = "Option::is_none")]
        #[doc = "Property symbol object, if the property is of the `symbol` type."]
        pub symbol: Option<::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Object internal property descriptor. This property isn't normally visible in JavaScript code."]
    pub struct InternalPropertyDescriptor<'a> {
        #[serde(rename = "name")]
        #[doc = "Conventional property name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "The value associated with the property."]
        pub value: Option<::runtime::RemoteObject<'a>>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Represents function call argument. Either remote object id `objectId`, primitive `value`,\nunserializable primitive value or neither of \\(for undefined\\) them should be specified."]
    pub struct CallArgument<'a> {
        #[serde(rename = "value", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value or serializable javascript object."]
        pub value: Option<::serde_json::Value>,
        #[serde(rename = "unserializableValue", skip_serializing_if = "Option::is_none")]
        #[doc = "Primitive value which can not be JSON-stringified."]
        pub unserializable_value: Option<::runtime::UnserializableValue<'a>>,
        #[serde(rename = "objectId", skip_serializing_if = "Option::is_none")]
        #[doc = "Remote object handle."]
        pub object_id: Option<::runtime::RemoteObjectId<'a>>,
    }
    #[doc = "Id of an execution context."]
    pub type ExecutionContextId = i32;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Description of an isolated world."]
    pub struct ExecutionContextDescription<'a> {
        #[serde(rename = "id")]
        #[doc = "Unique id of the execution context. It can be used to specify in which execution context\nscript evaluation should be performed."]
        pub id: ::runtime::ExecutionContextId,
        #[serde(rename = "origin")]
        #[doc = "Execution context origin."]
        pub origin: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "name")]
        #[doc = "Human readable name describing given context."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "auxData", skip_serializing_if = "Option::is_none")]
        #[doc = "Embedder-specific auxiliary data."]
        pub aux_data: Option<::Empty>,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Detailed information about exception \\(or error\\) that was thrown during script compilation or\nexecution."]
    pub struct ExceptionDetails<'a> {
        #[serde(rename = "exceptionId")]
        #[doc = "Exception id."]
        pub exception_id: i32,
        #[serde(rename = "text")]
        #[doc = "Exception text, which should be used together with exception object when available."]
        pub text: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        #[doc = "Line number of the exception location \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "Column number of the exception location \\(0-based\\)."]
        pub column_number: i32,
        #[serde(rename = "scriptId", skip_serializing_if = "Option::is_none")]
        #[doc = "Script ID of the exception location."]
        pub script_id: Option<::runtime::ScriptId<'a>>,
        #[serde(rename = "url", skip_serializing_if = "Option::is_none")]
        #[doc = "URL of the exception location, to be used when the script was not reported."]
        pub url: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "stackTrace", skip_serializing_if = "Option::is_none")]
        #[doc = "JavaScript stack trace if available."]
        pub stack_trace: Option<::runtime::StackTrace<'a>>,
        #[serde(rename = "exception", skip_serializing_if = "Option::is_none")]
        #[doc = "Exception object if available."]
        pub exception: Option<::runtime::RemoteObject<'a>>,
        #[serde(rename = "executionContextId", skip_serializing_if = "Option::is_none")]
        #[doc = "Identifier of the context where exception happened."]
        pub execution_context_id: Option<::runtime::ExecutionContextId>,
    }
    #[doc = "Number of milliseconds since epoch."]
    pub type Timestamp = f64;
    #[doc = "Number of milliseconds."]
    pub type TimeDelta = f64;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Stack entry for runtime errors and assertions."]
    pub struct CallFrame<'a> {
        #[serde(rename = "functionName")]
        #[doc = "JavaScript function name."]
        pub function_name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "scriptId")]
        #[doc = "JavaScript script id."]
        pub script_id: ::runtime::ScriptId<'a>,
        #[serde(rename = "url")]
        #[doc = "JavaScript script name or url."]
        pub url: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "lineNumber")]
        #[doc = "JavaScript script line number \\(0-based\\)."]
        pub line_number: i32,
        #[serde(rename = "columnNumber")]
        #[doc = "JavaScript script column number \\(0-based\\)."]
        pub column_number: i32,
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Call frames for assertions or error messages."]
    pub struct StackTrace<'a> {
        #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
        #[doc = "String label of this stack trace. For async traces this may be a name of the function that\ninitiated the async call."]
        pub description: Option<::std::borrow::Cow<'a, str>>,
        #[serde(rename = "callFrames")]
        #[doc = "JavaScript function name."]
        pub call_frames: Vec<::runtime::CallFrame<'a>>,
        #[serde(rename = "parent", skip_serializing_if = "Option::is_none")]
        #[doc = "Asynchronous JavaScript stack trace that preceded this stack, if available."]
        pub parent: Option<Box<::runtime::StackTrace<'a>>>,
        #[serde(rename = "parentId", skip_serializing_if = "Option::is_none")]
        #[doc = "<span class=\"stab unstable\">[Experimental]</span> Asynchronous JavaScript stack trace that preceded this stack, if available."]
        pub parent_id: Option<::runtime::StackTraceId<'a>>,
    }
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> Unique identifier of current debugger."]
    pub type UniqueDebuggerId<'a> = ::std::borrow::Cow<'a, str>;
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "<span class=\"stab unstable\">[Experimental]</span> If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This\nallows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages."]
    pub struct StackTraceId<'a> {
        #[serde(rename = "id")]
        pub id: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "debuggerId", skip_serializing_if = "Option::is_none")]
        pub debugger_id: Option<::runtime::UniqueDebuggerId<'a>>,
    }
}
#[doc = "# Schema\n\n## Commands\n\n- [`Schema.getDomains`](struct.GetDomainsCommand.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated.</span>\n\n  Returns supported domains.\n\n##Types\n\n- [`Domain`](struct.Domain.html)\n  \n  <span class=\"stab deprecated\">This domain is deprecated.</span>\n\n  Description of the protocol domain.\n"]
#[deprecated(note = "This domain is deprecated.")]
pub mod schema {
    #[derive(Clone, Debug, PartialEq)]
    #[doc = "Returns supported domains.\n\n# Command `Schema.getDomains`\n\n*Domain Module:* [`cdp::schema`](index.html)  \n*Command Struct:* [`cdp::schema::GetDomainsCommand`](struct.GetDomainsCommand.html)  \n*Response Struct:* [`cdp::schema::GetDomainsResponse`](struct.GetDomainsResponse.html)"]
    #[deprecated(note = "This domain is deprecated.")]
    pub struct GetDomainsCommand;
    impl ::serde::Serialize for GetDomainsCommand {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(&::Empty, serializer)
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetDomainsCommand {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            <::Empty as ::serde::Deserialize<'de>>::deserialize(deserializer)
                .map(|_| GetDomainsCommand)
        }
    }
    impl ::CdpCommand for GetDomainsCommand {
        const COMMAND_NAME: &'static str = "Schema.getDomains";
    }
    impl ::SerializeCdpCommand for GetDomainsCommand {
        fn command_name(&self) -> &str {
            "Schema.getDomains"
        }
        fn serialize_command_params<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: ::serde::Serializer,
        {
            ::serde::Serialize::serialize(self, serializer)
        }
    }
    impl<'de> ::DeserializeCdpCommand<'de> for GetDomainsCommand {
        fn deserialize_command<D>(name: &str, params: D) -> Result<Result<Self, D::Error>, D>
        where
            D: ::serde::Deserializer<'de>,
        {
            if name == "Schema.getDomains" {
                Ok(
                    <GetDomainsCommand as ::serde::Deserialize<'de>>::deserialize(params),
                )
            } else {
                Err(params)
            }
        }
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Returns supported domains.\n\n# Command `Schema.getDomains`\n\n*Domain Module:* [`cdp::schema`](index.html)  \n*Command Struct:* [`cdp::schema::GetDomainsCommand`](struct.GetDomainsCommand.html)  \n*Response Struct:* [`cdp::schema::GetDomainsResponse`](struct.GetDomainsResponse.html)"]
    #[deprecated(note = "This domain is deprecated.")]
    pub struct GetDomainsResponse<'a> {
        #[serde(rename = "domains")]
        #[doc = "List of supported domains."]
        pub domains: Vec<::schema::Domain<'a>>,
    }
    impl<'a> ::CdpCommand for GetDomainsResponse<'a> {
        const COMMAND_NAME: &'static str = "Schema.getDomains";
    }
    impl<'b> ::HasCdpResponse<'b> for GetDomainsCommand {
        type Response = GetDomainsResponse<'b>;
    }
    impl<'a, 'b> ::HasCdpCommand<'a> for GetDomainsResponse<'b> {
        type Command = GetDomainsCommand;
    }
    #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
    #[doc = "Description of the protocol domain."]
    #[deprecated(note = "This domain is deprecated.")]
    pub struct Domain<'a> {
        #[serde(rename = "name")]
        #[doc = "Domain name."]
        pub name: ::std::borrow::Cow<'a, str>,
        #[serde(rename = "version")]
        #[doc = "Domain version."]
        pub version: ::std::borrow::Cow<'a, str>,
    }
}
